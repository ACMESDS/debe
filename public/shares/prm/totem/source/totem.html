<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">&quot;use strict&quot;;

// UNCLASSIFIED 

<span id='TOTEM'>/**
</span>@class TOTEM

@requires http
@requires https
@requires fs
@requires constants
@requires clusters
@requires child-process
@requires os

@requires enum
@requires jsdb

@requires mime
@requires socket.io
@requires socket.io-clusterhub
@requires mysql
@requires xml2js
@requires toobusy
@requires json2csv
@requires js2xmlparser
@requires toobusy-js
 */

var // NodeJS modules
HTTP = require(&quot;http&quot;),
    //&lt; http interface
HTTPS = require(&quot;https&quot;),
    //&lt; https interface
CP = require(&quot;child_process&quot;),
    //&lt; spawn OS shell commands
FS = require(&quot;fs&quot;),
    //&lt; access file system
CONS = require(&quot;constants&quot;),
    //&lt; constants for setting tcp sessions
CLUSTER = require(&quot;cluster&quot;),
    //&lt; multicore  processing
URL = require(&quot;url&quot;),
    //&lt; url parsing
NET = require(&quot;net&quot;),
    // network interface
OS = require('os'); // OS utilitites

var // 3rd party modules
MIME = require(&quot;mime&quot;),
    //&lt; file mime types
SIO = require('socket.io'),
    //&lt; Socket.io client mesh
SIOHUB = require('socket.io-clusterhub'),
    //&lt; Socket.io client mesh for multicore app
MYSQL = require(&quot;mysql&quot;),
    //&lt; mysql conector
XML2JS = require(&quot;xml2js&quot;),
    //&lt; xml to json parser (*)
BUSY = require('toobusy-js'),
    //&lt; denial-of-service protector (cant install on NodeJS 5.x+)
JS2XML = require('js2xmlparser'),
    //&lt; JSON to XML parser
JS2CSV = require('json2csv'); //&lt; JSON to CSV parser	

var // Totem modules
JSDB = require(&quot;jsdb&quot;),
    //&lt; JSDB database agnosticator
ENUM = require(&quot;enum&quot;),
    //&lt; Basic enumerators
sqlThread = JSDB.thread,
    Copy = ENUM.copy,
    Each = ENUM.each,
    Log = console.log;

var TOTEM = module.exports = ENUM.extend({

<span id='TOTEM-cfg-dogs'>	/**
</span> @cfg {Object}
 Watchdogs {name: dog(sql, lims), ... } run every dog.cycle seconds with a dog.trace message using
 specified dog.parms.  When the watchdog is invoked it is given a sql connector and its lims attributes.
 */
	dogs: {//&lt; watchdog functions(sql, lims)
	},

	watchFile: function watchFile(area, name, cb) {
<span id='TOTEM-method-watchFile'>		/**
</span>  @private
  @method  watchFile
  Establish smart file watcher when file at area/name has changed.
  @param {String} area Name of folder being watched
  @param {String} name Name of file being watched
  @param {Function} callback cb(sql, name, path) when file at path has changed
  */
		var path = area + name,
		    watchMods = TOTEM.watchMods;

		Trace(&quot;WATCHING &quot; + name);

		watchMods[path] = 0;

		FS.watch(path, function (ev, file) {
			var path = area + file,
			    isSwap = file.charAt(0) == &quot;.&quot;;

			if (file &amp;&amp; !isSwap) switch (ev) {
				case &quot;change&quot;:
					sqlThread(function (sql) {
						Trace(ev.toUpperCase() + &quot; &quot; + file, sql);

						FS.stat(path, function (err, stats) {

							if (!err &amp;&amp; watchMods[path] - stats.mtime) {
								watchMods[path] = stats.mtime;
								cb(sql, file, path);
							}
						});
					});

					break;

				case &quot;delete&quot;:
				case &quot;rename&quot;:
				default:

			}
		});
	},

	createCert: createCert, //&lt; method to create PKI certificate

<span id='TOTEM-cfg-nodeDivider'>	/**
</span> @cfg {String}
 @member TOTEM
 Node divider NODE $$ NODE ....  (&quot;&quot; disables dividing).
 */
	nodeDivider: &quot;$$&quot;, //&lt; node divider

<span id='TOTEM-cfg-maxFiles'>	/**
</span> @cfg {Number}
 @member TOTEM
 Max files to index by the indexer() method (0 disables).
 */
	maxFiles: 100, //&lt; max files to index

<span id='TOTEM-cfg-IO'>	/**
</span> @cfg {Object}
 @private
 @member TOTEM
 Reserved for socket.io support to multiple clients
 */
	IO: null,

<span id='TOTEM-cfg-dsAttrs'>	/**
</span> @cfg {Object}
 @member TOTEM
 Reserved for dataset attributes derived by JSDB.config
 */
	dsAttrs: {},

	Array: [//&lt; Array prototypes

	function hyper(refs, arg) {
<span id='Array-method-rtns'>		/**
</span>  @private
  @member Array
  Returns list containing hyperlink list joined by an arg spearator.
  @param {Function} cb callback(val) returns item for join
  */
		var rtns = [],
		    ref = ref[0];
		this.each(function (n, lab) {
			rtns.push(lab.hyper(refs[n] || ref));
		});
		return rtns.join(arg);
	}, function treeify(idx, kids, level, piv, wt) {
<span id='Array-method-treeify'>		/**
</span>  @private
  @method treeify
  @member Array
  Returns list as a tree containing children,weight,name leafs.
  @param [Number] idx starting index (0 on first call)
  @param [Number] kids number of leafs following starting index (this.length on first call)
  @param [Number] level current depth (0 on first call)
  @param [Array] piv pivots
  @param [String] wt key name that contains leaf weight (defaults to &quot;size&quot;)
  */

		if (!wt) return this.treeify(0, recs.length, 0, idx, &quot;size&quot;);

		var recs = this;
		var key = piv[level];
		var levels = piv.length - 1;
		var ref = recs[idx][key];
		var len = 0;
		var pos = idx,
		    end = idx + kids;
		var tar = [];

		if (level &lt; levels) while (pos &lt; end) {
			var rec = recs[idx];
			var stop = idx == end ? true : rec[key] != ref;

			if (stop) {
				//Log([pos,idx,end,key,ref,recs.length]);

				var node = {
					name: key + &quot;:&quot; + ref,
					weight: len, //wt ? parseInt(rec[wt] || &quot;0&quot;) : 0,
					children: recs.treeify(pos, len, level + 1, piv, wt)
				};

				tar.push(node);
				pos = idx;
				len = 0;
				ref = idx == end ? null : recs[idx][key];
			} else {
				idx++;
				len++;
			}
		} else while (pos &lt; end) {
			var rec = recs[pos++];
			tar.push({
				name: key + &quot;:&quot; + rec[key],
				weight: wt ? parseInt(rec[wt] || &quot;1&quot;) : 1,
				doc: rec
			});
		}

		return tar;
	}],

	String: [//&lt; String prototypes

	function tag(el, at) {
<span id='TOTEM-method-tag'>		/**
</span>  * @method tag
  * Tag url (el=&quot;?&quot;) or tag html using specified attributes.
  * @param {String} el tag element
  * @param {String} at tag attributes
  * @return {String} tagged results
  */

		if (el == &quot;?&quot;) {
			// tag a url
			var rtn = this + &quot;?&quot;;

			if (at) for (var n in at) {
				rtn += n + &quot;=&quot;;
				switch ((at[n] || 0).constructor) {
					//case Array: rtn += at[n].join(&quot;,&quot;);	break;
					case Array:
					case Date:
					case Object:
						rtn += JSON.stringify(at[n]);break;
					default:
						rtn += at[n];
				}
				rtn += &quot;&amp;&quot;;
			}

			return rtn;
		} else {
			// tag html
			var rtn = &quot;&lt;&quot; + el + &quot; &quot;;

			if (at) for (var n in at) {
				rtn += n + &quot;='&quot; + at[n] + &quot;' &quot;;
			}switch (el) {
				case &quot;embed&quot;:
				case &quot;img&quot;:
				case &quot;link&quot;:
				case &quot;input&quot;:
					return rtn + &quot;&gt;&quot; + this;
				default:
					return rtn + &quot;&gt;&quot; + this + &quot;&lt;/&quot; + el + &quot;&gt;&quot;;
			}
		}
	}, function each(pat, rtn, cb) {
<span id='String-method-msg'>		/**
</span>  @private
  @member String
  Enumerate over pattern found in a string.
  @param {String} pat pattern to find
  @param {Array} rtn list being extended by callback
  @param {Function} cb callback(rtn)
  */

		var msg = this;

		while ((idx = msg.indexOf(pat)) &gt;= 0) {

			msg = msg.substr(0, idx) + cb(rtn) + msg.substr(idx + pat.length);
		}

		return msg;
	}, function format(req, plugin) {
<span id='Format'>		/**
</span>  @private
  @member String
  Return an EMAC &quot;...${...}...&quot; string using supplied req $-tokens and plugin methods.
  */

		function Format(X, S) {
			/*
    * Format a string S containing ${X.key} tags.  The String wrapper for this
    * method extends X with optional plugins like X.F = {fn: function (X){}, ...}.
    */

			try {
				return eval(&quot;`&quot; + S + &quot;`&quot;);
			} catch (err) {
				return S;
			}
		}

		req.plugin = req.F = plugin || {};
		return Format(req, this);
	}, function parseJSON(def) {
		try {
			return JSON.parse(this);
		} catch (err) {

			if (!def) // no default method so return null
				return null;else if (def.constructor == Function) // use supplied parse method
				return def(this);else return def;
		}
	}, function parseQuery(def) {
<span id='String-property-lastkey'>		/**
</span>  @private
  @member String
  Parse a &quot;&amp;key=val&amp;key=val?query&amp;relation&amp; ...&quot; query into 
  the default hash def = {key:val, key=val?query, relation:null, key:json, ...}.
  */

		var lastkey = &quot;&quot;;

		this.split(&quot;?&quot;).each(function (qn, query) {
			query.split(&quot;&amp;&quot;).each(function (pn, parm) {

				if (parm) if (qn) def[lastkey] += (pn ? &quot;&amp;&quot; : &quot;?&quot;) + parm;else {
					var parts = parm.split(&quot;=&quot;),
					    // split into key=val
					key = parts[0],
					    val = parm.substr(key.length + 1);

					if (key) // key = val used
						try {
							// val could be json 
							def[lastkey = key] = JSON.parse(val);
						} catch (err) {
							def[lastkey = key] = unescape(val);
						} else // store key relationship (e.g. key&lt;val or simply key)
						def[parm] = null;
				}
			});
		});

		//Log([this+&quot;&quot;, def]);
		return def;
	}, function parseXML(def, cb) {
<span id='String-property-'>		/**
</span>  @private
  @member String
  Callback cb(xml parsed) string
  */
		XML2JS.parseString(this, function (err, json) {
			cb(err ? def : json);
		});
	}, function hyper(ref) {
<span id='String-property-'>		/**
</span>  @private
  @member String
  Return a hyperlink of given label string.
  */
		if (ref) {
			if (ref.charAt(0) == &quot;:&quot;) return this.link(&quot;/&quot; + (ref.substr(1) || this.toLowerCase()) + &quot;.view&quot;);else return this.link(ref);
		} else return this.link(ref || &quot;/&quot; + this.toLowerCase() + &quot;.view&quot;);
	}],

<span id='TOTEM-cfg-config'>	/**
</span> @cfg {Function}
 @member TOTEM
 @method config
 Configure and start the service with options and optional callback when started.
 @param {Object} opts configuration options following ENUM.Copy() conventions
 @param {Function} cb callback(err) when service started
 */
	config: configService,

<span id='TOTEM-cfg-stop'>	/**
</span> @cfg {Function}
 @member TOTEM	
 @method stop
 Stop the server.
 */
	stop: stopService,

<span id='TOTEM-method-thread'>	/**
</span> @member TOTEM	
 @method thread
 Thread a new sql connection to a callback.  Unless overridden, will default to the JSDB thread method.
 @param {Function} cb callback(sql connector)
  * */
	thread: sqlThread,

<span id='TOTEM-cfg-crud'>	/**
</span> @cfg {Object}  
 @member TOTEM
 REST-to-CRUD translations
 */
	crud: {
		GET: &quot;select&quot;,
		DELETE: &quot;delete&quot;,
		POST: &quot;insert&quot;,
		PUT: &quot;update&quot;
	},

<span id='TOTEM-cfg-reqFlags'>	/**
</span> @cfg {Object} 
 @member TOTEM
 Options to parse request flags
 
 		traps: { flag:cb(query,flags), ...} // sets trap cb for a _flag=list to reorganize the query and flags hash,
 		edits: { flag:cb(list,data,req), ...} // sets data conversion cb for a _flag=list,
 		prefix:  &quot;_&quot; 	// sets flag prefix
 */
	reqFlags: { //&lt; Properties for request flags
		strips: //&lt; Flags to strips from request
		{ &quot;&quot;: 1, &quot;_&quot;: 1, leaf: 1, _dc: 1, id: 1, &quot;=&quot;: 1, &quot;?&quot;: 1, &quot;request&quot;: 1 },

		id: &quot;ID&quot;, //&lt; SQL record id
		prefix: &quot;_&quot;, //&lt; Prefix that indicates a field is a flag
		trace: &quot;_trace&quot; //&lt; Echo flags before and after parse		
	},

<span id='TOTEM-cfg-fetchers'>	/**
</span> @cfg {Object} 
 @member TOTEM
 Data fetcher X is used when a GET on X is requested.  Fetchers feed data pulled from the
 TOTEM.paths.url[req.table] URL (formatted by an optional plugin context) to its callback:
 
 		X: cb(url, res),
 		X: cb(...),
 		...
 		plugin: {
 			var: ...
 			var: ...
 			...
 			method: function () {...}
 			method: function () {...}
 			...
 		}
 */
	fetchers: { //&lt; data fetchers
		curl: curlFetch,
		wget: wgetFetch,
		http: httpFetch,
		plugin: { //&lt; example fetch url plugins
			ex1: function ex1(req) {
				return req.profile.QoS + req.profile.Credit;
			},
			ex2: &quot;save.file.jpg&quot;,
			wgetout: &quot;./shares/wget.out&quot;
		}
	},

<span id='TOTEM-cfg-mysql'>	/**
</span> @cfg {Object} 
 @member TOTEM
 Mysql connection options: 
 
 	host: name
 	user: name
 	pass: phrase
 	sessions: number	
 */
	mysql: null,

<span id='TOTEM-cfg-encrypt'>	/**
</span> @cfg {String} [encrypt=&quot;&quot;]
 @member TOTEM
 Cert passphrase to start encrypted service
 */
	encrypt: &quot;&quot;, //&lt; passphrase when service encypted 
	sockets: false, //&lt; enabled to support web sockets

<span id='TOTEM-cfg-cores'>	/**
</span> @cfg {Number} [cores=0]
 @member TOTEM	
 Number of worker cores (0 for master-only).  If cores&gt;0, masterport should != workPort, master becomes HTTP server, and workers
 become HTTP/HTTPS depending on encrypt option.  In the coreless configuration, master become HTTP/HTTPS depending on 
 encrypt option, and there are no workers.  In this way, a client can access stateless workers on the workerport, and stateful 
 workers via the masterport.	
 */
	cores: 0, //&lt; Number of worker cores (0 for master-only)

<span id='TOTEM-cfg-masterport'>	/**
</span> @cfg {Number} [masterport=8080]
 @member TOTEM	
 Port for master HTTP/HTTPS service.  If cores&gt;0, masterport should != workPort, master becomes HTTP server, and workers
 become HTTP/HTTPS depending on encrypt option.  In the coreless configuration, master become HTTP/HTTPS depending on 
 encrypt option, and there are no workers.  In this way, a client can access stateless workers on the workerport, and stateful 
 workers via the masterport.	
 */
	masterport: 8080, //&lt; master port for stateful threads
<span id='TOTEM-cfg-workerport'>	/**
</span> @cfg {Number} [workerport=8443]
 @member TOTEM	
 Port for worker HTTP/HTTPS service.  If cores&gt;0, masterport should != workPort, master becomes HTTP server, and workers
 become HTTP/HTTPS depending on encrypt option.  In the coreless configuration, master become HTTP/HTTPS depending on 
 encrypt option, and there are no workers.  In this way, a client can access stateless workers on the workerport, and stateful 
 workers via the masterport.	
 */
	workerport: 8443, //&lt; worker port for stateless threads

<span id='TOTEM-cfg-host'>	/**
</span> @cfg {String} [host=&quot;localhost&quot;]
 @member TOTEM	
 Service host name 
 */
	host: &quot;localhost&quot;, //&lt; Service host name 

<span id='TOTEM-cfg-watch'>	/**
</span> @cfg {Obect}
 @member TOTEM	
 Folder watching callbacks cb(path) 
 */
	watch: {//&lt; Folder watching callbacks cb(path) 
	},

	watchMods: {//&lt; List to track changed files as OS will trigger multiple change evented when file changed
	},

<span id='TOTEM-cfg-behindProxy'>	/**
</span> @cfg {Boolean} [behindProxy=false]
 @member TOTEM	
 Enable if https server being proxied
 */
	behindProxy: false, //&lt; Enable if https server being proxied

<span id='TOTEM-cfg-name'>	/**
</span> @cfg {String} [name=&quot;Totem&quot;]
 @member TOTEM	
 Name of this service used to
 	1) derive site parms from mysql openv.apps by Nick=name
 	2) set mysql name.table for guest clients,
 	3) identify server cert name.pfx file.
 If the Nick=name is not located in openv.apps, the supplied	config() options are not overridden.
 */
	name: &quot;Totem&quot;,

<span id='TOTEM-cfg-site'>	/**
</span> @cfg {Object} 
 @member TOTEM	
 Site context extended by the mysql derived query when service starts
 */
	site: {// reserved for derived context vars		
	},

<span id='TOTEM-cfg-reqTypes'>	/**
</span> @cfg {Object} 
 @member TOTEM	
 Endpoint reqTypes cb(ack data as string || error)
 */
	reqTypes: {
		db: function db(ack, req, res) {
			req.sql.query(&quot;select found_rows()&quot;).on('result', function (stat) {
				// records sourced from sql				
				res({
					success: true,
					msg: &quot;ok&quot;,
					count: stat[&quot;found_rows()&quot;] || 0,
					data: ack
				});
			}).on(&quot;error&quot;, function () {
				// records sourced from virtual table
				res({
					success: true,
					msg: &quot;ok&quot;,
					count: ack.length,
					data: ack
				});
			});
		},

		csv: function csv(ack, req, res) {
			JS2CSV({
				data: ack,
				fields: Object.keys(ack[0] || {})
			}, function (err, csv) {
				res(err || csv);
			});
		},

		&quot;&quot;: function _(ack, req, res) {
			res(ack);
		},

		json: function json(ack, req, res) {
			res(ack);
		},

		xml: function xml(ack, req, res) {
			res(JS2XML.parse(req.table, {
				count: ack.length,
				data: ack
			}));
		}
	},

<span id='TOTEM-cfg-byTable'>	/**
</span> @cfg {Object} 
 @member TOTEM	
 By-table endpoint routers {table: method(req,res), ... } for data fetchers, system and user management
 */
	byTable: {
		riddle: checkRiddle
	},

<span id='TOTEM-cfg-byAction'>	/**
</span> @cfg {Object} 
 @member TOTEM	
 By-action endpoint routers for accessing engines
 */
	byAction: {},

<span id='TOTEM-cfg-byType'>	/**
</span> @cfg {Object} 
 @member TOTEM	
 By-type endpoint routers  {type: method(req,res), ... } for accessing dataset readers
 */
	byType: {},

<span id='TOTEM-cfg-byArea'>	/**
</span> @cfg {Object} 
 @member TOTEM	
 By-area endpoint routers {area: method(req,res), ... } for sending/cacheing files
 */
	byArea: {},

<span id='TOTEM-cfg-byActionTable'>	/**
</span> @cfg {Object} 
 @member TOTEM	
 By-action-table endpoint routers {action: {table: method(req,res), ...}, ... } for accessing virtual tables
 */
	byActionTable: {
		select: {
			//user: selectUser
		},
		delete: {
			//user: deleteUser
		},
		update: {
			//user: updateUser
		},
		insert: {
			//user: insertUser
		},
		execute: {
			//user: executeUser
		}
	},

	fetch: {
		wget: fetchWget,
		curl: fetchCurl,
		http: fetchHttp
	},

<span id='TOTEM-cfg-trust'>	/**
</span> @cfg {Object} 
 @private
 @member TOTEM	
 Trust store extened with certs in the certs.truststore folder when the service starts in encrypted mode
 */
	trust: [],

<span id='TOTEM-cfg-server'>	/**
</span> @cfg {Object} 
 @private
 @member TOTEM	
 CRUDE (req,res) method to respond to Totem request
 */
	server: null,

	//======================================
	// CRUDE interface

<span id='TOTEM-cfg-select'>	/**
</span> @cfg {Function}
 @method select
 @member TOTEM	
 CRUDE (req,res) method to respond to a Totem request
 @param {Object} req Totem session request
 @param {Function} res Totem responder
 */
	select: selectDS,
<span id='TOTEM-cfg-update'>	/**
</span> @cfg {Function}	
 @method update
 @member TOTEM	
 CRUDE (req,res) method to respond to a Totem request
 @param {Object} req Totem session request
 @param {Function} res Totem responder
 */
	update: updateDS,
<span id='TOTEM-cfg-delete'>	/**
</span> @cfg {Function}	
 @method delete
 @member TOTEM	
 CRUDE (req,res) method to respond to a Totem request
 @param {Object} req Totem session request
 @param {Function} res Totem responder
 */
	delete: deleteDS,
<span id='TOTEM-cfg-insert'>	/**
</span> @cfg {Function}
 @method insert
 @member TOTEM	
 CRUDE (req,res) method to respond to a Totem request
 @param {Object} req Totem session request
 @param {Function} res Totem responder
 */
	insert: insertDS,
<span id='TOTEM-cfg-execute'>	/**
</span> @cfg {Function}
 @method execute
 @member TOTEM	
 CRUDE (req,res) method to respond to a Totem request
 @param {Object} req Totem session request
 @param {Function} res Totem responder
 */
	execute: executeDS,

	//======================================

<span id='TOTEM-cfg-started'>	/**
</span> @cfg {Date} 
 @private
 @member TOTEM	
 totem start time
 */
	started: null, //&lt; totem start time

<span id='TOTEM-cfg-retries'>	/**
</span> @cfg {Number} [retries=5]
 @member TOTEM	
 Maximum number of retries the data fetcher will user
 */
	retries: 5, //&lt; Maximum number of retries the data fetcher will user

<span id='TOTEM-cfg-notify'>	/**
</span> @cfg {Boolean} [notify=true]
 @member TOTEM	
 Enable/disable tracing of data fetchers
 */
	notify: true, //&lt; Enable/disable tracing of data fetchers

<span id='TOTEM-cfg-nofaults'>	/**
</span> @cfg {Boolean} [nofaults=false]
 @member TOTEM	
 Enable/disable service protection mode
 */
	nofaults: false, //&lt; Enable/disable service protection mode

<span id='TOTEM-cfg-protect'>	/**
</span> @cfg {Object} 
 @private
 @member TOTEM	
 Service protections when in nofaults mode
 */
	protect: {
		SIGUSR1: 1,
		SIGTERM: 1,
		SIGINT: 1,
		SIGPIPE: 1,
		SIGHUP: 1,
		SIGBREAK: 1,
		SIGWINCH: 1,
		SIGKILL: 1,
		SIGSTOP: 1
	},

<span id='TOTEM-cfg-validator'>	/**
</span> @cfg {Function} 
 @member TOTEM	
 Additional session validator(req,res) responds will null if client validated, otherwise
 responds with an error.
 */
	validator: null,

<span id='TOTEM-cfg-admitRule'>	/**
</span> @cfg {Object} 
 @member TOTEM	
 Null to admitRule all clients, or {X:&quot;required&quot;, Y: &quot;optional&quot;, ...} to admitRule clients with cert organizational
 credentials X.
 */
	admitRule: null,
	/*{ &quot;u.s. government&quot;: &quot;required&quot;,
   	&quot;us&quot;: &quot;optional&quot;
   }*/

<span id='TOTEM-cfg-guestProfile'>	/**
</span> @cfg {Object}
 @member TOTEM	
 Default guest profile (unencrypted or client profile not found)
 */
	guestProfile: {
		Banned: &quot;&quot;,
		QoS: 10000,
		Credit: 100,
		Charge: 0,
		LikeUs: 0,
		Challenge: 1,
		Client: &quot;guest@guest.org&quot;,
		User: &quot;guest@guest&quot;,
		Group: &quot;app&quot;,
		Repoll: true,
		Retries: 5,
		Timeout: 30,
		Message: &quot;Welcome guest - what is (riddle)?&quot;
	},

<span id='TOTEM-cfg-riddleMap'>	/**
</span> @cfg {Object} 
 @private
 @member TOTEM	
 Riddle digit-to-jpeg map (null to disable riddles)
 */
	riddleMap: {
		0: [&quot;10&quot;, &quot;210&quot;],
		1: [&quot;30&quot;, &quot;60&quot;],
		2: [&quot;50&quot;, &quot;160&quot;],
		3: [&quot;70&quot;, &quot;100&quot;],
		4: [&quot;20&quot;, &quot;90&quot;],
		5: [&quot;00&quot;, &quot;110&quot;],
		6: [&quot;130&quot;, &quot;180&quot;],
		7: [&quot;150&quot;, &quot;290&quot;],
		8: [&quot;170&quot;, &quot;310&quot;],
		9: [&quot;40&quot;, &quot;190&quot;]
	},

<span id='TOTEM-cfg-riddles'>	/**
</span> @cfg {Number} [riddles=0]
 @member TOTEM	
 Number of riddles to protect site (0 to disable anti-bot)
 */
	riddles: 0,

	//proxy: proxyService,  //&lt; default relay if needed
	isEncryptedWorker: false, //&lt; enabled by config if worker service is HTTPS encrypted
	//workers: [],

<span id='TOTEM-cfg-paths'>	/**
</span> @cfg {Object} 
 @private
 @member TOTEM	
 Default paths to service files
 */
	paths: {
		default: &quot;files/&quot;,

		url: {
			//fetch: &quot;http://localhost:8081?return=${req.query.file}&amp;opt=${plugin.ex1(req)+plugin.ex2}&quot;,
			//default: &quot;/home&quot;,
			//resetpass: &quot;/resetpass&quot;,
			wget: &quot;http://localhost:8081?return=${req.query.file}&amp;opt=${plugin.ex1(req)+plugin.ex2}&quot;,
			curl: &quot;http://localhost:8081?return=${req.query.file}&amp;opt=${plugin.ex1(req)+plugin.ex2}&quot;,
			http: &quot;http://localhost:8081?return=${req.query.file}&amp;opt=${plugin.ex1(req)+plugin.ex2}&quot;,
			socketio: &quot;/socket.io/socket.io.js&quot;,
			riddler: &quot;/riddle&quot;
		},

		certs: &quot;./certs/&quot;,

		mysql: {
			users: &quot;SELECT 'user' AS Role, group_concat(DISTINCT dataset SEPARATOR ';') AS Contact FROM app.dblogs WHERE instr(dataset,'@')&quot;,
			derive: &quot;SELECT *, count(ID) AS Count FROM openv.apps WHERE ? LIMIT 0,1&quot;,
			record: &quot;INSERT INTO app.dblogs SET ? ON DUPLICATE KEY UPDATE Actions=Actions+1, Transfer=Transfer+?, Delay=Delay+?, Event=?&quot;,
			search: &quot;SELECT * FROM app.files HAVING Score &gt; 0.1&quot;,
			credit: &quot;SELECT * FROM app.files LEFT JOIN openv.profiles ON openv.profiles.Client = files.Client WHERE least(?) LIMIT 0,1&quot;,
			upsession: &quot;INSERT INTO openv.sessions SET ? ON DUPLICATE KEY UPDATE Connects=Connects+1,?&quot;,
			challenge: &quot;SELECT *,count(ID) as Count FROM openv.profiles WHERE least(?) LIMIT 0,1&quot;,
			guest: &quot;SELECT * FROM openv.profiles WHERE Client='guest' LIMIT 0,1&quot;,
			pocs: &quot;SELECT lower(Hawk) AS Role, group_concat(DISTINCT Client SEPARATOR ';') AS Contact FROM openv.roles GROUP BY hawk&quot;
		},

		mime: { // default static file areas
			files: &quot;.&quot;, // path to shared files 
			captcha: &quot;.&quot;, // path to antibot captchas
			index: { // indexers
				files: &quot;indexer&quot;
			},
			extensions: {// extend mime types as needed
			}
		}
	},

<span id='TOTEM-cfg-admitGuests'>	/**
</span> @cfg {Boolean} 
 @member TOTEM	
 Enable to admit guest clients making https requests
 */
	admitGuests: true, //&lt; enable to admit guest clients making https requests

<span id='TOTEM-cfg-errors'>	/**
</span> @cfg {Object} 
 @private
 @member TOTEM	
 Error messages
 */
	errors: {
		pretty: function pretty(err) {
			return err + &quot;&quot;;
		},
		badMethod: new Error(&quot;unsupported request method&quot;),
		noProtocol: new Error(&quot;no protocol specified to fetch&quot;),
		noRoute: new Error(&quot;no endpoint here&quot;),
		badQuery: new Error(&quot;invalid query&quot;),
		badGroup: new Error(&quot;invalid group requested&quot;),
		lostConnection: new Error(&quot;client connection lost&quot;),
		noDB: new Error(&quot;database unavailable&quot;),
		noProfile: new Error(&quot;user profile could not be determined&quot;),
		failedUser: new Error(&quot;failed modification of user profile&quot;),
		missingPass: new Error(&quot;missing initial user password&quot;),
		expiredCert: new Error(&quot;cert expired&quot;),
		rejectedCert: new Error(&quot;cert rejected&quot;),
		tooBusy: new Error(&quot;too busy - try again later&quot;),
		noFile: new Error(&quot;file not found&quot;),
		noIndex: new Error(&quot;cannot index files here&quot;),
		badType: new Error(&quot;no such dataset type&quot;),
		badReturn: new Error(&quot;nothing returned&quot;),
		noSockets: new Error(&quot;socket.io failed&quot;),
		noService: new Error(&quot;no service  to start&quot;),
		noData: new Error(&quot;no data returned&quot;),
		retryFetch: new Error(&quot;data fetch retries exceeded&quot;),
		notAllowed: new Error(&quot;this dataset interface is disabled&quot;),
		noAccess: new Error(&quot;no access to master core at this endpoint&quot;)
	},

<span id='TOTEM-cfg-indexer'>	/**
</span> @method 
 @cfg {Function}
 @member TOTEM	
 	File indexer
 */
	indexer: indexFile,

<span id='TOTEM-cfg-uploader'>	/**
</span> @cfg {Function}
 @method uploader
 @member TOTEM	
 File uploader 
 */
	uploader: pipeFile,

<span id='TOTEM-cfg-busycycle'>	/**
</span> @cfg {Number}
 @member TOTEM	
 Server toobusy check period in seconds
 */
	busycycle: 5000, //&lt; site too-busy check interval [ms] (0 disables)

<span id='TOTEM-cfg-setContext'>	/**
</span> @cfg {Function}
 @private
 @member TOTEM	
 Sets the site context parameters available in TOTEM.site.
 */
	setContext: function setContext(sql, cb) {
		var site = TOTEM.site,
		    paths = TOTEM.paths,
		    mysql = paths.mysql;

		site.pocs = {};
		site.distro = {};

		if (pocs = mysql.pocs) sql.query(pocs).on(&quot;result&quot;, function (poc) {
			site.pocs[poc.Role] = poc.Contact;
			site.distro[poc.Role] = poc.Role.link(&quot;mailto:&quot; + poc.Contact);
		});

		if (users = mysql.users) sql.query(users).on(&quot;result&quot;, function (poc) {
			site.pocs[poc.Role] = poc.Contact;
			site.distro[poc.Role] = poc.Role.link(&quot;mailto:&quot; + poc.Contact);
		});

		if (guest = mysql.guest) sql.query(guest).on(&quot;result&quot;, function (rec) {
			TOTEM.guestProfile = Copy(rec, {});
		});

		if (derive = mysql.derive) // derive site context vars
			sql.query(derive, { Nick: TOTEM.name }).on(&quot;result&quot;, function (opts) {

				if (opts.Count) Each(opts, function (key, val) {
					key = key.toLowerCase();
					site[key] = val;

					if ((val || 0).constructor == String) try {
						site[key] = JSON.parse(val);
					} catch (err) {}

					if (key in TOTEM) TOTEM[key] = site[key];
				});

				if (cb) cb();
			}).on(&quot;error&quot;, function (err) {
				Log(err);
				throw TOTEM.errors.noDB;
			});
			/*
   sql.indexJsons( &quot;openv.apps&quot;, {}, function (jsons) {	// get site json vars
   }); */

		else if (cb) cb();
	},

<span id='TOTEM-cfg-cache'>	/**
</span> @cfg {Object} 
 @member TOTEM	
 @private
 */
	cache: { //&lt; cacheing options

		never: { //&lt; files to never cache - useful while debugging client side stuff
			&quot;base.js&quot;: 1,
			&quot;extjs.js&quot;: 1,
			&quot;jquery.js&quot;: 1,
			&quot;flow.js&quot;: 1,
			&quot;dojo.js&quot;: 1,
			&quot;games.js&quot;: 1,
			&quot;capture.js&quot;: 1,
			&quot;jade&quot;: 1,
			&quot;view&quot;: 1,
			&quot;gif&quot;: 1
		},

		clients: { // byType cache of clients area
			js: {},
			css: {},
			ico: {}
		},

		&quot;socket.io&quot;: { // byType cache of socketio area
			js: {}
		},

		learnedTables: true,

		certs: {} // reserved for client crts (pfx, crt, and key reserved for server)
	},

<span id='TOTEM-cfg-Function'>	/**
</span> @cfg {Object} 
 @private
 @member TOTEM	
 ENUM will callback this initializer when the service is started
 */
	Function: Initialize //&lt; added to ENUM callback stack

});

<span id='TOTEM'>/**
</span> * @class TOTEM
 **/

function selectDS(req, res) {
	//&lt; Default virtual table logic is real table
<span id='TOTEM-method-deleteDS'>	/**
</span>  * @private
  * @method deleteDS
  * @param {Object} req Totem's request
  * @param {Function} res Totem's response callback
  * */
	if (TOTEM.mysql) req.sql.query(&quot;SELECT * FROM ??.??&quot;, [req.group, req.table], function (err, data) {
		res(err || data);
	});else res(TOTEM.errors.noDB);
}

function updateDS(req, res) {
<span id='TOTEM-method-updateDS'>	/**
</span>  * @private
  * @method updateDS
  * @param {Object} req Totem's request
  * @param {Function} res Totem's response callback
  * */
	res(TOTEM.paths.TOTEM.errors.noRoute);
}

function insertDS(req, res) {
<span id='TOTEM-method-insertDS'>	/**
</span>  * @private
  * @method insertDS
  * @param {Object} req Totem's request
  * @param {Function} res Totem's response callback
  * */
	res(TOTEM.paths.TOTEM.errors.notAllowed);
}

function deleteDS(req, res) {
<span id='TOTEM-method-deleteDS'>	/**
</span>  * @private
  * @method deleteDS
  * @param {Object} req Totem's request
  * @param {Function} res Totem's response callback
  * */
	res(TOTEM.paths.TOTEM.errors.notAllowed);
}

function executeDS(req, res) {
<span id='TOTEM-method-executeDS'>	/**
</span>  * @private
  * @method executeDS
  * @param {Object} req Totem's request
  * @param {Function} res Totem's response callback
  * */
	res(TOTEM.paths.TOTEM.errors.notAllowed);
}

<span id='TOTEM'>/**
</span> * @class TOTEM
 **/

function configService(opts, cb) {
<span id='TOTEM-method-configService'>	/**
</span>  * @private
  * @method configService
  * Configure, protect, connect, then start this server.
  * @param {Object} opts configuration options following the ENUM.Copy() conventions.
  * @param {Function} cb callback() after service configured
  * */

	TOTEM.extend(opts);

	var name = TOTEM.name,
	    mysql = TOTEM.mysql,
	    paths = TOTEM.paths,
	    site = TOTEM.site;

	Trace(&quot;CONFIG &quot; + name);

	TOTEM.started = new Date();

	Copy(paths.mime.extensions, MIME.types);

	if (mysql) JSDB.config({ // establish the db agnosticator 
		//io: TOTEM.IO,   // cant set socketio until after server defined by startService

		fetchers: TOTEM.fetchers,

		mysql: Copy({
			opts: {
				host: mysql.host, // hostname 
				user: mysql.user, // username
				password: mysql.pass, // passphrase
				connectionLimit: mysql.sessions || 100, // max simultaneous connections
				//acquireTimeout : 10000, 			// connection acquire timer
				queueLimit: 100, // max concections to queue (0=unlimited)
				waitForConnections: true // allow connection requests to be queued
			}
		}, mysql)
	}, function (sql) {
		// derive server vars and site context vars

		Trace(&quot;DERIVE &quot; + name);

		for (var n in mysql) {
			// derive server paths
			if (n in paths) paths[n] = mysql[n];
		}if (name) // derive site context
			TOTEM.setContext(sql, function () {
				protectService(cb || function (err) {
					Trace(err || &quot;STARTED &quot; + name + &quot; ENCRYPTED&quot;, sql);
				});
			});

		//TOTEM.dsAttrs = JSDB.dsAttrs;
		sql.release();
	});else protectService(cb || function (err) {
		Trace(err || &quot;STARTED &quot; + name + &quot; UNENCRYPTED&quot;, sql);
	});

	return TOTEM;
}

function startService(server, cb) {
<span id='TOTEM-method-startService'>	/**
</span>  * @private
  * @method startService
  * Attach the responder to this server then initialized.
  * @param {Object} server HTTP/HTTP server
  * @param {Function} cb callback(err) when service initialized.
  * */

	var name = TOTEM.name,
	    site = TOTEM.site,
	    paths = TOTEM.paths;

	Trace(&quot;START &quot; + name);

	TOTEM.server = server || { // define server
		listen: function listen() {
			Trace(&quot;NO SERVER&quot;);
		},
		on: function on() {
			Trace(&quot;NO SERVER&quot;);
		}
	};

	if (server &amp;&amp; name) {
		// attach responder
		//server.on(&quot;connection&quot;, simThread);

		server.on(&quot;request&quot;, sesThread);
	} else return cb(TOTEM.errors.noService);

	TOTEM.flush(); // flush enum's config callback stack

	if (TOTEM.isEncryptedWorker &amp;&amp; site.urls.socketio) {
		// attach &quot;/socket.io&quot; with SIO and setup connection listeners
		var IO = TOTEM.IO = JSDB.io = SIO(server, {// use defaults but can override ...
			//serveClient: true, // default true to prevent server from intercepting path
			//path: &quot;/socket.io&quot; // default get-url that the client-side connect issues on calling io()
		}),
		    HUBIO = TOTEM.HUBIO = new SIOHUB(); //&lt; Hub fixes socket.io+cluster bug	

		if (IO) {
			// Setup client web-socket support
			Trace(&quot;ATTACH SOCKETS AT &quot; + IO.path());

			IO.on(&quot;connection&quot;, function (socket) {
				// Trap every connect				
				//Trace(&quot;&gt;ALLOW CLIENT CONNECTIONS&quot;);
				socket.on(&quot;select&quot;, function (req) {
					// Trap connect raised on client &quot;select/join request&quot;

					Trace(&quot;&gt;CONNECTING &quot; + req.client);
					sqlThread(function (sql) {

						var ses = {
							Client: req.client,
							Location: req.location,
							Connects: 1,
							ipAddress: req.ip,
							Joined: new Date(),
							Message: req.message
						};

						if (upsession = paths.mysql.upsession) sql.query(upsession, [ses, {
							Location: req.location,
							ipAddress: req.ip,
							Joined: new Date()
						}]);

						if (challenge = paths.mysql.challenge) sql.query(challenge, { Client: req.client, Challenge: 1 }).on(&quot;result&quot;, function (profile) {

							if (profile.Count) challengeClient(req.client, profile);
						});

						sql.release();
					});
				});
			});

			/*
   IO.on(&quot;connect_error&quot;, function (err) {
   	Log(err);
   });
   
   IO.on(&quot;disconnection&quot;, function (socket) {
   	Log(&quot;&gt;&gt;DISCONNECT CLIENT&quot;);
   });	*/

			cb(null);
		} else return cb(TOTEM.errors.noSockets);
	} else cb(null);

	// The BUSY interface provides a mean to limit client connections that would lock the 
	// service (down deep in the tcp/icmp layer).  Busy thus helps to thwart denial of 
	// service attacks.  (Alas latest versions do not compile in latest NodeJS.)

	if (BUSY &amp;&amp; TOTEM.busycycle) BUSY.maxLag(TOTEM.busycycle);

	// listening on-routes message

	if (TOTEM.cores) {
			// Start for master-workers
			if (CLUSTER.isMaster) {
				// Establish master port

				server.listen(TOTEM.masterport, function () {
					// Establish master
					Trace(&quot;SERVE &quot; + site.urls.master);
				});

				CLUSTER.on('exit', function (worker, code, signal) {
					Trace(&quot;TERMINATE core-&quot; + worker.id + &quot; &quot; + (code || &quot;ok&quot;));
				});

				CLUSTER.on('online', function (worker) {
					Trace(&quot;CONNECT core-&quot; + worker.id);
				});

				for (var core = 0; core &lt; TOTEM.cores; core++) {
					worker = CLUSTER.fork();
					Trace(&quot;FORK core-&quot; + worker.id);
				}
			} else // Establish worker port			
				server.listen(TOTEM.workerport, function () {
					Trace(&quot;SERVE &quot; + site.urls.worker + &quot; ON core-&quot; + CLUSTER.worker.id);
				});
	} else // Establish master-only
		server.listen(TOTEM.workerport, function () {
			Trace(&quot;SERVE &quot; + site.urls.master);
		});

	if (TOTEM.nofaults) {
		// catch core faults
		process.on(&quot;uncaughtException&quot;, function (err) {
			console.warn(&quot;SERVICE FAULTED &quot; + err);
		});

		process.on(&quot;exit&quot;, function (code) {
			console.warn(&quot;SERVICE EXITED &quot; + code);
		});

		for (var n in TOTEM.nofaults) {
			process.on(n, function () {
				console.warn(&quot;SERVICE SIGNALED &quot; + n);
			});
		}
	}

	if (CLUSTER.isMaster) sqlThread(function (sql) {
		initializeService(sql);
	});
}

function connectService(cb) {
<span id='TOTEM-method-connectService'>	/**
</span>  * @private
  * @method connectService
  * If the TOTEM server already connected, inherit the server; otherwise
  * define an the apprpriate http interface (https if encrypted, 
  * http if unencrypted), then start the server.
  * @param {Function} cb callback when done
  * */

	var name = TOTEM.name,
	    paths = TOTEM.paths,
	    certs = TOTEM.cache.certs;

	if (TOTEM.isEncryptedWorker) {

		Copy({ // cache server data fetching certs 
			pfx: FS.readFileSync(&quot;&quot; + paths.certs + name + &quot;.pfx&quot;),
			crt: &quot;&quot; + paths.certs + name + &quot;.crt&quot;,
			key: &quot;&quot; + paths.certs + name + &quot;.key&quot;
		}, certs);

		//Log({certcache: certs});

		try {
			// build the trust strore
			Each(FS.readdirSync(paths.certs + &quot;/truststore&quot;), function (n, file) {
				if (file.indexOf(&quot;.crt&quot;) &gt;= 0 || file.indexOf(&quot;.cer&quot;) &gt;= 0) {
					Trace(&quot;TRUSTING &quot; + file);
					TOTEM.trust.push(FS.readFileSync(paths.certs + &quot;truststore/&quot; + file, &quot;utf8&quot;));
				}
			});
		} catch (err) {}

		startService(HTTPS.createServer({
			passphrase: TOTEM.encrypt, // passphrase for pfx
			pfx: certs.pfx, // TOTEM.paths's pfx/p12 encoded crt+key TOTEM.paths
			ca: TOTEM.trust, // list of TOTEM.paths authorities (trusted serrver.trust)
			crl: [], // pki revocation list
			requestCert: true,
			rejectUnauthorized: true
			//secureProtocol: CONS.SSL_OP_NO_TLSv1_2
		}), cb);
	}

	//else
	//if (CLUSTER.isMaster &amp;&amp; TOTEM.cores)
	//	startService( NET.createServer(), cb );

	else startService(HTTP.createServer(), cb);
}

function protectService(cb) {
<span id='TOTEM-method-protectService'>	/**
</span>  * @private
  * @method protectService
  * Create the server's PKI certs (if they dont exist), setup its urls, then connect the service.
  * @param {Function} cb callback when done
  * 
  * */

	var name = TOTEM.name,
	    dom = (TOTEM.encrypt ? &quot;https://&quot; : &quot;http://&quot;) + TOTEM.host,
	    paths = TOTEM.paths,
	    sock = TOTEM.sockets ? paths.url.socketio : &quot;&quot;,
	    pfxfile = &quot;&quot; + paths.certs + name + &quot;.pfx&quot;;

	Trace(&quot;PROTECT &quot; + name);

	TOTEM.site.urls = TOTEM.cores ? { // establish site urls
		socketio: sock,
		worker: dom + &quot;:&quot; + TOTEM.workerport,
		master: &quot;http://&quot; + TOTEM.host + &quot;:&quot; + TOTEM.masterport
	} : {
		socketio: sock,
		worker: dom + &quot;:&quot; + TOTEM.workerport,
		master: dom + &quot;:&quot; + TOTEM.workerport
	};

	if (TOTEM.isEncryptedWorker = TOTEM.encrypt &amp;&amp; (CLUSTER.isWorker || !TOTEM.cores)) // derive a pfx cert if this is an encrypted service
		FS.access(pfxfile, FS.F_OK, function (err) {

			if (err) {
				var owner = TOTEM.name;
				Trace(&quot;CREATE SERVERCERT FOR &quot; + owner);

				createCert(owner, TOTEM.encrypt, function () {
					connectService(cb);
				});
			} else connectService(cb);
		});else connectService(cb);
}

function stopService() {
<span id='TOTEM-method-stopService'>	/**
</span>  * @private
  * @method stopService
  * Stop the server.
  * */

	var server = TOTEM.server;

	if (server) server.close(function () {
		Trace(&quot;STOP &quot; + TOTEM.name);
	});
}

function initializeService(sql) {

	// clear system logs

	sql.query(&quot;DELETE FROM openv.syslogs&quot;);

	// initialize file watcher

	sql.query(&quot;UPDATE app.files SET State='watching' WHERE Area='uploads' AND State IS NULL&quot;);

	var watchMods = TOTEM.watchMods;

	Each(TOTEM.watch, function (area, cb) {
		// callback cb(sql,name,area) when file changed
		FS.readdir(area, function (err, files) {
			if (err) Trace(err);else files.each(function (n, file) {

				if (file.charAt(0) != &quot;.&quot;) TOTEM.watchFile(area, file, cb);
			});
		});
	});

	// start watch dogs

	Each(TOTEM.dogs, function (key, dog) {
		if (dog.cycle) {
			Trace(&quot;DOGGING &quot; + key);
			setInterval(function (args) {

				Trace(&quot;DOG &quot; + args.name);

				sqlThread(function (sql) {
					dog(sql, dog);
				});
			}, dog.cycle * 1e3, {
				name: key
			});
		}
	});
}

<span id='USER_MAINT'>/**
</span>@class USER_MAINT reserved for endpoints to manage users and their profiles.
 */

function selectUser(req, res) {
<span id='USER_MAINT-method-selectUser'>	/**
</span> @private
 @method selectUser
 Return user profile information
 @param {Object} req Totem session request 
 @param {Function} res Totem response
  */

	var sql = req.sql,
	    query = req.query || 1,
	    isHawk = req.cert.isHawk;

	isHawk = 1;
	if (isHawk) Trace(sql.query(&quot;SELECT * FROM openv.profiles WHERE least(?,1)&quot;, [query], function (err, users) {
		res(err || users);
	}).sql);else sql.query(&quot;SELECT * FROM openv.profiles WHERE ? AND least(?,1)&quot;, [{ client: req.client }, req.query], function (err, users) {
		res(err || users);
	});
}

function updateUser(req, res) {
<span id='USER_MAINT-method-updateUser'>	/**
</span> @private
 @method updateUser
 Update user profile information
 @param {Object} req Totem session request 
 @param {Function} res Totem response
  */

	var sql = req.sql,
	    query = req.query,
	    isHawk = req.cert.isHawk;

	if (sql.query) {
		if (isHawk)
			// sql.context({users:{table:&quot;openv.profile&quot;,where:{client:query.user},rec:query}});
			Trace(sql.query(&quot;UPDATE openv.profiles SET ? WHERE ?&quot;, [query, { client: query.user }], function (err, info) {
				res(err || TOTEM.errors.failedUser);
			}).sql);else sql.query(&quot;UPDATE openv.profiles SET ? WHERE ?&quot;, [query, { client: req.client }], function (err, info) {

			res(err || TOTEM.errors.failedUser);
		});
	} else res(TOTEM.errors.failedUser);
}

function deleteUser(req, res) {
<span id='USER_MAINT-method-deleteUser'>	/**
</span> @private
 @method deleteUser
 Remove user profile.
 @param {Object} req Totem session request 
 @param {Function} res Totem response
  */

	var sql = req.sql,
	    query = req.query,
	    isHawk = req.cert.isHawk;

	if (query) {
		if (isHawk)
			// sql.context({users:{table:&quot;openv.profiles&quot;,where:[ {client:query.user}, req.query ],rec:res}});
			Trace(sql.query(&quot;TEST FROM openv.profiles WHERE ? AND least(?,1)&quot;, [{ client: query.user }, req.query], function (err, info) {
				res(err || TOTEM.errors.failedUser);

				// res should remove their files and other 
				// allocated resources
			}).sql);else sql.query(&quot;TEST FROM openv.profiles WHERE ? AND least(?,1)&quot;, [{ client: req.client }, req.query], function (err, info) {
			res(err || TOTEM.errors.failedUser);
		});
	} else res(TOTEM.errors.failedUser);
}

function insertUser(req, res) {
<span id='USER_MAINT-method-insertUser'>	/**
</span> @private
 @method insertUser
 Create user profile, associated certs and distribute info to user
 @param {Object} req Totem session request 
 @param {Function} res Totem response
  */

	var sql = req.sql,
	    query = req.query || {},
	    isHawk = req.cert.isHawk;

	var url = TOTEM.paths.url;

	if (req.cert.isHawk) {
		if (query.pass) sql.query(&quot;SELECT * FROM openv.profiles WHERE Requested AND NOT Approved AND least(?,1)&quot;, query.user ? { User: query.user } : 1).on(&quot;result&quot;, function (user) {
			var init = Copy({
				Approved: new Date(),
				Banned: url.resetpass ? &quot;Please &quot; + &quot;reset your password&quot;.tag(&quot;a&quot;, { href: url.resetpass }) + &quot; to access&quot; : &quot;&quot;,

				Client: user.User,
				QoS: 0,

				Message: (&quot;Greetings from &quot; + site.Nick.tag(&quot;a&quot;, { href: site.urls.master }) + &quot;-\n\nAdmin:\n\tPlease create an AWS EC2 account for &quot; + owner + &quot; using attached cert.\n\nTo connect to &quot; + site.Nick + &quot; from Windows:\n\n1. Establish gateway using \n\n\t\tPutty | SSH | Tunnels\n\t\t\n\twith the following LocalPort, RemotePort map:\n\t\n\t\t5001, &quot; + site.urls.master + &quot;:22\n\t\t5100, &quot; + site.urls.master + &quot;:3389\n\t\t5200, &quot; + site.urls.master + &quot;:8080\n\t\t5910, &quot; + site.urls.master + &quot;:5910\n\t\t5555, Dynamic\n\t\n\tand, for convienience:\n\n\t\tPageant | Add Keys | your private ppk cert\n\n2. Start a &quot; + site.Nick + &quot; session using one of these methods:\n\n\t&quot; + Putty + &quot; | Session | Host Name = localhost:5001 \n\tRemote Desktop Connect| Computer = localhost:5100 \n\t&quot; + FF + &quot; | Options | Network | Settings | Manual Proxy | Socks Host = localhost, Port = 5555, Socks = v5 &quot;).replace(/\n/g, &quot;&lt;br&gt;&quot;)

			}, Copy(TOTEM.guestProfile, {}));

			sql.query(&quot;UPDATE openv.profiles SET ? WHERE ?&quot;, [init, { User: user.User }], function (err) {

				createCert(user.User, pass, function () {

					Trace(&quot;CREATE CERT FOR &quot; + user.User, sql);

					CP.exec(&quot;sudo adduser &quot; + user.User + &quot; -gid &quot; + user.Group + &quot;; sudo id &quot; + user.User, function (err, out) {

						sql.query(&quot;UPDATE openv.profiles SET ? WHERE ?&quot;, [{ uid: out }, { User: user.User }]);

						Log(err ? &quot;Account failed for &quot; + user.User + &quot; - require \&quot;sudo adduser\&quot; to protect this service&quot; : &quot;Account created and group rights assigned to &quot; + user.User);
					});
				});
			});
		}).on(&quot;end&quot;, function () {
			res(&quot;User creation working&quot;);
		});else res(TOTEM.errors.missingPass);
	} else sql.query(&quot;INSERT openv.profiles SET ? WHERE ?&quot;, [req.query, { User: req.User }], function (err, info) {

		res(err || TOTEM.errors.failedUser);
	});
}

function executeUser(req, res) {
<span id='USER_MAINT-method-executeUser'>	/**
</span> @private
 @method executeUser
 Fetch user profile for processing
 @param {Object} req Totem session request 
 @param {Function} res Totem response
  */
	var access = TOTEM.user,
	    query = req.query;

	query.user = query.user || query.select || query.delete || query.update || query.insert;

	if (access) {
		for (var n in { select: 1, delete: 1, update: 1, insert: 1 }) {
			if (query[n]) {
				delete query[n];
				return access[n](req, res);
			}
		}if (call = query.call) {
			delete query.call;
			return access[call](req, res);
		}
	}

	res(TOTEM.errors.failedUser);
}

<span id='PKI_CERTS'>/**
</span>@class PKI_CERTS utilities to create and manage PKI certs
 */

function createCert(owner, pass, cb) {
<span id='PKI_CERTS-method-createCert'>	/**
</span> @private
 @method createCert
 Create a cert for the desired owner with the desired passphrase then callback cb() when complete.
 @param {String} owner userID to own this cert
 @param {String} password for this cert
 @param {Function} cb callback when completed
 */

	function traceExecute(cmd, cb) {

		Trace(cmd.replace(/\n/g, &quot;\\n&quot;));

		CP.exec(cmd, function (err) {

			if (err) console.info({
				shell: cmd,
				error: err
			});

			cb();
		});
	}

	var paths = TOTEM.paths,
	    name = &quot;&quot; + paths.certs + owner,
	    truststore = paths.certs + &quot;truststore&quot;,
	    pfx = name + &quot;.pfx&quot;,
	    key = name + &quot;.key&quot;,
	    crt = name + &quot;.crt&quot;,
	    ppk = name + &quot;.ppk&quot;;

	traceExecute(&quot;echo -e \&quot;\n\n\n\n\n\n\n\&quot; | openssl req -x509 -nodes -days 5000 -newkey rsa:2048 -keyout &quot; + key + &quot; -out &quot; + crt, function () {

		traceExecute(&quot;export PASS=\&quot;&quot; + pass + &quot;\&quot;;openssl pkcs12 -export -in &quot; + crt + &quot; -inkey &quot; + key + &quot; -out &quot; + pfx + &quot; -passout env:PASS&quot;, function () {

			traceExecute(&quot;cp &quot; + crt + &quot; &quot; + truststore, function () {

				traceExecute(&quot;puttygen &quot; + owner + &quot;.key -N &quot; + pass + &quot; -o &quot; + ppk, function () {

					Trace(&quot;IGNORE PREVIOUS PUTTYGEN ERRORS IF NOT INSTALLED&quot;);
					cb();
				});
			});
		});
	});
}

function validateClient(req, res) {
<span id='PKI_CERTS-method-validateClient'>	/**
</span> @private
 @method validateClient
 @param {Object} req totem request
 @param {Function} res totem response
 
 Responds will res(null) if session is valid or res(err) if session invalid.  Adds the client's session metric log, 
 org, serverip, group, profile, db journalling flag, time joined, email and client ID to this req request.  
 */

	function getCert() {
		//&lt; Return cert for https/http connection on this req.socket w or w/o proxy.
		var cert = (sock ? sock.getPeerCertificate ? sock.getPeerCertificate() : null : null) || { //&lt; default cert
			issuer: {},
			subjectaltname: &quot;&quot;,
			subject: {},
			valid_to: null,
			valid_from: null
		};

		if (TOTEM.behindProxy) {
			// when going through a proxy, must update cert with originating cert info that was placed in header
			var NA = Req.headers.ssl_client_notafter,
			    NB = Req.headers.sll_client_notbefore,
			    DN = Req.headers.ssl_client_s_dn;

			if (NA) cert.valid_to = new Date([NA.substr(2, 2), NA.substr(4, 2), NA.substr(0, 2)].join(&quot;/&quot;) + &quot; &quot; + [NA.substr(6, 2), NA.substr(8, 2), NA.substr(10, 2)].join(&quot;:&quot;));

			if (NB) cert.valid_to = new Date([NB.substr(2, 2), NB.substr(4, 2), NB.substr(0, 2)].join(&quot;/&quot;) + &quot; &quot; + [NB.substr(6, 2), NB.substr(8, 2), NB.substr(10, 2)].join(&quot;:&quot;));

			if (DN) Each(DN.split(&quot;/&quot;), function (n, hdr) {
				if (hdr) {
					var sub = hdr.split(&quot;=&quot;);
					cert.subject[sub[0]] += sub[1];
				}
			});

			var CN = cert.subject.CN;

			if (CN) {
				CN = CN.split(&quot; &quot;);
				cert.subject.CN = CN[CN.length - 1] + &quot;@coe.ic.gov&quot;;
			}
		}

		return cert;
	}

	function admitClient(req, res, profile, cert, client) {
		// callback res(null) if client can be admited; otherwise res(error)
		/* 
  If the client's cert is good,respond with res(null), then add the client's session metric log, org, serverip, 
  group, profile, db journalling flag, time joined, email and client ID to this req request.  The cert is also
  cached for future data fetching to https sites.  If the cert is bad, then respond with res(err).
  */
		function cpuavgutil() {
			// compute average cpu utilization
			var avgUtil = 0;
			var cpus = OS.cpus();

			cpus.each(function (n, cpu) {
				idle = cpu.times.idle;
				busy = cpu.times.nice + cpu.times.sys + cpu.times.irq + cpu.times.user;
				avgUtil += busy / (busy + idle);
			});
			return avgUtil / cpus.length;
		}

		if (TOTEM.isEncryptedWorker) {
			// validate client's cert

			if (now &lt; new Date(cert.valid_from) || now &gt; new Date(cert.valid_to)) return res(TOTEM.errors.expiredCert);

			if (admitRule = TOTEM.admitRule) if (!(cert.issuer.O.toLowerCase() in admitRule &amp;&amp; cert.subject.C.toLowerCase() in admitRule)) return res(TOTEM.errors.rejectedCert);
		}

		if (profile.Banned) // block client if banned
			return res(new Error(profile.Banned));

		sql.query(&quot;show session status like 'Thread%'&quot;, function (err, stats) {
			// start session metric logging
			if (err) stats = [{ Value: 0 }, { Value: 0 }, { Value: 0 }, { Value: 0 }];

			Copy({ // add session metric logs and session parms
				log: { // potential session metrics to log
					Event: now, // start time
					Action: req.action, // db action
					ThreadsRunning: stats[3].Value, // sql threads running
					ThreadsConnected: stats[1].Value, // sql threads connected
					Stamp: TOTEM.name, // site name
					Util: cpuavgutil(), // cpu utilization
					Fault: &quot;isp&quot; // fault codes
					//Cores: site.Cores, 					// number of safety core hyperthreads
					//VMs: 1,								// number of VMs
					//Client: client, 				// client id
					//Table: req.table, 					// db target
					//RecID: req.query.ID || 0,			// sql recID
				},

				org: cert.subject.O || &quot;unknown&quot;, // cert organization 
				serverip: sock ? sock.address().address : &quot;unknown&quot;,
				group: profile.Group, // || TOTEM.site.db, 
				profile: new Object(profile), // complete profile
				onencrypted: CLUSTER.isWorker, // flag
				journal: true, // journal db actions
				joined: now, // time joined
				email: client, // email address from pki
				client: client // client ID
			}, req);

			res(null);
		});
	}

	var sql = req.sql,
	    sock = req.reqSocket,
	    cert = getCert(),
	    now = new Date(),
	    client = (cert.subject.emailAddress || cert.subjectaltname || cert.subject.CN || TOTEM.guestProfile.Client).split(&quot;,&quot;)[0].replace(&quot;email:&quot;, &quot;&quot;);

	TOTEM.cache.certs[client] = new Object(cert);

	if (TOTEM.mysql) // get client's profile
		sql.query(&quot;SELECT *,count(ID) as Count FROM openv.profiles WHERE ? LIMIT 0,1&quot;, { client: client }).on(&quot;result&quot;, function (profile) {

			if (profile.Count) admitClient(req, res, profile, cert, client);else if (TOTEM.admitGuests) {
				delete TOTEM.guestProfile.ID;
				Trace(&quot;ADMIT GUEST&quot;, sql);
				sql.query( // prime a profile if it does not already exist
				&quot;INSERT INTO openv.profiles SET ?&quot;, Copy({
					Client: client,
					User: client.replace(&quot;ic.gov&quot;, &quot;&quot;).replace(/\./g, &quot;&quot;).toLowerCase()
				}, TOTEM.guestProfile), function (err) {

					admitClient(req, res, TOTEM.guestProfile, cert, client);
				});
			} else res(TOTEM.errors.noProfile);
		}).on(&quot;error&quot;, function (err) {
			res(TOTEM.errors.noProfile);
		});else if (TOTEM.encrypt) res(TOTEM.errors.noDB);else {
		// setup guest connection
		req.socket = null;
		admitClient(req, res, TOTEM.guestProfile, cert, client);
		res(null);
	}
}

<span id='FILE_ACCESS'>/**
</span>@class FILE_ACCESS file cacheing, indexing and uploading
 */

function indexFile(path, cb) {
<span id='FILE_ACCESS-method-indexFile'>	/**
</span> @private
 @method indexFile
 @param {String} path file path
 @param {Function} cb totem response
 */
	var files = [];

	findFile(path, function (n, file) {
		files.push(file.indexOf(&quot;.&quot;) &gt;= 0 ? file : file + &quot;/&quot;);
	});

	cb(files);
}

function findFile(path, cb) {
<span id='FILE_ACCESS-method-findFile'>	/**
</span> @private
 @method findFile
 @param {String} path file path
 @param {Function} cb totem response
 */
	if (maxFiles = TOTEM.maxFiles) try {
		FS.readdirSync(path).each(function (n, file) {
			if (n &gt; maxFiles) return true;

			if (file.charAt(0) != &quot;_&quot; &amp;&amp; file.charAt(file.length - 1) != &quot;~&quot;) cb(n, file);
		});
	} catch (err) {} else cb([]);
}

function getFile(client, filepath, cb) {
<span id='FILE_ACCESS-method-getFile'>	/**
</span> @private
 @method getFile
 @param {String} client name of client requesting a data port (aka file)
 @param {String} filepath path to the file
 @param {Function} cb callback(sql, area, fileID) if no errors
 Access (create if needed) a file then callback cb(sql, area, fileID) if no errors
 */

	var parts = filepath.split(&quot;/&quot;),
	    name = parts.pop() || &quot;&quot;,
	    area = parts[0] || &quot;&quot;;

	sqlThread(function (sql) {
		sql.getFirst(&quot;FILE&quot;, &quot;SELECT ID FROM app.files WHERE least(?,1) LIMIT 1&quot;, {
			Name: name,
			Client: client,
			Area: area
		}, function (file) {

			if (file) cb(sql, area, file.ID);else sql.getAll(&quot;FILE&quot;, &quot;INSERT INTO app.files SET Added=now(), ?&quot;, {
				Name: name,
				Client: client,
				Area: area,
				Notes: &quot;Please visit &quot; + &quot;here&quot;.tag(&quot;a&quot;, { href: &quot;/files.view&quot; }) + &quot; to manage your files&quot;
			}, function (info) {
				cb(sql, area, info.insertId);
			});
		});
	});
}

function pipeFile(srcStream, client, sinkPath, tags, cb) {
<span id='FILE_ACCESS-method-pipeFile'>	/**
</span> @private
 @method pipeFile
 @param {Stream} source stream
 @param {String} client name of client requesting file upload
 @param {String} sinkPath path to target file
 @param {Object} tags hach of tags to add to file
 @param {Function} cb callback(fileID) if no errors encountered
 */
	getFile(client, sinkPath, function (sql, area, fileID) {
		var notes = &quot;Please visit &quot; + &quot;here&quot;.tag(&quot;a&quot;, { href: &quot;/files.view&quot; }) + &quot; to manage your holdings.&quot;,
		    folder = TOTEM.paths.mime[area],
		    sinkStream = FS.createWriteStream(folder + &quot;/&quot; + sinkPath, &quot;utf8&quot;).on(&quot;finish&quot;, function () {
			// establish sink stream for export pipe
			//Trace(&quot;EXPORTED &quot;+sinkPath);
			Log(&quot;totem done uploading&quot;);
			sqlThread(function (sql) {

				//if (cb) cb(fileID);

				sql.query(&quot;UPDATE apps.files SET ? WHERE ?&quot;, [Copy(tags || {}, {
					Notes: &quot;Uploaded on &quot; + new Date() + notes
				}), { ID: fileID }]);

				sql.release();
			});
		}).on(&quot;error&quot;, function (err) {
			Log(&quot;totem upload error&quot;, err);
			sqlThread(function (sql) {
				sql.query(&quot;UPDATE app.files SET ? WHERE ?&quot;, [{
					Notes: &quot;Upload failed: &quot; + err + notes
				}, { ID: fileID }]);

				sql.release();
			});
		});

		Log(&quot;uploading to&quot;, folder, sinkPath);

		if (cb) cb(fileID); // callback if provided

		if (srcStream) // if a source stream was provided, start pipe to copy source to sink
			srcStream.pipe(sinkStream);
	});
}

function uploadFile(files, client, area, tags, cb) {
<span id='FILE_ACCESS-method-uploadFile'>	/**
</span> @private
 @method uploadFile
 @param {Array} files files to upload
 @param {String} clinet name of client requesting the upload
 @param {String} area area to upload files into
 @param {Object} tags hash of tags to stamp on file
 @param {Function} cb totem response
 */

	/*
 function copyFile(srcFile, sinkFile, cb) {
 	var src = FS.createReadStream(srcFile);
 	var sink = FS.createWriteStream(sinkFile);
 	
 	sink		
 		.on(&quot;finish&quot;, function() {  // establish sink stream for export pipe
 			//Trace(&quot;EXPORTED &quot;+filePath);
 			sql.query(&quot;UPDATE apps.files SET ? WHERE ?&quot;, {
 				Notes: &quot;Exported on &quot; + new Date() + notes
 			}, {ID: fileID} );
 		})
 		.on(&quot;error&quot;, function (err) {
 			Log(&quot;Ingest File Error&quot;, err);
 			sql.query(&quot;UPDATE app.files SET ? WHERE ?&quot;, {
 				Notes: &quot;Export failed: &quot; + err + notes
 			}, {ID: fileID} );
 		});
 	
 	/ *
 	var cbCalled = false;
 	function done(err) {
 		if (!cbCalled) {
 			cb(err);
 			cbCalled = true;
 		}
 	}
 	rs.on(&quot;error&quot;, function(err) {
 	done(err);
 	});
 		ws.on(&quot;error&quot;, function(err) {
 	done(err);
 	});
 	ws.on(&quot;close&quot;, function(ex) {
 	done();
 	}); * /
 		src.pipe(sink);
 }
 	var arrived = new Date();
 */

	files.each(function (n, file) {
		var name = file.filename,
		    target = TOTEM.paths.mime[area] + &quot;/&quot; + area + &quot;/&quot; + name;

		Trace(&quot;UPLOAD &quot; + name);

		cb(file);

		if (file.image) {

			var prefix = &quot;data:image/png;base64,&quot;;
			var buf64 = new Buffer(file.image.substr(prefix.length), 'base64');
			var temp = &quot;tmp/temp.png&quot;; // many browsers only support png so convert to jpg

			FS.writeFile(temp, buf64.toString(&quot;binary&quot;), { encoding: &quot;binary&quot; }, function (err) {
				Log(&quot;SAVE &quot; + name + &quot; TO &quot; + target + (err ? &quot; FAILED&quot; : &quot;&quot;));

				if (!err &amp;&amp; cb) LWIP.open(temp, function (err, image) {

					if (!err) {
						image.writeFile(target, function (err) {
							console.info(&quot;JPG convert &quot; + (err || &quot;ok&quot;));
						});

						if (cb) cb({
							Name: name,
							Area: area,
							Added: arrived,
							Size: file.size,
							Width: image.width(),
							Height: image.height()
						});
					}
				});
			});
		} else switch (file.type) {
			/*
   case &quot;image/jpeg&quot;:  // legacy
   		var buf = new Buffer(file.data, &quot;base64&quot;);
   	FS.writeFile(target, buf.toString(&quot;binary&quot;), {encodings:&quot;binary&quot;}, function (err) {
   		Log(err);
   	});
   	break;
   */

			case &quot;image/jpeg&quot;:
			case &quot;application/pdf&quot;:
			case &quot;application/javascript&quot;:
			default:
				var buf = new Buffer(file.data, &quot;base64&quot;);

				FS.writeFile(target, buf, &quot;base64&quot;, function (err) {
					if (err) Log(err);
				});
		}

		/*
  copyFile(file.path, target, function (err) {
  		console.info(&quot;SAVE &quot;+file.path+&quot; TO &quot;+target+(err?&quot; FAILED&quot;:&quot;&quot;));
  		if (cb) cb({
  		Name: name,
  		Area: area,
  		Added: arrived,
  		Size: file.size
  	});
  		if (false)
  		APP.NEWREAD.JOB(sql,body.Area,name);
  });*/
	});
}

<span id='DATA_FETCHING'>/**
</span>@class DATA_FETCHING methods to pull external data from other services
 */

function fetchWget(req, res) {
	//&lt; wget endpoint
<span id='DATA_FETCHING-method-fetchWget'>	/**
</span> @private
 @method fetchWget
 @param {Object} req totem request
 @param {Function} res totem response
 */
	if (req.out) TOTEM.fetchers.plugin.wgetout = req.out;

	if (url = TOTEM.paths.url[req.table]) wgetFetch(url.format(req, TOTEM.fetchers.plugin), res);
}

function fetchCurl(req, res) {
	//&lt; curl endpoint
<span id='DATA_FETCHING-method-fetchCurl'>	/**
</span> @private
 @method fetchCurl
 @param {Object} req totem request
 @param {Function} res totem response
 */
	if (url = TOTEM.paths.url[req.table]) curlFetch(url.format(req, TOTEM.fetchers.plugin), res);
}

function fetchHttp(req, res) {
	//&lt; http endpoint
<span id='DATA_FETCHING-method-fetchHttp'>	/**
</span> @private
 @method fetchHttp
 @param {Object} req totem request
 @param {Function} res totem response
 */
	if (url = TOTEM.paths.url[req.table]) httpFetch(url.format(req, TOTEM.fetchers.plugin), res);
}

function curlFetch(url, cb) {

	var opts = URL.parse(url),
	    certs = TOTEM.cache.certs,
	    transport = {
		&quot;http:&quot;: &quot;curl \&quot;&quot; + url + &quot;\&quot;&quot;,
		&quot;https:&quot;: &quot;curl -gk --cert &quot; + certs.crt + &quot; --key &quot; + certs.key + &quot; \&quot;&quot; + url + &quot;\&quot;&quot;
	};

	retryFetch(transport[opts.protocol], opts, function (err, out) {
		try {
			cb(JSON.parse(out));
		} catch (err) {
			cb(null);
		}
	});
}

function wgetFetch(url, cb) {

	function retryFetch(cmd, opts, cb) {

		function trycmd(cmd, cb) {

			if (TOTEM.notify) Trace(&quot;TRY[&quot; + opts.retry + &quot;] &quot; + cmd);

			CP.exec(cmd, function (err, stdout, stderr) {
				if (err) {
					if (opts.retry) {
						opts.retry--;

						trycmd(cmd, cb);
					} else cb(TOTEM.errors.retryFetch);
				} else if (cb) cb(null, stdout);
			});
		}

		opts.retry = TOTEM.retries;

		if (opts.retry) trycmd(cmd, cb);else CP.exec(cmd, function (err, stdout, stderr) {
			cb(err, stdout);
		});
	}

	var parts = url.split(&quot; &gt;&gt; &quot;),
	    url = parts[0],
	    out = parts[1] || &quot;./shares/junk.jpg&quot;,
	    opts = URL.parse(url),
	    certs = TOTEM.cache.certs,
	    transport = {
		&quot;http:&quot;: &quot;wget -O &quot; + out + &quot; \&quot;&quot; + url + &quot;\&quot;&quot;,
		&quot;https:&quot;: &quot;wget -O &quot; + out + &quot; --no-check-certificate --certificate &quot; + certs.crt + &quot; --private-key &quot; + certs.key + &quot; \&quot;&quot; + url + &quot;\&quot;&quot;
	};

	retryFetch(transport[opts.protocol], opts, function (err) {
		cb(err ? null : &quot;ok&quot;);
	});
}

function httpFetch(url, cb) {

	var opts = URL.parse(url),
	    certs = TOTEM.cache.certs,
	    transport = {
		&quot;http:&quot;: HTTP,
		&quot;https:&quot;: HTTPS
	};

	opts.pfx = certs.pfx;
	opts.passphrase = TOTEM.encrypt;
	opts.retry = TOTEM.retries;
	opts.rejectUnauthorized = false;
	opts.agent = false;

	/*if (opts.soap) {
 	opts.headers = {
 		&quot;Content-Type&quot;: &quot;application/soap+xml; charset=utf8&quot;,
 		&quot;Content-Length&quot;: opts.soap.length
 	};
 	opts.method = &quot;POST&quot;;
 }*/

	Trace(&quot;FETCH &quot; + url);

	if (opts.protocol) {
		var Req = transport[opts.protocol].request(opts, function (Res) {
			var body = &quot;&quot;;
			Res.on('data', function (chunk) {
				body += chunk.toString();
			});

			Res.on(&quot;end&quot;, function () {
				try {
					cb(JSON.parse(body));
				} catch (err) {
					cb(null);
				}
			});
		});

		Req.on('error', function (err) {
			cb(null);
		});

		/*if (opts.soap)
  	Req.write(opts.soap);*/ // only for put method

		Req.end();
	} else cb(null);
}

/*
function readTemplate(req,res) {
	
	var	sql = req.sql,
		route = TOTEM.execute[req.table];

	if (route)
		route(req,res);
	else
		res();			
}

function sendTemplate(req,res) {
	res( &quot;there you go&quot;);
}
*/

<span id='ANTIBOT_PROTECTION'>/**
</span>@class ANTIBOT_PROTECTION data theft protection
 */

function checkRiddle(req, res) {
	//&lt; endpoint to check clients response to a riddle
<span id='ANTIBOT_PROTECTION-method-checkRiddle'>	/**
</span> @private
 @method checkRiddle
 Endpoint to check clients response req.query to a riddle created by challengeClient.
 @param {Object} req Totem session request
 @param {Function} res Totem response callback
 */
	var query = req.query,
	    sql = req.sql;

	sql.query(&quot;SELECT *,count(ID) as Count FROM openv.riddles WHERE ? LIMIT 0,1&quot;, { Client: query.ID }).on(&quot;result&quot;, function (rid) {

		var ID = { Client: rid.ID },
		    guess = (query.guess + &quot;&quot;).replace(/ /g, &quot;&quot;);

		Log([rid, query]);

		if (rid.Count) {
			if (rid.Riddle == guess) {
				res(&quot;pass&quot;);
				//sql.query(&quot;DELETE FROM openv.riddles WHERE ?&quot;,ID);
			} else if (rid.Attempts &gt; rid.maxAttempts) {
				res(&quot;fail&quot;);
				//sql.query(&quot;DELETE FROM openv.riddles WHERE ?&quot;,ID);
			} else {
				res(&quot;retry&quot;);
				sql.query(&quot;UPDATE openv.riddles SET Attempts=Attempts+1 WHERE ?&quot;, ID);
			}
		} else res(&quot;fail&quot;);
	});
}

function initChallenger() {
<span id='ANTIBOT_PROTECTION-method-initChallenger'>	/**
</span> @private
 @method initChallenger
 Create a set of TOTEM.riddles challenges.
 */
	function Riddle(map, ref) {
		var Q = {
			x: Math.floor(Math.random() * 10),
			y: Math.floor(Math.random() * 10),
			z: Math.floor(Math.random() * 10),
			n: Math.floor(Math.random() * map[&quot;0&quot;].length)
		},
		    A = {
			x: &quot;&quot;.tag(&quot;img&quot;, { src: ref + &quot;/&quot; + Q.x + &quot;/&quot; + map[Q.x][Q.n] + &quot;.jpg&quot; }),
			y: &quot;&quot;.tag(&quot;img&quot;, { src: ref + &quot;/&quot; + Q.y + &quot;/&quot; + map[Q.y][Q.n] + &quot;.jpg&quot; }),
			z: &quot;&quot;.tag(&quot;img&quot;, { src: ref + &quot;/&quot; + Q.z + &quot;/&quot; + map[Q.z][Q.n] + &quot;.jpg&quot; })
		};

		return {
			Q: A.x + &quot; * &quot; + A.y + &quot; + &quot; + A.z,
			A: Q.x * Q.y + Q.z
		};
	}

	var riddle = TOTEM.riddle = [],
	    N = TOTEM.riddles,
	    map = TOTEM.riddleMap,
	    ref = &quot;/captcha&quot;;

	for (var n = 0; n &lt; N; n++) {
		riddle.push(Riddle(map, ref));
	}
}

function makeRiddles(msg, rid, ids) {
<span id='ANTIBOT_PROTECTION-method-checkRiddle'>	/**
</span> @private
 @method checkRiddle
 Endpoint to check clients response req.query to a riddle created by challengeClient.
 @param {String} msg riddle mask contianing (riddle), (yesno), (ids), (rand), (card), (bio) keys
 @param {Array} rid List of riddles returned
 @param {Object} ids Hash of {id: value, ...} replaced by (ids) key
 */
	var riddles = TOTEM.riddle,
	    N = riddles.length;

	msg = (msg || &quot;&quot;).each(&quot;(riddle)&quot;, rid, function (rid) {

		var n = Math.floor(Math.random() * N),
		    QA = riddles[n];

		rid.push(QA.A);
		return QA.Q;
	}).each(&quot;(yesno)&quot;, rid, function (rid) {

		rid.push(&quot;yes&quot;);
		return &quot;yes/no&quot;;
	}).each(&quot;(ids)&quot;, rid, function (rid) {

		var rtn = &quot;&quot;,
		    pre = &quot;&quot;;
		Each(ids, function (n, id) {
			rtn += pre + &quot;(&quot; + n + &quot;)&quot;;
			pre = &quot;, &quot;;
		});

		return rtn;
	}).each(&quot;(rand)&quot;, rid, function (rid) {

		rid.push(val = Math.floor(Math.random() * 10));

		return &quot;random integer between 0 and 9&quot;;
	}).each(&quot;(card)&quot;, rid, function (rid) {
		return &quot;cac card challenge TBD&quot;;
	}).each(&quot;(bio)&quot;, rid, function (rid) {
		return &quot;bio challenge TBD&quot;;
	});

	Each(ids, function (n, id) {

		msg = msg.each(&quot;(&quot; + n + &quot;)&quot;, rid, function (rid) {
			rid.push(id);
			return n;
		});
	});

	return msg;
}

function challengeClient(client, profile) {
<span id='ANTIBOT_PROTECTION-method-challengeClient'>	/**
</span> @private
 @method challengeClient
 Challenge a client with specified profile parameters
 @param {String} client name of client being challenged
 @param {Object} profile client's profile .Message = riddle mask, .IDs = {id:value, ...}
 */
	var rid = [],
	    reply = TOTEM.riddleMap &amp;&amp; TOTEM.riddles ? makeRiddles(profile.Message, rid, profile.IDs.parseJSON({})) : profile.Message;

	if (reply &amp;&amp; TOTEM.IO) sqlThread(function (sql) {
		sql.query(&quot;REPLACE INTO openv.riddles SET ?&quot;, {
			Riddle: rid.join(&quot;,&quot;).replace(/ /g, &quot;&quot;),
			Client: client,
			Made: new Date(),
			Attempts: 0,
			maxAttempts: profile.Retries
		}, function (err, info) {

			TOTEM.IO.emit(&quot;select&quot;, {
				message: reply,
				riddles: rid.length,
				rejected: false,
				retries: profile.Retries,
				timeout: profile.Timeout,
				ID: client, //info.insertId,
				callback: TOTEM.paths.url.riddler
			});

			sql.release();
		});
	});
}

function Initialize() {
<span id='TOTEM-method-Initialize'>	/**
</span> @private
 @member TOTEM
 @method Initialize
 Initialize TOTEM.
 */

	Trace(&quot;INIT &quot; + TOTEM.name + &quot; WITH &quot; + TOTEM.riddles + &quot; RIDDLES&quot;);

	initChallenger();
}

<span id='ENDPOINT_ROUTING'>/**
</span>@class ENDPOINT_ROUTING methods to route notes byType, byAction, byTable, byActionTable, byArea.
*/

function parseNode(req) {
<span id='ENDPOINT_ROUTING-method-parseNode'>	/**
</span> @private
 @method parseNode
 Parse node request to define req.table, .path, .area, .query, .search, .type, .file, .flags, and .body.
 @param {Object} req Totem session request
 */
	var node = URL.parse(req.node),
	    path = req.path = node.path,
	    search = req.search = node.query || &quot;&quot;,
	    query = req.query = search.parseQuery({}),
	    areas = node.pathname.split(&quot;/&quot;),
	    file = req.filename = areas.pop() || (areas[1] ? &quot;&quot; : TOTEM.paths.default),
	    parts = req.parts = file.split(&quot;.&quot;),
	    type = req.type = parts[1] || &quot;&quot;,
	    table = req.table = parts[0] || &quot;&quot;,
	    area = req.filearea = areas[1] || &quot;&quot;;

	//Log(&quot;requset&quot;,req);

	if (req.filepath = req.filearea ? TOTEM.paths.mime[req.filearea] || req.filearea : &quot;&quot;) req.filepath += node.pathname;else {
		req.filearea = &quot;&quot;;

		// flags and joins

		var reqFlags = TOTEM.reqFlags,
		    strips = reqFlags.strips,
		    prefix = reqFlags.prefix,
		    traps = reqFlags.traps,
		    id = reqFlags.id,
		    body = req.body,
		    flags = req.flags,
		    joins = req.joins;

		/*
  Log({before: {
  	a: req.action,
  	q: query,
  	b: body,
  	f: flags
  }}); */

		for (var n in query) {
			// remove bogus query parameters and remap query flags and joins
			if (n in strips) // remove bogus
				delete query[n];else if (n.charAt(0) == prefix) {
				// remap flag
				var flag = n.substr(1);
				flags[flag] = query[n];
				delete query[n];
			} else {
				// remap join
				var parts = n.split(&quot;.&quot;);
				if (parts.length &gt; 1) {
					joins[parts[0]] = n + &quot;=&quot; + query[n];
					delete query[n];
				}
			}
		}for (var n in body) {
			// remap body flags
			if (n.charAt(0) == prefix) {
				flags[n.substr(1)] = body[n];
				delete body[n];
			}
		}if (id in body) {
			// remap body record id
			query[id] = body[id];
			delete body[id];
		}

		if (traps) for (var n in traps) {
			// let traps remap query-flag parms
			if (flags[n]) traps[n](req);
		} /*
    Log({after: {
    	a: req.action,
    	q: query,
    	b: body,
    	f: flags
    }}); */
	}
}

function syncNodes(nodes, acks, req, res) {
<span id='ENDPOINT_ROUTING-method-syncNodes'>	/**
</span> @private
 @method syncNodes
 @param {Array} nodes
 @param {Object} acks
 @param {Object} req Totem session request
 @param {Function} res Totem response callback
 Submit nodes=[/dataset.type, /dataset.type ...]  on the current request thread req to the routeNode() 
 method, aggregate results, then send with supplied response().
 */

	if (node = req.node = nodes.pop()) // grab last node
		routeNode(req, function (ack) {
			// route it and intercept its ack
			acks[req.table] = ack;
			syncNodes(nodes, acks, Copy(req, {}), res);
		});else if (nodes.length) // still more nodes
		syncNodes(nodes, acks, Copy(req, {}), res);else // no more nodes
		res(acks);
}

function routeNode(req, res) {
<span id='ENDPOINT_ROUTING-method-routeNode'>	/**
</span> @private
 @method routeNode
 @param {Object} req Totem session request
 @param {Function} res Totem response callback
 
 Parse the node=/dataset.type on the current req thread, then route it to the approprate TOTEM byArea, 
 byType, byActionTable, engine or file indexer (see config documentation).
 */

	parseNode(req);

	function sendFile(req, res) {
		//Log(&quot;send file&quot;, req.filepath);
		res(function () {
			return req.filepath;
		});
	}1;

	var sql = req.sql,
	    node = req.node,
	    table = req.table,
	    type = req.type,
	    action = req.action,
	    area = req.filearea,
	    paths = TOTEM.paths;

	//Log([action,req.filepath,area,table,type]);

	if (req.filepath &amp;&amp; (route = TOTEM.byArea[area] || sendFile)) followRoute(route, req, res);else if (route = TOTEM.byType[type]) followRoute(route, req, res);else if (route = TOTEM.byActionTable[action][table]) followRoute(route, req, res);else if (route = TOTEM.byTable[table]) followRoute(route, req, res);else // attempt to route to engines then to database
		if (route = TOTEM.byAction[action]) route(req, function (ack) {
			//Log({engroute: ack});

			if (ack) res(ack);else if (route = TOTEM[action]) {
				if (TOTEM.cache.learnedTables) followRoute(TOTEM.byActionTable[action][table] = route, req, res);else followRoute(route, req, res);
			} else res(TOTEM.errors.noRoute);
		});else if (route = TOTEM[action]) followRoute(route, req, res);else res(TOTEM.errors.noRoute);
}

function followRoute(route, req, res) {
<span id='ENDPOINT_ROUTING-method-followRoute'>	/**
</span> @private
 @method followRoute
 @param {Function} route method endpoint to process session 
 @param {Object} req Totem session request
 @param {Function} res Totem response callback
 
 Log session metrics, trace the current route, then callback route on the supplied 
 request-response thread
 */

	function logMetrics() {
		//&lt; log session metrics 

		if (sock = req.socket) if (record = TOTEM.paths.mysql.record) {
			var log = req.log;

			sock._started = new Date();

			/*
   If maxlisteners is not set to infinity=0, the connection becomes sensitive to a sql 
   connector t/o and there will be random memory leak warnings.
   */

			sock.setMaxListeners(0);
			sock.on('close', function () {
				// cb when connection closed

				var secs = sock._started ? (new Date().getTime() - sock._started.getTime()) / 1000 : 0,
				    bytes = sock.bytesWritten,
				    log = req.log;

				sqlThread(function (sql) {

					if (false) // grainular track
						sql.query(record, [Copy(log, {
							Delay: secs,
							Transfer: bytes,
							Event: sock._started,
							Dataset: req.table,
							Client: rec.client,
							Actions: 1
						}), bytes, secs, log.Event]);else {
						// bucket track
						sql.query(record, [Copy(log, {
							Delay: secs,
							Transfer: bytes,
							Event: sock._started,
							Dataset: req.table,
							Actions: 1
						}), bytes, secs, log.Event]);

						sql.query(record, [Copy(log, {
							Delay: secs,
							Transfer: bytes,
							Event: sock._started,
							Dataset: req.client,
							Actions: 1
						}), bytes, secs, log.Event]);
					}

					sql.release();
				});
			});
		}
	}

	if (!req.filepath &amp;&amp; TOTEM.isEncryptedWorker) logMetrics(); // dont log file requests
	var myid = CLUSTER.isMaster ? 0 : CLUSTER.worker.id;

	Trace((route ? route.name : &quot;null&quot;).toUpperCase() + (&quot; &quot; + req.filename + &quot; FOR &quot; + req.group + &quot;.&quot; + req.client + &quot; ON CORE&quot; + myid), req.sql);

	route(req, res);

	/*
 if ( CLUSTER.isWorker || !TOTEM.cores ) {
 }
 else
 if (route.name == &quot;simThread&quot;)
 	route(req,res);
 
 else
 	res(TOTEM.errors.noAccess);
 */
}

<span id='THREAD_PROCESSING'>/**
</span>@class THREAD_PROCESSING sql and session thread processing
*/

function sesThread(Req, Res) {
<span id='THREAD_PROCESSING-method-sesThread'>	/**
</span> @method sesThread
 @param {Object} Req http/https request
 @param {Object} Res http/https response
 
 Created a HTTP/HTTPS request-repsonse session thread.  UsesTOTEM's byTable, byArea, byType, byActionTable to
 route this thread to the appropriate (req,res)-endpoint, where the newly formed request req contains
 
 		method: &quot;GET, ... &quot; 		// http method and its ...
 		action: &quot;select, ...&quot;,		// corresponding crude name
 		socketio: &quot;path&quot;  // filepath to client's socketio.js
 		query: {...}, 		// query ke-value parms from url
 		body: {...},		// body key-value parms from request body
 		flags: {...}, 		// _flags key-value parms parsed from url
 		joins: {...}, 		// experimental ds from-to joins
 		files: [...] 		// files uploaded
 		site: {...}			// skinning context keys
 		sql: connector 		// sql database connector (dummy if no mysql config)
 		url	: &quot;url&quot;				// complete &quot;/area/.../name.type?query&quot; url
 		search: &quot;query&quot;		// query part
 		path: &quot;/...&quot;			// path part 
 		filearea: &quot;area&quot;		// area part
 		filename: &quot;name&quot;	// name part
 		type: &quot;type&quot; 			// type part 
 		connection: socket		// http/https socket to retrieve client cert 
 
 The newly form response res method accepts a string, an objects, an array, an error, or a file-cache function
 to appropriately respond and close this thread and its sql connection.  The session is validated and logged, and 
 the client is challenged as necessary.
  */

	// Session terminating functions to respond with a string, file, db structure, or error message.

	function sendString(data) {
		// Send string
		Res.end(data);
		Req.req.sql.release();
	}

	function sendFileIndex(head, files) {
		// Send list of files under specified folder

		switch (0) {
			case 0:
				files.each(function (n, file) {
					files[n] = file.tag(&quot;a&quot;, { href: &quot;&quot; + file });
				});

				sendString(head + &quot;:&lt;br&gt;&quot; + files.join(&quot;&lt;br&gt;&quot;));
				break;

			case 1:
				sendString(head + &quot;:\n&quot; + files.join(&quot;\n&quot;));
				break;
		}
	}

	function sendCache(path, file, type, area) {
		// Cache and send file to client

		var
		//mime = MIME[type] || MIME.html  || &quot;text/plain&quot;,
		paths = TOTEM.paths;
		index = paths.mime.index;

		//Trace(`SENDING ${path} AS ${mime} ${file} ${type} ${area}`);

		if (type) {
			// cache and send file

			var cache = TOTEM.cache;

			if (cache.never[file] || cache.never[type]) cache = null;
			if (cache) cache = cache[area];
			if (cache) cache = cache[type];

			var buf = cache ? cache[path] : null;

			if (buf) sendString(buf);else try {
				if (cache) sendString(cache[path] = FS.readFileSync(path));else sendString(FS.readFileSync(path));
			} catch (err) {
				sendError(TOTEM.errors.noFile);
			}
		} else if (indexer = index[area]) {
			// index files
			TOTEM[indexer](path, function (files) {
				// use configured indexer
				sendFileIndex(&quot;Index of &quot; + path, files);
			});
		} else sendError(TOTEM.errors.noIndex);
	}

	function sendError(err) {
		// Send pretty error message
		Res.end(TOTEM.errors.pretty(err));
		Req.req.sql.release();
	}

	function sendRecords(ack, req, res) {
		// Send records via converter
		var reqTypes = TOTEM.reqTypes,
		    errors = TOTEM.errors;

		if (ack) {
			if (conv = reqTypes[req.type] || reqTypes.default) conv(ack, req, function (rtn) {
				if (rtn) switch (rtn.constructor) {
					case Error:
						sendError(rtn);
						break;

					case String:
						sendString(rtn);
						break;

					case Array:
					case Object:
					default:
						try {
							sendString(JSON.stringify(rtn));
						} catch (err) {
							sendErrror(errors.noData);
						}
				} else sendError(errors.noData);
			});else sendError(errors.badType);
		} else sendErrror(errors.noData);
	}

	function res(ack) {
		// Session response callback

		var req = Req.req,
		    sql = req.sql,
		    mime = (ack || 0).constructor == Error ? MIME.types.html : MIME.types[req.type] || MIME.types.html || &quot;text/plain&quot;,
		    paths = TOTEM.paths;

		Res.setHeader(&quot;Content-Type&quot;, mime);
		Res.statusCode = 200;

		try {
			switch (ack.constructor) {// send ack based on its type
				case Error:
					// send error message

					switch (req.type) {
						case &quot;db&quot;:
							sendString(JSON.stringify({
								success: false,
								msg: ack + &quot;&quot;,
								count: 0,
								data: []
							}));
							break;

						default:
							sendError(ack);
					}
					break;

				case Function:
					// send file via search or direct

					if ((search = req.query.search) &amp;&amp; paths.mysql.search) // search for file via nlp/etc
						sql.query(paths.mysql.search, { FullSearch: search }, function (err, files) {

							if (err) sendError(TOTEM.errors.noFile);else sendError(TOTEM.errors.noFile); // reserved functionality
						});else {
						// credit/charge client when file pulled from file system	
						if (paths.mysql.credit) sql.query(paths.mysql.credit, { Name: req.node, Area: req.filearea }).on(&quot;result&quot;, function (file) {
							if (file.Client != req.client) sql.query(&quot;UPDATE openv.profiles SET Credit=Credit+1 WHERE ?&quot;, { Client: file.Client });
						});

						sendCache(ack(), req.filename, req.type, req.filearea);
					}

					break;

				case Array:
					// send data records 

					if (blog = req.flags.blog) {
						// blog back selected keys
						var keys = blog.split(&quot;,&quot;),
						    recs = ack;
						if (blog = TOTEM.reqFlags.blog) {
							recs.each(function (n, rec) {
								keys.each(function (n, key) {
									if (val = rec[key]) if (val.constructor == String) blog(val, rec, req.table, function (html) {
										rec[key] = html;
									});
								});
							});
							sendRecords(ack, req, res);
						} else sendRecords(ack, req, res);
					} else sendRecords(ack, req, res);

					break;

				case String:
					// send message
					sendString(ack);
					break;

				case Object:
				default:
					// send data record
					sendRecords([ack], req, res);
					break;

			}
		} catch (err) {
			sendError(TOTEM.errors.badReturn);
		}
	}

	function getBody(cb) {
		// Feed body and file parameters to callback

		var body = &quot;&quot;;

		Req.on(&quot;data&quot;, function (chunk) {
			body += chunk.toString();
		}).on(&quot;end&quot;, function () {
			if (body) cb(body.parseJSON(function () {
				// yank files if body not json

				var files = [],
				    parms = {};

				body.split(&quot;\r\n&quot;).each(function (n, line) {
					if (line) if (parms.type) {
						// type was defined so have the file data
						files.push(Copy(parms, { data: line, size: line.length }));
						parms = {};
					} else {
						//Trace(&quot;LOAD &quot;+line);

						line.split(&quot;;&quot;).each(function (n, arg) {
							// process one file at a time

							var tok = arg.replace(&quot;Content-Disposition: &quot;, &quot;disposition=&quot;).replace(&quot;Content-Type: &quot;, &quot;type=&quot;).split(&quot;=&quot;),
							    val = tok.pop(),
							    key = tok.pop();

							if (key) parms[key.replace(/ /g, &quot;&quot;)] = val.replace(/&quot;/g, &quot;&quot;);
						});
					}
				});

				//Log(files);
				return { files: files };
			}));else cb({});
		});
	}

	function startSession(cb) {
		//&lt; callback cb() if not combating denial of service attacks
<span id='THREAD_PROCESSING-method-startSession'>		/**
</span>  @private
  @method startSession
  Start session and protect from denial of service attacks.
  @param {Function} callback() when completed
  */

		if (BUSY &amp;&amp; (busy = TOTEM.errors.tooBusy)) if (BUSY()) return Res.end(TOTEM.errors.pretty(busy));

		switch (Req.method) {
			case &quot;PUT&quot;:
			case &quot;GET&quot;:
			case &quot;POST&quot;:
			case &quot;DELETE&quot;:
				return cb();

			case &quot;OPTIONS&quot;:
				// client making cross-domain call - must respond with what are valid methods
				//Req.method = Req.headers[&quot;access-control-request-method&quot;];
				Res.writeHead(200, {
					&quot;access-control-allow-origin&quot;: &quot;*&quot;,
					&quot;access-control-allow-methods&quot;: &quot;POST, GET, DELETE, PUT, OPTIONS&quot;
				});
				Res.end();

				/*res.header = function () {
    	Res.writeHead(200);
    	Res.socket.write(Res._header);
    	Res.socket.write(Res._header);
    	Res._headerSent = true;
    }; */

				break;

			default:
				Res.end(TOTEM.errors.pretty(TOTEM.errors.badMethod));
		}
	}

	function conThread(req, res) {
		//&lt; establish request connection with callbacl res(null) if started otherwise res(error)
<span id='THREAD_PROCESSING-method-conThread'>		/**
</span>   * @private
   * @method conThread
   * Start a connection thread cb(err) containing a Req.req.sql connector,
   * a validated Req.req.cert certificate, and set appropriate Res headers. 
   * 
   * @param {Object} req request
   * @param {Function} res response
   *
   * on-input req = {action, socketio, query, body, flags, joins}
   * on-output req =  adds {log, cert, client, org, serverip, session, group, profile, journal, 
   * joined, email and STATICS}
   * */

		if (sock = req.reqSocket) resThread(req, function (sql) {
			validateClient(req, function (err) {
				if (err) res(err);else if (TOTEM.mysql) sql.query(&quot;SELECT * FROM openv.sessions WHERE ?&quot;, { Client: req.client }, function (err, ses) {

					if (err) return res(err);

					if (!ses.length) req.session = {
						Client: &quot;guest&quot;,
						ipAddress: &quot;unknown&quot;,
						Location: &quot;unknown&quot;,
						Joined: new Date()
					};else req.session = new Object(ses[0]);

					if (validator = TOTEM.validator) validator(req, res);else res(null);
				});else if (validator = TOTEM.validator) validator(req, res);else res(null);
			});
		});else Res.end(TOTEM.errors.pretty(TOTEM.errors.lostConnection));
	}

	function getSocket() {
		// returns req/res socket if this isnt/is a cross domain session
		if (Req.headers.origin) {
			// xdom session is progress from master (http) to its workers (https)
			Res.writeHead(200, { &quot;content-type&quot;: &quot;text/plain&quot;, &quot;access-control-allow-origin&quot;: &quot;*&quot; });
			Res.socket.write(Res._header);
			Res._headerSent = true;
			return Res.socket;
		} else return Req.socket;
	}

	startSession(function () {
		// process if session not busy

		getBody(function (body) {
			// parse body, query and route

			var
			// parse request url into /area/nodes
			paths = TOTEM.paths,


			// prime session request hash
			req = Req.req = {
				method: Req.method,
				action: TOTEM.crud[Req.method],
				reqSocket: Req.socket,
				resSocket: getSocket,
				socketio: TOTEM.encrypt ? TOTEM.site.urls.socketio : &quot;&quot;,
				query: {},
				body: body,
				flags: {},
				joins: {},
				site: TOTEM.site
			},


			// get a clean url
			/*
   There exists an edge case wherein an html tag within json content, e.g &lt;img src=&quot;/ABC&quot;&gt;, 
   is reflected back the server as a /%5c%22ABC%5c%22 which then unescapes to /\\&quot;ABC\\&quot;.
   This is ok but can be confusing.
   */
			url = req.url = unescape(Req.url),


			// get a list of all nodes
			nodes = (nodeDivider = TOTEM.nodeDivider) ? url ? url.split(nodeDivider) : [] : url ? [url] : [];

			conThread(req, function (err) {
				// start session with client

				// must carefully set appropriate heads to prevent http-parse errors when using master-worker proxy
				if (TOTEM.isEncryptedWorker) Res.setHeader(&quot;Set-Cookie&quot;, [&quot;client=&quot; + req.client, &quot;service=&quot; + TOTEM.name]);

				if (err) // session validator rejected (bad cert)
					res(err);else if (nodes.length == 1) {
					// respond with only this node
					node = req.node = nodes.pop();
					routeNode(req, res);
				} else // respond with aggregate of all nodes
					syncNodes(nodes, {}, req, res);
			});
		});
	});
}

function resThread(req, cb) {
<span id='THREAD_PROCESSING-method-resThread'>	/**
</span> @private
 @method resThread
 @param {Object} req Totem session request
 @param {Function} cb sql connector callback(sql)
 
 Callback with request set to sql conector
 */
	sqlThread(function (sql) {
		cb(req.sql = sql);
	});
}

function Trace(msg, sql) {
	ENUM.trace(&quot;T&gt;&quot;, msg, sql);
}

function proxyService(req, res) {
	// not presently used but might want to support later

	var pathto = TOTEM.site.urls.master + req.path,

	//TOTEM.site.urls.master + &quot;/news&quot;,  
	//&quot;http://localhost:8081&quot; + req.path,

	proxy = URL.parse(pathto);

	proxy.method = req.method;

	Log(proxy, pathto);

	/*
 var sock = NET.connect( proxy.port );
 sock.setEncoding(&quot;utf8&quot;);
 sock.write(&quot;here is some data for u&quot;);
 sock.on(&quot;data&quot;, function (d) {
 	Log(&quot;sock rx&quot;, d);
 	res(d);
 }); */

	var Req = HTTP.request(pathto, function (Res) {
		Log(&quot;==========SETUP&quot;, Res.statusCode, Res.headers);

		var body = &quot;&quot;;

		Res.setEncoding(&quot;utf8&quot;);
		Res.on('data', function (chunk) {
			// will not trigger unless worker fails to end socket
			body += chunk;
		});

		Res.on(&quot;end&quot;, function () {
			Log(&quot;=========rx &quot; + body);
			res(body);
		});

		Res.on(&quot;error&quot;, function (err) {
			Log(&quot;what??? &quot; + err);
		});
	});

	Req.on('error', function (err) {
		Log(&quot;=========tx &quot; + err);
		res(&quot;oh well&quot;);
	});

	//Log( &quot;RELAY TX &quot;+JSON.stringify( req.body) );

	if (proxy.method == &quot;PUT&quot;) Req.write(JSON.stringify(req.body));

	Req.end();

	/*  
 generic
 		var http = require('http');
 
 http.createServer(function(request, response) {
   var proxy = http.createClient(80, request.headers['host'])
   var proxy_request = proxy.request(request.method, request.url, request.headers);
   proxy_request.addListener('response', function (proxy_response) {
     proxy_response.addListener('data', function(chunk) {
       response.write(chunk, 'binary');
     });
     proxy_response.addListener('end', function() {
       response.end();
     });
     response.writeHead(proxy_response.statusCode, proxy_response.headers);
   });
   request.addListener('data', function(chunk) {
     proxy_request.write(chunk, 'binary');
   });
   request.addListener('end', function() {
     proxy_request.end();
   });
 }).listen(8080);
 */

	/*
 var net = require('net');
 
 var LOCAL_PORT  = 6512;
 var REMOTE_PORT = 6512;
 var REMOTE_ADDR = &quot;192.168.1.25&quot;;
 
 var server = net.createServer(function (socket) {
     socket.on('data', function (msg) {
         Log('  ** START **');
         Log('&lt;&lt; From client to proxy ', msg.toString());
         var serviceSocket = new net.Socket();
         serviceSocket.connect(parseInt(REMOTE_PORT), REMOTE_ADDR, function () {
             Log('&gt;&gt; From proxy to remote', msg.toString());
             serviceSocket.write(msg);
         });
         serviceSocket.on(&quot;data&quot;, function (data) {
             Log('&lt;&lt; From remote to proxy', data.toString());
             socket.write(data);
             Log('&gt;&gt; From proxy to client', data.toString());
         });
     });
 });
 
 server.listen(LOCAL_PORT);
 Log(&quot;TCP server accepting connection on port: &quot; + LOCAL_PORT);
 */
}

/*
function simThread(sock) { 
	//Req.setSocketKeepAlive(true);
	Log({ip: sock.remoteAddress, port: sock.remotePort});
	sock.setEncoding(&quot;utf8&quot;);
	sock.on(&quot;data&quot;, function (req) {
		Log(&quot;sock data&gt;&gt;&gt;&gt;&quot;,req);
		var 
			Req = Copy({
				socket: sock  // used if master makes handoff
			}, JSON.parse(req)),
			
			Res = {  // used if master does not makes handoff
				end: function (ack) {
					sock.write(ack);
				}
			};
				
		sesThread(Req,Res);
	});
} */

// UNCLASSIFIED</pre>
</body>
</html>
