<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">&quot;use strict&quot;;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// UNCLASSIFIED 

<span id='DEBE'>/**
</span>@class DEBE
@requires child_process
@requires cluster
@requires child-process
@requires fs
@requires stream

@requires i18n-abide
@requires socket.io
@requires socket.io-clusterhub
@requires jade
@requires jade-filters
@requires markdown
@requires optimist
@requires tokml
@requires mathjax-node

@requires flex
@requires totem
@requires atomic
@requires geohack
@requires jslab
*/

var // globals
ENV = process.env,
    WINDOWS = process.platform == 'win32',
    //&lt; Is Windows platform
CRUDE = { select: 1, delete: 1, insert: 1, update: 1, execute: 1 };

var // NodeJS modules
CP = require(&quot;child_process&quot;),
    //&lt; Child process threads
CLUSTER = require(&quot;cluster&quot;),
    //&lt; Support for multiple cores
STREAM = require(&quot;stream&quot;),
    //&lt; pipe streaming
FS = require(&quot;fs&quot;); //&lt; NodeJS filesystem and uploads

var // 3rd party modules
ODOC = require(&quot;officegen&quot;),
    //&lt; office doc generator
LANG = require('i18n-abide'),
    //&lt; I18 language translator
ARGP = require('optimist'),
    //&lt; Command line argument processor
TOKML = require(&quot;tokml&quot;),
    //&lt; geojson to kml convertor
JAX = require(&quot;mathjax-node&quot;),
    //&lt; servde side mathjax parser
JADE = require('jade'); //&lt; using jade as the skinner

var // totem modules		
ATOM = require(&quot;atomic&quot;),
    FLEX = require(&quot;flex&quot;),
    TOTEM = require(&quot;totem&quot;),
    JSLAB = require(&quot;jslab&quot;),
    HACK = require(&quot;geohack&quot;);

var // shortcuts and globals
Copy = TOTEM.copy,
    Each = TOTEM.each,
    sqlThread = TOTEM.thread,
    Log = console.log;

var DEBE = module.exports = TOTEM.extend({

	// watchdog config parameters

	dogs: { // watch dog cycle timers [secs] (zero to disable)
		dogCatalog: Copy({
			//cycle: 1000,
			trace: &quot;&quot;
		}, function (sql, lims) {}),

		dogDetectors: Copy({
			cycle: 0,
			trace: &quot;&quot;
		}, function (sql, lims) {}),

		dogVoxels: Copy({
			//cycle: 120,
			trace: &quot;&quot;,
			atmage: 2 // days to age before refresh atm data
		}, function (sql, lims) {
			var gets = {
				unused: &quot;SELECT voxels.ID AS ID,aois.id AS aoiID FROM app.voxels LEFT JOIN app.aois ON aois.name=voxels.aoi HAVING aoiID IS null&quot;,
				refresh: &quot;SELECT ID FROM app.voxels WHERE MBRcontains(ring, GeomFromText(?)) AND datediff(now(), added) &gt; ?&quot;
			};

			sql.getEach(lims.trace, gets.unused, [], function (voxel) {
				sql.update(&quot;DELETE FROM app.voxels WHERE ?&quot;, { ID: voxel.ID });
			});

			if (lims.atmage) {
				// fetch new atm data from whatever service and loop over recs (grouped by Point(x y) grid location)

				sql.getEach(lims.trace, gets.refresh, [atm.gridLocation, lims.atmage], function (voxel) {
					// update voxels with atm data
				});
			}
		}),

		dogCache: Copy({
			//cycle: 120,
			trace: &quot;&quot;
		}, function (sql, lims) {}),

		dogFiles: Copy({
			cycle: 30, // secs
			trace: &quot;DOG&quot;
			//maxage: 30 // days
		}, function (sql, lims) {

			function pretty(stats, sigfig) {
				var rtn = [];
				Each(stats, function (key, stat) {
					rtn.push((stat || 0).toFixed(sigfig) + &quot; &quot; + key);
				});
				return rtn.join(&quot;, &quot;);
			}

			var gets = {
				ungraded: &quot;SELECT ID,Voxelized,Actors,States,Steps FROM app.files WHERE NOT graded&quot;,
				expired: &quot;SELECT ID FROM app.files WHERE now() &gt; Expired&quot;,
				update: &quot;UPDATE app.files SET canDelete=?, Notes=concat(Notes,?)&quot;,
				old: &quot;SELECT files.*,count(events.id) AS evCount FROM app.events LEFT JOIN app.files ON events.fileid = files.id WHERE datediff( now(), files.added)&gt;=? AND NOT files.canDelete GROUP BY fileid&quot;
			};

			sql.getEach(lims.trace, gets.expired, [], function (file) {
				Log(&quot;expired file&quot;, file);
				sql.query(&quot;DELETE FROM app.events WHERE ?&quot;, { fileID: file.ID });
				/*
    need to export events to output file, then archive this output file
    CP.exec(`git commit -am &quot;archive ${path}&quot;; git push github master; rm ${zip}`, function (err) {
    });		  */
			});

			if (lims.maxage) sql.getEach(lims.trace, gets.old, lims.maxage, function (file) {
				Log(&quot;maxage&quot;, file);

				var site = DEBE.site,
				    url = site.urls.worker,
				    paths = {
					info: &quot;here&quot;.tag(&quot;a&quot;, { href: url + &quot;/files.view&quot; }),
					admin: &quot;totem resource manages&quot;.tag(&quot;a&quot;, { href: url + &quot;/request.view&quot; })
				},
				    notice = &quot;\n&quot; + file.client + &quot; has been notified that &quot; + file.Name + &quot;, containing &quot; + file.eventCount + &quot; events, has been flagged for delete as it is older than &quot; + maxage + &quot; days.\nConsult &quot; + paths.admin + &quot; to request additional resources.  Further information about this file is available &quot; + paths.info + &quot;. &quot;;

				sql.query(files.update, [true, notice]);

				if (sendMail = FLEX.sendMail) sendMail({
					to: file.client,
					subject: &quot;TOTEM will be removing &quot; + file.Name,
					body: notice
				}, sql);
			}).on(&quot;end&quot;, function () {
				sql.release();
			});

			sql.getEach(lims.trace, gets.ungraded, [], function (file) {

				Log(&quot;dog file&quot;, file);

				if (file.Voxelized) DEBE.gradeIngest(sql, file, function (stats) {
					//cb( Copy(stats, aoi) );

					sql.getAll(lims.trace, &quot;SELECT events.ID AS ID FROM app.events LEFT JOIN app.voxels ON voxels.ID = events.voxelID WHERE ? &lt; voxels.minSNR AND ?&quot;, [stats.snr, { fileID: file.ID }], function (evs) {
						Log(&quot;dog rejected&quot;, evs.length);

						evs.each(function (n, ev) {
							sql.query(&quot;DELETE FROM app.events WHERE ?&quot;, { ID: ev.ID });
						});

						sql.getAll(lims.trace, &quot;UPDATE app.files SET ?, Notes=concat(Notes,?) WHERE ?&quot;, [{
							tag: JSON.stringify(stats),
							rejected: evs.length,
							coherence_time: stats.coherence_time,
							coherence_intervals: stats.coherence_intervals,
							//mean_jump_rate: stats.mean_jump_rate,
							degeneracy_param: stats.degeneracy_param,
							snr: stats.snr,
							graded: true
						}, &quot;Initial SNR assessment: &quot; + (stats.snr || 0).toFixed(4), { ID: file.ID }]);
					});
				});else sql.getAll(lims.trace, &quot;UPDATE app.files SET ?, Notes=concat(Notes,?) WHERE ?&quot;, [{
					Graded: true }, +&quot;No events fell into &quot; + &quot;existing voxels&quot;.tag(&quot;a&quot;, { href: &quot;/aois.run&quot; }), { ID: file.ID }]);
			});
		}),

		dogJobs: Copy({
			cycle: 300,
			trace: &quot;&quot;
		}, function (sql, lims) {
			var gets = {
				stuck: &quot;UPDATE app.queues SET Departed=now(), Notes=concat(Notes, ' is ', link('billed', '/profile.view')), Age=Age + (now()-Arrived)/3600e3, Finished=1 WHERE least(Departed IS NULL,Done=Work)&quot;
			},
			    queues = FLEX.queues;

			sql.getAll(lims.trace, gets.stuck, [], function (info) {

				Each(queues, function (rate, queue) {
					// save collected queuing charges to profiles
					Each(queue.client, function (client, charge) {

						if (charge.bill) {
							if (trace) Trace(trace + &quot; &quot; + client + &quot; &quot; + charge.bill + &quot; CREDITS&quot;, sql);

							sql.query(&quot;UPDATE openv.profiles SET Charge=Charge+?,Credit=greatest(0,Credit-?) WHERE ?&quot;, [charge.bill, charge.bill, { Client: client }], function (err) {
								Log({ charging: err });
							});
							charge.bill = 0;
						}
					});
				});

				sql.release();
			});
		}),

		dogSystem: Copy({
			//cycle: 100,
			pigs: 2,
			jobs: 5,
			trace: &quot;&quot;
		}, function (sql, lims) {
			// system diag watch dog
			var gets = {
				engs: &quot;SELECT count(ID) AS Count FROM app.engines WHERE Enabled&quot;,
				jobs: &quot;SELECT count(ID) AS Count FROM app.queues WHERE Departed IS NULL&quot;,
				pigs: &quot;SELECT sum(DateDiff(Departed,Arrived)&gt;1) AS Count from app.queues&quot;,
				logs: &quot;SELECT sum(Delay&gt;20)+sum(Fault != '') AS Count FROM app.dblogs&quot;
			},
			    diag = DEBE.diag;

			sql.getEach(lims.trace, gets.engs, [], function (engs) {
				sql.getEach(lims.trace, gets.jobs, [], function (jobs) {
					sql.getEach(lims.trace, gets.pigs, [], function (pigs) {
						sql.getEach(lims.trace, gets.logs, [], function (isps) {
							var rtn = diag.counts = { Engines: engs.Count, Jobs: jobs.Count, Pigs: pigs.Count, Faults: isps.Count, State: &quot;ok&quot; };

							for (var n in lims) {
								if (rtn[n] &gt; 5 * lims[n]) rtn.State = &quot;critical&quot;;else if (rtn[n] &gt; lims[n]) rtn.State = &quot;warning&quot;;
							}sql.release();
						});
					});
				});
			});
		}),

		dogHawks: Copy({
			//cycle: 500,
			maxage: 10,
			trace: &quot;&quot;
		}, function (sql, lims) {
			// job hawking watch dog
			/*
    * Hawk over jobs in the queues table given {Action,Condition,Period} rules 
    * defined in the hawks table.  The rule is run on the interval specfied 
    * by Period (minutes).  Condition in any valid sql where clause. Actions 
    * supported:
    * 		stop=halt=kill to kill matched jobs and update its queuing history
    * 		remove=destroy=delete to kill matched jobs and obliterate its queuing history
    * 		log=notify=flag=tip to email client a status of matched jobs
    * 		improve=promote to increase priority of matched jobs
    * 		reduce=demote to reduce priority of matached jobs
    * 		start=run to run jobs against dirty records
    * 		set expression to revise queuing history of matched jobs	 
    * */
			var gets = {
				unbilled: &quot;SELECT * FROM app.queues WHERE Finished AND NOT Billed&quot;,
				unfunded: &quot;SELECT * FROM app.queues WHERE NOT Funded AND now()-Arrived&gt;?&quot;
			};

			sql.getEach(lims.trace, gets.unbilled, [], function (job) {
				//Trace(`BILLING ${job} FOR ${job.Client}`, sql);
				sql.query(&quot;UPDATE openv.profiles SET Charge=Charge+? WHERE ?&quot;, [job.Done, { Client: job.Client }]);

				sql.query(&quot;UPDATE app.queues SET Billed=1 WHERE ?&quot;, { ID: job.ID });
			});

			if (lims.maxage) sql.getEach(trace, gets.unfunded, [lims.maxage], function (job) {
				//Trace(&quot;KILLING &quot;,job);
				sql.query();
			}
			//&quot;DELETE FROM app.queues WHERE ?&quot;, {ID:job.ID}
			);

			sql.release();
		}),

		dogClients: Copy({
			//cycle: 100000,
			trace: &quot;&quot;,
			disk: 10, //MB
			qos: 2, //0,1,2,...
			unused: 4, // days
			certage: 360 // days
		}, function (sql, lims) {
			var gets = {
				needy: &quot;SELECT ID FROM openv.profiles WHERE useDisk&gt;?&quot;,
				dormant: &quot;&quot;,
				poor: &quot;&quot;,
				naughty: &quot;SELECT ID FROM openv.profiles WHERE Banned&quot;,
				uncert: &quot;SELECT ID FROM openv.profiles LEFT JOIN app.quizes ON profiles.Client=quizes.Client WHERE datediff(now(), quizes.Credited)&gt;?&quot;
			};

			sql.getEach(lims.trace, gets.naughty, [], function (client) {});

			if (lims.disk) sql.getEach(lims.trace, gets.needy, [lims.disk], function (client) {});

			if (lims.dormant) sql.getEach(lims.trace, gets.dormant, [lims.unused], function (client) {});

			if (lims.poor) sql.getEach(lims.trace, gets.poor, [lims.qos], function (client) {});

			if (lims.certage) sql.getEach(lims.trace, gets.uncert, [lims.certage], function (client) {});
		}),

		dogEngines: Copy({
			cycle: 0,
			trace: &quot;&quot;,
			&quot;undefined&quot;: 123,
			bugs: 10
		}, function (sql, lims) {
			var gets = {
				&quot;undefined&quot;: &quot;&quot;,
				buggy: &quot;&quot;
			};

			if (lims.undefined) sql.getEach(lims.trace, gets.undefined, [lims.undefined], function (client) {});
		}),

		dogUsers: Copy({
			cycle: 0,
			trace: &quot;&quot;,
			inactive: 1,
			bugs: 10
		}, function (sql, lims) {
			var gets = {
				inactive: &quot;&quot;,
				buggy: &quot;&quot;
			};

			if (lims.inactive) sql.getEach(lims.trace, gets.inactive, [lims.inactive], function (client) {});
		})
	},

	diag: { // self diag parms
		status: &quot;&quot;,
		counts: { State: &quot;&quot; }
	},

	// request config parameters

	&quot;reqFlags.&quot;: { //&lt; endpoint request flags

		traps: { // TRAP=name flags can modify the request flags
			save: function save(req) {
				//&lt; _save=name retains query in named engine
				var sql = req.sql,
				    cleanurl = req.url.replace(&quot;_save=&quot; + req.flags.save, &quot;&quot;);

				Trace(&quot;PUBLISH &quot; + cleanurl + &quot; AT &quot; + req.flags.save + &quot; FOR &quot; + req.client, sql);
				sql.query(&quot;INSERT INTO app.engines SET ?&quot;, {
					Name: req.flags.save,
					Enabled: 1,
					Type: &quot;url&quot;,
					Code: cleanurl
				});
			},

			browse: function browse(req) {
				//&lt; _browse=name navigates named folder
				var query = req.query,
				    flags = req.flags;
				query.NodeID = parseInt(query.init) ? &quot;&quot; : query.target || &quot;&quot;;
				flags.nav = [query.NodeID, query.cmd];
				delete query.cmd;
				delete query.init;
				delete query.target;
				delete query.tree;
			},

			view: function view(req) {
				//&lt; ?_view=name correlates named view to request dataset
				req.sql.query(&quot;INSERT INTO openv.viewers SET ?&quot;, {
					Viewer: req.flags.view,
					Dataset: req.table
				});
			}
		},

		blog: function blog(src, ds, dsname, cb) {
			// blog=key,... request flag
			function renderEmac(ds, src) {
				try {
					return eval(&quot;`&quot; + src + &quot;`&quot;);
				} catch (err) {
					return src;
				}
			}
			function renderMath(tex, src, cb) {
				var rtn = src,
				    isEmpty = tex.each(function (n, tex, isLast) {

					JAX.typeset({
						math: tex,
						format: &quot;TeX&quot;, // TeX, inline-TeX, AsciiMath, MathML
						mml: true
					}, function (d) {
						rtn = rtn.replace(&quot;$math&quot; + n, d.mml);
						if (isLast) cb(rtn);
					});
				});

				if (isEmpty) cb(rtn);
			}

			var tex = [];

			renderMath(tex,
			//renderEmac(ds,src)
			src.replace(/\$\$(.|\n)*\$\$/g, function (m, i) {
				// tex markfown
				tex.push(m.substr(2, m.length - 4));
				return &quot;$math&quot; + (tex.length - 1);
			}).replace(/\[.*\]\((.*?)\)/g, function (m, i) {
				// [x,w,h,s](u) markdown
				m = m.substr(1, m.length - 2).split(&quot;](&quot;);
				var v = m[0].split(&quot;,&quot;),
				    u = m[1] || &quot;missing url&quot;,
				    x = v[0] || &quot;&quot;,
				    w = v[1] || 100,
				    h = v[2] || 100,
				    s = v[3] || dsname + &quot;?ID=&quot; + ds.ID,
				    p = u.split(&quot;;&quot;).join(&quot;&amp;&quot;);

				switch (x) {
					case &quot;update&quot;:
						return x.tag(&quot;a&quot;, { href: dsname + &quot;.exe?ID=&quot; + ds.ID }) + &quot;&quot;.tag(&quot;iframe&quot;, { src: u, width: w, height: h });
					case &quot;image&quot;:
						return &quot;&quot;.tag(&quot;img&quot;, { src: u, width: w, height: h });
					case &quot;post&quot;:
						return &quot;&quot;.tag(&quot;iframe&quot;, { src: u, width: w, height: h });
					case &quot;nada&quot;:
						return &quot;[nada](&quot; + u + &quot;)&quot;;
					case &quot;link&quot;:
						return x.tag(&quot;a&quot;, { href: u });
					default:
						return &quot;&quot;.tag(&quot;iframe&quot;, { src: &quot;/&quot; + x + &quot;.view?&quot; + p + &quot;&amp;w=&quot; + w + &quot;&amp;h=&quot; + h + &quot;&amp;ds=&quot; + s, width: w, height: h });
				}
			}).replace(/href=.*&gt;/g, function (m, i) {
				// follow &lt;a href=B&gt;A&lt;/a&gt; links
				var q = i.charAt(0) == &quot;'&quot; ? '&quot;' : &quot;'&quot;;
				return &quot;href=&quot; + q + &quot;javascript:navigator.follow(&quot; + i + &quot;,BASE.user.client,BASE.user.source)&quot; + q + &quot;&gt;&quot;;
			}), cb);
		}

	},

	&quot;reqTypes.&quot;: { //&lt; endpoint types to convert dataset recs on specifed req-res thread
		view: function view(recs, req, res) {
			//&lt; dataset.view returns rendered skin
			res(recs);
		},

		exe: function exe(recs, req, res) {
			res(recs);
		},

		kml: function kml(recs, req, res) {
			//&lt; dataset.kml converts to kml
			res(TOKML({}));
		},

		flat: function index(recs, req, res) {
			//&lt; dataset.flat flattens records
			recs.each(function (n, rec) {
				var rtns = new Array();
				for (var key in rec) {
					rtns.push(rec[key]);
				}recs[n] = rtns;
			});
			res(recs);
		},

		txt: function txt(recs, req, res) {
			//&lt; dataset.txt convert to text
			var head = recs[0],
			    cols = [],
			    cr = String.fromCharCode(13),
			    txt = &quot;&quot;,
			    list = &quot;,&quot;;

			if (head) {
				for (var n in head) {
					cols.push(n);
				}txt += cols.join(list) + cr;

				recs.each(function (n, rec) {
					var cols = [];
					for (var n in rec) {
						cols.push(rec[n]);
					}txt += cols.join(list) + cr;
				});
			}

			res(txt);
		},

		json: function json(recs, req, res) {
			res(recs);
		},

		stat: function stat(recs, req, res) {
			// dataset.stat provide info
			var table = req.table,
			    group = req.group,
			    uses = [&quot;db&quot;, &quot;xml&quot;, &quot;csv&quot;, &quot;txt&quot;, &quot;tab&quot;, &quot;view&quot;, &quot;tree&quot;, &quot;flat&quot;, &quot;delta&quot;, &quot;nav&quot;, &quot;encap&quot;, &quot;html&quot;, &quot;json&quot;, &quot;view&quot;, &quot;pivot&quot;, &quot;site&quot;, &quot;spivot&quot;, &quot;brief&quot;, &quot;gridbrief&quot;, &quot;pivbrief&quot;, &quot;run&quot;, &quot;plugin&quot;, &quot;runbrief&quot;, &quot;exe&quot;, &quot;stat&quot;];

			uses.each(function (n, use) {
				uses[n] = use.tag(&quot;a&quot;, { href: &quot;/&quot; + table + &quot;.&quot; + use });
			});

			req.sql.query(&quot;DESCRIBE ??.??&quot;, [group, table], function (err, stats) {

				if (err) res(err);else {
					stats.each(function (n, stat) {
						stats[n] = stat.Field.tag(&quot;a&quot;, { href: &quot;/&quot; + table + &quot;?_index=&quot; + stat.Field });
					});

					res(&quot;\nRecords: &quot; + recs.length + &quot;&lt;br&gt;\nFields: &quot; + stats.join(&quot;,&quot;) + &quot;&lt;br&gt;\nUsage: &quot; + uses.join(&quot;,&quot;) + &quot;  &quot;);
				}
			});
		},

		html: function html(recs, req, res) {
			//&lt; dataset.html converts to html
			res(DEBE.site.gridify(recs).tag(&quot;table&quot;));
		},

		// events from engine usecase
		default: function _default(recs, req, res) {
			var filename = req.table + &quot;.&quot; + req.type,
			    group = req.group,
			    type = req.type,
			    sql = req.sql;

			sql.getFirst(type, &quot;SELECT ID FROM ??.files WHERE ?&quot;, [group, { Name: filename }], function (file) {

				if (file) sql.getAll(type, &quot;SELECT * FROM ??.events WHERE ?&quot;, [group, { fileID: file.ID }], res);else res(null);
			});
		},

		// MS office doc reqTypes
		xdoc: genDoc,
		xxls: genDoc,
		xpps: genDoc,
		xppt: genDoc,

		tree: function tree(recs, req, res) {
			//&lt; dataset.tree treeifies records sorted with _sort=keys
			res({
				name: &quot;root&quot;,
				weight: 1,
				children: recs.treeify(0, recs.length, 0, (req.flags.sort || &quot;&quot;).split(&quot;,&quot;))
			});
		},

		delta: function delta(recs, req, res) {
			//&lt; dataset.delta adds change records from last baseline
			var sql = req.sql;
			var ctx = {
				src: {
					table: &quot;baseline.&quot; + req.table
				}
			};

			sql.context(ctx, function (ctx) {
				// establish skinning context for requested table
				ctx.src.rec = function (Recs, me) {
					// select the baseline records 

					if (Recs.constructor == Error) res(Recs);else res(recs.merge(Recs, Object.keys(Recs[0] || {})));
				};
			});
		},

		encap: function encap(recs, req, res) {
			//&lt; dataset.encap to encap records
			res({ encap: recs });
		},

		nav: function nav(recs, req, res) {
			//&lt; dataset.nav to navigate records pivoted with _browse=keys

			/*
   Log({
   	i: &quot;nav&quot;,
   	c: keys,
   	f: req.flags,
   	q: req.query
   });*/

			var keys = Object.keys(recs[0] || {}),
			    flags = req.flags,
			    query = req.query,
			    Browse = flags.browse.split(&quot;,&quot;),
			    Cmd = keys.pop(),
			    Slash = &quot;_&quot;,
			    Parent = keys.pop(),
			    Nodes = Parent ? Parent.split(Slash) : [],
			    Folder = Browse[Nodes.length],
			    Parent = Parent || &quot;root&quot;,
			    Files = [{ // prime the side tree area
				mime: &quot;directory&quot;,
				ts: 1334071677,
				read: 1,
				write: 0,
				size: recs.length,
				hash: Parent,
				volumeid: &quot;v1&quot;,
				//phash: Back,	// cant do this for some reason
				name: Parent + (Folder ? &quot;:&quot; + Folder : &quot;&quot;),
				locked: 1,
				dirs: 1
			}];

			Trace(&quot;NAVIGATE Recs=&quot; + recs.length + &quot; Parent=&quot; + Parent + &quot; Nodes=&quot; + Nodes + &quot; Folder=&quot; + Folder);

			if (Folder) // at branch
				recs.each(function (n, rec) {
					Files.push({
						mime: &quot;directory&quot;, // mime type
						ts: 1310252178, // time stamp format?
						read: rec.read, // read state
						write: rec.write, // write state
						size: rec.NodeCount, // size
						hash: rec.NodeID, // hash name
						name: rec.name || &quot;?&quot; + n, // keys name
						phash: Parent, // parent hash name
						locked: rec.locked, // lock state
						volumeid: rec.group,
						dirs: 1 // place inside tree too
					});
				});else // at leaf
				recs.each(function (n, rec) {
					// at leafs
					Files.push({
						mime: &quot;application/tbd&quot;, //&quot;application/x-genesis-rom&quot;,	//&quot;image/jpg&quot;, // mime type
						ts: 1310252178, // time stamp format?
						read: rec.read, // read state
						write: rec.write, // write state
						size: rec.NodeCount, // size
						hash: rec.NodeID, // hash name
						name: rec.name || &quot;?&quot; + n, // keys name
						phash: Parent, // parent hash name
						volumeid: rec.group,
						locked: rec.locked // lock state
					});
				});

			//Log(Files);	

			switch (Cmd) {// Handle keys nav
				case &quot;test&quot;:
					// canonical test case for debugging					
					res({
						cwd: {
							&quot;mime&quot;: &quot;directory&quot;,
							&quot;ts&quot;: 1334071677,
							&quot;read&quot;: 1,
							&quot;write&quot;: 0,
							&quot;size&quot;: 0,
							&quot;hash&quot;: &quot;root&quot;,
							&quot;volumeid&quot;: &quot;l1_&quot;,
							&quot;name&quot;: &quot;Demo&quot;,
							&quot;locked&quot;: 1,
							&quot;dirs&quot;: 1 },

						/*&quot;options&quot;:{
      	&quot;path&quot;:&quot;&quot;, //&quot;Demo&quot;,
      	&quot;url&quot;:&quot;&quot;, //&quot;http:\/\/elfinder.org\/files\/demo\/&quot;,
      	&quot;tmbUrl&quot;:&quot;&quot;, //&quot;http:\/\/elfinder.org\/files\/demo\/.tmb\/&quot;,
      	&quot;disabled&quot;:[&quot;extract&quot;],
      	&quot;separator&quot;:&quot;\/&quot;,
      	&quot;copyOverwrite&quot;:1,
      	&quot;archivers&quot;: {
      		&quot;create&quot;:[&quot;application\/x-tar&quot;, &quot;application\/x-gzip&quot;],
      		&quot;extract&quot;:[] }
      },*/

						files: [{ // cwd again
							&quot;mime&quot;: &quot;directory&quot;,
							&quot;ts&quot;: 1334071677,
							&quot;read&quot;: 1,
							&quot;write&quot;: 0,
							&quot;size&quot;: 0,
							&quot;hash&quot;: &quot;root&quot;,
							&quot;volumeid&quot;: &quot;l1_&quot;,
							&quot;name&quot;: &quot;Demo&quot;,
							&quot;locked&quot;: 1,
							&quot;dirs&quot;: 1 },

						/*{
      &quot;mime&quot;:&quot;directory&quot;,
      &quot;ts&quot;:1334071677,
      &quot;read&quot;:1,
      &quot;write&quot;:0,
      &quot;size&quot;:0,
      &quot;hash&quot;:&quot;root&quot;,
      &quot;volumeid&quot;:&quot;l1_&quot;,
      &quot;name&quot;:&quot;Demo&quot;,
      &quot;locked&quot;:1,
      &quot;dirs&quot;:1},*/

						{
							&quot;mime&quot;: &quot;directory&quot;,
							&quot;ts&quot;: 1340114567,
							&quot;read&quot;: 0,
							&quot;write&quot;: 0,
							&quot;size&quot;: 0,
							&quot;hash&quot;: &quot;l1_QmFja3Vw&quot;,
							&quot;name&quot;: &quot;Backup&quot;,
							&quot;phash&quot;: &quot;root&quot;,
							&quot;locked&quot;: 1 }, {
							&quot;mime&quot;: &quot;directory&quot;,
							&quot;ts&quot;: 1310252178,
							&quot;read&quot;: 1,
							&quot;write&quot;: 0,
							&quot;size&quot;: 0,
							&quot;hash&quot;: &quot;l1_SW1hZ2Vz&quot;,
							&quot;name&quot;: &quot;Images&quot;,
							&quot;phash&quot;: &quot;root&quot;,
							&quot;locked&quot;: 1 }, {
							&quot;mime&quot;: &quot;directory&quot;,
							&quot;ts&quot;: 1310250758,
							&quot;read&quot;: 1,
							&quot;write&quot;: 0,
							&quot;size&quot;: 0,
							&quot;hash&quot;: &quot;l1_TUlNRS10eXBlcw&quot;,
							&quot;name&quot;: &quot;MIME-types&quot;,
							&quot;phash&quot;: &quot;root&quot;,
							&quot;locked&quot;: 1 }, {
							&quot;mime&quot;: &quot;directory&quot;,
							&quot;ts&quot;: 1268269762,
							&quot;read&quot;: 1,
							&quot;write&quot;: 0,
							&quot;size&quot;: 0,
							&quot;hash&quot;: &quot;l1_V2VsY29tZQ&quot;,
							&quot;name&quot;: &quot;Welcome&quot;,
							&quot;phash&quot;: &quot;root&quot;,
							&quot;locked&quot;: 1,
							&quot;dirs&quot;: 1 }, {
							&quot;mime&quot;: &quot;directory&quot;,
							&quot;ts&quot;: 1390785037,
							&quot;read&quot;: 1,
							&quot;write&quot;: 1,
							&quot;size&quot;: 0,
							&quot;hash&quot;: &quot;l2_Lwxxyyzz&quot;,
							&quot;volumeid&quot;: &quot;l2_&quot;,
							&quot;name&quot;: &quot;Test here&quot;,
							&quot;locked&quot;: 1 }, {
							&quot;mime&quot;: &quot;application\/x-genesis-rom&quot;,
							&quot;ts&quot;: 1310347586, &quot;read&quot;: 1,
							&quot;write&quot;: 0,
							&quot;size&quot;: 3683,
							&quot;hash&quot;: &quot;l1_UkVBRE1FLm1k&quot;,
							&quot;name&quot;: &quot;README.md&quot;,
							&quot;phash&quot;: &quot;root&quot;,
							&quot;locked&quot;: 1 }],

						api: &quot;2.0&quot;, &quot;uplMaxSize&quot;: &quot;16M&quot;, &quot;netDrivers&quot;: [],

						debug: {
							&quot;connector&quot;: &quot;php&quot;,
							&quot;phpver&quot;: &quot;5.3.26-1~dotdeb.0&quot;,
							&quot;time&quot;: 0.016080856323242,
							&quot;memory&quot;: &quot;1307Kb \/ 1173Kb \/ 128M&quot;,
							&quot;upload&quot;: &quot;&quot;,
							&quot;volumes&quot;: [{ &quot;id&quot;: &quot;l1_&quot;,
								&quot;name&quot;: &quot;localfilesystem&quot;,
								&quot;mimeDetect&quot;: &quot;internal&quot;,
								&quot;imgLib&quot;: &quot;imagick&quot; }, { &quot;id&quot;: &quot;l2_&quot;,
								&quot;name&quot;: &quot;localfilesystem&quot;,
								&quot;mimeDetect&quot;: &quot;internal&quot;,
								&quot;imgLib&quot;: &quot;gd&quot; }],

							&quot;mountErrors&quot;: [] }
					});
					break;

				/*case &quot;tree&quot;: 	// not sure when requested
    	return {
    		tree: Files,
    			debug: {
    			connector:&quot;php&quot;,
    			phpver:&quot;5.3.26-1~dotdeb.0&quot;,
    			time:0.016080856323242,
    			memory:&quot;1307Kb \/ 1173Kb \/ 128M&quot;,
    			upload:&quot;&quot;,
    			volumes:[{	id:&quot;l1_&quot;,
    						name:&quot;localfilesystem&quot;,
    						mimeDetect:&quot;internal&quot;,
    						imgLib:&quot;imagick&quot;},
    						{	id:&quot;l2_&quot;,
    						name:&quot;localfilesystem&quot;,
    						mimeDetect:&quot;internal&quot;,
    						imgLib:&quot;gd&quot;}],
    				mountErrors:[]
    		}		
    	};	
    	break;*/

				case &quot;size&quot;:
					// on directory info
					res({
						size: 222
					});
					break;

				case &quot;parents&quot;: // not sure when requested
				case &quot;rename&quot;: // on rename with name=newname
				case &quot;keys&quot;:
					// on open via put, on download=1 via get
					res({
						message: &quot;TBD&quot;
					});
					break;

				case &quot;tree&quot;:
				case &quot;open&quot;:
					// on double-click to follow
					res({
						cwd: Files[0],
						/*{ 
      	mime:&quot;directory&quot;,
      	ts:1334071677,
      	read:1,
      	write:0,
      	size:999,
      	hash: flags.NodeID,
      	phash: &quot;&quot;, //cwdBack,
      	volumeid:&quot;tbd&quot;, //&quot;l1_&quot;,
      	name: Folder,
      	locked:0,
      	dirs:1},*/

						options: {
							path: &quot;/&quot;, //cwdPath,
							url: &quot;/&quot;, //&quot;/root/&quot;,
							tmbUrl: &quot;/root/.tmb/&quot;,
							disabled: [&quot;extract&quot;],
							separator: Slash,
							copyOverwrite: 1,
							archivers: {
								create: [&quot;application/x-tar&quot;, &quot;application/x-gzip&quot;],
								extract: [] }
						},

						files: Files,

						api: &quot;2.0&quot;,
						uplMaxSize: &quot;16M&quot;,
						netDrivers: [],

						debug: {
							connector: &quot;php&quot;,
							phpver: &quot;5.3.26-1~dotdeb.0&quot;,
							time: 0.016080856323242,
							memory: &quot;1307Kb \/ 1173Kb \/ 128M&quot;,
							upload: &quot;&quot;,
							volumes: [{ id: &quot;v1&quot;,
								name: &quot;localfilesystem&quot;,
								mimeDetect: &quot;internal&quot;,
								imgLib: &quot;imagick&quot; }, { id: &quot;v2&quot;,
								name: &quot;localfilesystem&quot;,
								mimeDetect: &quot;internal&quot;,
								imgLib: &quot;gd&quot; }],
							mountErrors: []
						}
					});
					break;

				default:
					res({
						message: &quot;bad navigation command&quot;
					});
			}
		}

	},

	// endpoint router config parameters

	&quot;byArea.&quot;: {//&lt; routers for endpoints at /AREA/file ...
	},

	&quot;byTable.&quot;: { //&lt; routers for endpoints at /TABLE
		help: sysHelp,
		stop: sysStop,
		alert: sysAlert,
		ping: sysPing,
		bit: sysBIT
		//kill: sysKill,
		//start: sysStart,
		//checkpt: sysCheckpt,
		//codes: sysCodes,
		//agent: sysAgent
		//config: sysConfig
	},

	&quot;byType.&quot;: { //&lt; routers for endpoint types at /DATASET.TYPE
		code: sendCode,
		jade: sendCode,
		classif: sendAttr,
		readability: sendAttr,
		client: sendAttr,
		size: sendAttr,
		risk: sendAttr,

		view: renderSkin,
		run: renderSkin,
		plugin: renderSkin,
		site: renderSkin,
		brief: renderSkin,
		pivot: renderSkin,
		gridbrief: renderSkin,
		runbrief: renderSkin,
		pivbrief: renderSkin,

		//sim: simEngine,
		exe: exeEngine,
		add: extendPlugin,
		sub: retractPlugin
	},

	&quot;byActionTable.&quot;: {//&lt; routers for CRUD endpoints at /DATASET 
	},

	// private parameters

	admitRule: null, //&lt; admitRule all clients by default 	
	/*{ &quot;u.s. government&quot;: &quot;required&quot;,
  * 	&quot;us&quot;: &quot;optional&quot;
  * }*/

	&quot;site.&quot;: { //&lt; initial site context

		classif: {
			level: &quot;&quot;,
			purpose: &quot;&quot;,
			banner: &quot;&quot;
		},

		info: {},

		get: function get(recs, where, index, subs) {
			//&lt; index dataset
<span id='SKINS-method-get'>			/**
</span>   @member SKINS
   @method get
   Provides a data indexer when a skin is being rendered.
   @param {Array} recs Record source
   @param {Array} where {recKey:value, ...} to match recs
   @param {Array} index &quot;recKey,...&quot; keys to retain from recs
   @param {Array} subs {hash: {recKey: {key:value, ...}. ...}, ...} replace record values
   */

			function select(keys) {

				switch ((keys || 0).constructor) {
					case Object:
						for (var key in keys) {
							return &quot;SELECT * FROM ??.?? WHERE least(?,1)&quot;;
						}return &quot;SELECT * FROM ??.??&quot;;

					case Array:
						return &quot;&quot;;

					case String:
						return &quot;SELECT * FROM ??.? WHERE &quot; + keys;

					case Function:
						return &quot;&quot;;

					default:
						return &quot;&quot;;
				}
			}

			var rtns = [];

			switch ((index || 0).constructor) {
				case String:
					var idx = {};
					index.split(&quot;,&quot;).each(function (n, key) {
						idx[key] = key;
					});
					index = idx;
					break;

				case Array:
					return null;
					break;

				case Function:
					sqlThread(function (sql) {
						try {
							sql.query(select(where), [req.group, recs, where], function (err, recs) {
								index(err ? [] : recs);
							});
							sql.release();
						} catch (err) {
							index([]);
						}
					});
					return null;
			}

			recs.each(function (n, rec) {
				var match = true;

				if (where) for (var x in where) {
					if (rec[x] != where[x]) match = false;
				}if (match) {
					if (subs) Each(subs, function (pre, sub) {
						// make #key and ##kEy substitutions
						for (var idx in sub) {
							var keys = sub[idx];
							if (rec[idx]) for (var key in keys) {
								rec[idx] = (rec[idx] + &quot;&quot;).replace(pre + key, keys[key]);
							}
						}
					});

					/*
     if (sub1) {
     	for (var idx in sub1) {
     		var keys = sub1[idx];
     		if ( rec[idx] )
     			for (var key in keys)
     				rec[idx] = (rec[idx] + &quot;&quot;).replace(&quot;#&quot; + key, keys[key]);
     	}
     }*/

					if (index) {
						var rtn = new Object();
						for (var key in index) {
							var src = rec;
							key.split(&quot;.&quot;).each(function (k, idx) {
								src = src[idx];
							});
							rtn[index[key]] = src;
						}
						rec = rtn;
					}

					rtns.push(rec);
				}
			});

			return rtns;
		},

		json: function json(recs) {
			//&lt; jsonize dataset
<span id='SKINS-method-json'>			/**
</span>   @member SKINS
   @method json
   Jsonize records.
   @param {Array} recs Record source
   */
			return JSON.stringify(recs);
		},

		tag: function tag(src, el, tags) {
<span id='SKINS-method-tag'>			/**
</span>   @member SKINS
   @method tag
   */
			return tags ? src.tag(el, tags) : src.tag(&quot;a&quot;, { href: el });;
		},

		hover: function hover(ti, fn) {
<span id='SKINS-method-hover'>			/**
</span>   @member SKINS
   @method hover
   Title ti fileName fn
   */
			if (fn.charAt(0) != &quot;/&quot;) fn = &quot;/shares/&quot; + fn;
			return ti.tag(&quot;p&quot;, { class: &quot;sm&quot; }) + (&quot;&quot;.tag(&quot;img&quot;, { src: fn + &quot;.jpg&quot; }) + &quot;&quot;.tag(&quot;iframe&quot;, { src: fn + &quot;.html&quot; }).tag(&quot;div&quot;, { class: &quot;ctr&quot; }).tag(&quot;div&quot;, { class: &quot;mid&quot; })).tag(&quot;div&quot;, { class: &quot;container&quot; });
		},

		gridify: function gridify(recs, noheader) {
			//&lt; dump dataset as html table
<span id='SKINS-method-gridify'>			/**
</span>   @member SKINS
   @method gridify
   */
			function join(recs, sep) {
				switch (recs.constructor) {
					case Array:
						return this.join(sep);

					case Object:
						var rtn = [];
						for (var n in this) {
							rtn.push(this[n]);
						}return rtn.join(sep);

					default:
						return this;
				}
			}

			function table(recs) {
				// generate an html table from given data or object
				switch (recs.constructor) {
					case Array:
						// [ {head1:val}, head2:val}, ...]  create table from headers and values

						var rtn = &quot;&quot;,
						    head = !noheader,
						    heads = {};

						recs.each(function (n, rec) {
							Each(rec, function (key, val) {
								heads[key] = key;
							});
						});

						recs.each(function (n, rec) {

							if (head) {
								var row = &quot;&quot;;
								Each(heads, function (key, val) {
									row += key.tag(&quot;th&quot;);
								});
								rtn += row.tag(&quot;tr&quot;);
								head = false;
							}

							var row = &quot;&quot;,
							    intro = &quot;&quot;;
							Each(heads, function (key, val) {
								if (val = rec[key]) row += val.constructor == Array ? table(val) : (val + &quot;&quot;).tag(&quot;td&quot;, intro ? { class: &quot;intro&quot; } : {});else row += &quot;&quot;.tag(&quot;td&quot;);

								intro = false;
							});
							rtn += row.tag(&quot;tr&quot;);
						});

						return rtn; //.tag(&quot;table&quot;,{}); //.tag(&quot;div&quot;,{style:&quot;overflow-x:auto&quot;});

					case Object:
						// { key:val, ... } create table dump of object hash

						var rtn = &quot;&quot;;
						Each(recs, function (key, val) {
							if (val) rtn += val.constructor == Array ? table(val) : (key.tag(&quot;td&quot;) + JSON.stringify(val).tag(&quot;td&quot;)).tag(&quot;tr&quot;);
						});

						return rtn.tag(&quot;table&quot;);

					default:
						return recs + &quot;&quot;;
				}
			}

			function dump(x) {
				rtn = &quot;&quot;;
				for (var n in x) {
					switch (x[n].constructor) {
						case Object:
							rtn += dump(x[n]);break;
						case Array:
							rtn += n + &quot;[]&quot;;break;
						case Function:
							rtn += n + &quot;()&quot;;break;
						default:
							rtn += n;
					}
					rtn += &quot;; &quot;;
				}
				return rtn;
			}

			return table(recs);
		},

<span id='SKINS-cfg-context'>		/**
</span>  @private
  @cfg {Object}
  @member SKINS
  */
		context: { // define JSDB context keys when a skin is rendered
			swag: { // context keys for swag.jade
				projs: &quot;openv.milestones&quot;
			},
			airspace: {
				projs: &quot;openv.milestones&quot;
			},
			plugin: {
				projs: &quot;openv.milestones&quot;
			},
			briefs: {
				projs: &quot;openv.milestones&quot;
			},
			rtpsqd: {
				apps: &quot;openv.apps&quot;,
				users: &quot;openv.profiles&quot;,
				projs: &quot;openv.milestones&quot;,
				QAs: &quot;app.QAs&quot;
				//stats:{table:&quot;openv.profiles&quot;,group:&quot;client&quot;,index:&quot;client,event&quot;}
			}
		}
	},

	&quot;errors.&quot;: { //&lt; error messages
		pretty: function pretty(err) {
			return &quot;&quot;.tag(&quot;img&quot;, { src: &quot;/shares/reject.jpg&quot;, width: 40, height: 60 }) + (err + &quot;&quot;).replace(/\n/g, &quot;&lt;br&gt;&quot;).replace(process.cwd(), &quot;&quot;).replace(&quot;Error:&quot;, &quot;&quot;) + &quot;; see &quot; + &quot;issues&quot;.tag(&quot;a&quot;, { href: &quot;/issues.view&quot; }) + &quot; for further information&quot;;
		},
		badSkin: new Error(&quot;skin contains invalid jade&quot;),
		badDataset: new Error(&quot;dataset does not exist&quot;),
		noCode: new Error(&quot;engine has no code file&quot;),
		badFeature: new Error(&quot;unsupported feature&quot;),
		noOffice: new Error(&quot;office docs not enabled&quot;),
		noExe: new Error(&quot;no execute interface&quot;),
		noContext: new Error(&quot;no engine context&quot;),
		noUsecase: new Error(&quot;no usecase provided to plugin&quot;),
		certFailed: new Error(&quot;could not create pki cert&quot;),
		badEntry: new Error(&quot;sim engines must be accessed at master url&quot;)
	},

	&quot;paths.&quot;: { //&lt; paths to things
		default: &quot;home.view&quot;,

		jaderef: &quot;./public/jade/ref.jade&quot;, // jade reference path for includes, exports, appends

		engine: &quot;SELECT * FROM app.engines WHERE least(?,1) LIMIT 1&quot;,
		render: &quot;./public/jade/&quot;,

		sss: { // some streaming services
			spoof: ENV.DEBUG + &quot;/sss.exe?Name=spoof1&amp;&quot;,
			stats: ENV.DEBUG + &quot;/gaussmix.exe?&quot;,
			gaussmix: ENV.DEBUG + &quot;/gaussmix.exe?&quot;,
			thresher: ENV.SSS_THRESHER
		},

		wfs: { // wfs services
			spoof: ENV.DEBUG + &quot;/wfs.exe?Name=spoof1&amp;&quot;,
			ess: ENV.WFS_ESS,
			dglobe: ENV.WFS_DGLOBE,
			omar: ENV.WFS_OMAR,
			geosrv: ENV.WFS_GEOSRV
		},

		wms: { // wms services
			spoof: ENV.DEBUG + &quot;/wms.exe?Name=spoof1&amp;&quot;,
			ess: ENV.WMS_ESS,
			dglobe: ENV.WMS_DGLOBE,
			omar: ENV.WMS_OMAR,
			geosrv: ENV.WMS_GEOSRV
		},

		mime: {
			tour: &quot;.&quot;, //&lt; enable totem touring 
			//jobs: &quot;./public/jobs&quot;,		//&lt; path to tau simulator job files
			stores: &quot;./public&quot;, //&lt; persistant scrape area
			uploads: &quot;./public&quot;, //&lt; one-time scrape area
			chips: &quot;./public/images&quot;, //&lt; chipped files
			tips: &quot;./public/images&quot;, //&lt; tipped files
			data: &quot;./public&quot;, //&lt; debug data
			jade: &quot;./public&quot;,
			shares: &quot;.&quot;, //&lt; cached file area
			docs: &quot;.&quot;, //&lt; html documents
			socketio: &quot;.&quot;, //&lt; path to socket.io
			clients: &quot;.&quot;, //&lt; path to 3rd party ui clients
			uis: &quot;.&quot;, //&lt; path to debe ui drivers
			//icons: &quot;.&quot;,				//&lt; path to icons
			captcha: &quot;.&quot;,
			index: { //&lt; allowed file indexers
				shares: &quot;indexer&quot;,
				uploads: &quot;indexer&quot;,
				stores: &quot;indexer&quot;,
				tour: &quot;indexer&quot;,
				data: &quot;indexer&quot;
			},
			extensions: { // extend mime types as needed
				rdp: &quot;application/mstsc&quot;,
				run: &quot;text/html&quot;,
				exe: &quot;text/plain&quot;
			}
		},

		skin: {
			org1: &quot;./public/jade/Org1&quot;,
			org2: &quot;./public/jade/Org2&quot;,
			mood1: &quot;./public/jade/Mood1&quot;
		},

		code: {
			py: &quot;./public/py&quot;,
			js: &quot;./public/js&quot;,
			mat: &quot;./public/mat&quot;,
			jade: &quot;./public/jade&quot;,
			html: &quot;./public/htmls&quot;
		}
	},

<span id='DEBE-cfg-probono'>	/**
</span> @cfg {Boolean}
 @member DEBE
 Enable to give-away plugin services
 */
	probono: false, //&lt; enable to run plugins unregulated

	Function: Initialize, //&lt; added to ENUM callback stack

	// Prototypes

	String: [// string prototypes
	/*
 function indentify(tag) {
 	if (tag) 
 		return tag + &quot;\n\t&quot; + this.split(&quot;\n&quot;).join(&quot;\n\t&quot;);
 	else
 		return &quot;\t&quot; + this.split(&quot;\n&quot;).join(&quot;\n\t&quot;);
 },*/

	function renderJade(req, res) {
<span id='DEBE-method-render'>		/**
</span>  @private
  @method render
  Render Jade string this to res( err || html ) in a new context created for this request. 
  **/
		var jade = this + &quot;&quot;;
		siteContext(req, function (ctx) {
			try {
				if (generator = JADE.compile(jade, ctx)) res(generator(ctx));else res(DEBE.errors.badSkin);
			} catch (err) {
				return res(err);
			}
		});
	}, function renderFile(req, res) {
<span id='DEBE-method-render'>		/**
</span>  @private
  @method render
  Render Jade file at path this to res( err || html ) in a new context created for this request.  
  **/
		var file = this + &quot;&quot;;
		siteContext(req, function (ctx) {
			try {
				res(JADE.renderFile(file, ctx)); // js gets confused so force string
			} catch (err) {
				res(err);
			}
		});
	}],

	Array: [// array prototypes
	function getStash(watchKey, targetPrefix, ctx, stash, cb) {
		// this = [ { watchKey:&quot;KEY&quot;, x:X, y: Y, ...}, ... }
		// stash = { targetPrefix: { x: [X,...], y: [Y,...], ... }, ... }

		var rem = stash.remainder;

		this.each(function (n, stat) {
			// split-save all stashable keys
			var key = targetPrefix + stat[watchKey],
			    // target ctx key 
			ev = key in stash ? stash[key] // stash was already primed
			: key in ctx ? // see if its in the ctx
			stash[key] = cb(null, stat, ctx[key]) // prime stash
			: null; // not in ctx so stash in remainder

			if (ev) {
				// found a ctx target key to save results
				delete stat[watchKey];
				cb(ev, stat);
			} else if (rem) // stash remainder 
				rem.push(stat);
		});
	}, function merge(Recs, idx) {
<span id='DEBE-method-merge'>		/**
</span>  @method merge
  Merge changes when doing table deltas from their baseline versions.
  **/

		function changed(rec, Rec) {
			for (var n in rec) {
				if (rec[n] != Rec[n]) return true;
			}return false;
		}

		var recs = this;
		// sort records on specified index
		Recs = Recs.sort(function (a, b) {
			return a[idx] &gt; b[idx] ? 1 : -1;
		});
		recs = recs.sort(function (a, b) {
			return a[idx] &gt; b[idx] ? 1 : -1;
		});

		// merge records based on specified index.
		var k = 0,
		    Rec = Recs[k],
		    ID = 10000;

		if (Rec) recs.each(function (n, rec) {
			//Log([n,k,recs.length, Recs.length, idx, rec[idx], Rec[idx]]);

			while (Rec &amp;&amp; rec[idx] == Rec[idx]) {
				if (changed(rec, Rec)) {
					// return only changed records
					Rec.Baseline = 1;
					Rec.ID = ID++;
					recs.push(Rec);
				}
				Rec = Recs[++k];
			}

			rec.Baseline = 0;
		});

		recs = recs.sort(function (a, b) {
			return a[idx] &gt; b[idx] ? 1 : -1;
		});

		return recs;
	}, function treeify(idx, kids, level, keys, wt) {
<span id='DEBE-method-treeify'>		/**
</span>  @method treeify
  Return a tree = {name,weight,children: tree} from records having been sorted on keys=[key,...]
  */
		var recs = this,
		    key = keys[level],
		    len = 0,
		    pos = idx,
		    end = idx + kids,
		    tar = [];

		//Log([level,keys,ref,idx]);

		if (key) for (var ref = recs[idx][key]; pos &lt; end;) {
			var rec = recs[idx];
			var stop = idx == end ? true : rec[key] != ref;

			if (stop) {
				//Log([pos,idx,end,key,ref,recs.length]);

				var node = {
					name: key + &quot; &quot; + ref,
					weight: wt ? parseInt(rec[wt] || &quot;0&quot;) : len,
					children: recs.treeify(pos, len, level + 1, keys, wt)
				};

				tar.push(node);
				pos = idx;
				len = 0;
				ref = idx == end ? null : recs[idx][key];
			} else {
				idx++;
				len++;
			}
		} else while (pos &lt; end) {
			var rec = recs[pos++];
			tar.push({
				name: &quot;doc&quot;,
				weight: 0,
				doc: rec
			});
		}

		return tar;
	}],

<span id='DEBE-cfg-isSpawned'>	/**
</span> @cfg {Boolean}
 @member DEBE
 Enabled when this is child server spawned by a master server
 */
	isSpawned: false, //&lt; Enabled when this is child server spawned by a master server

	gradeIngest: function gradeIngest(sql, file, cb) {
		//&lt; callback cb(stats) if no errors

		var ctx = {
			Batch: 10, // batch size in steps
			_File: {
				Actors: file.Actors, // ensemble size
				States: file.States, // number of states consumed by process
				Steps: file.Steps // number of time steps
			},
			_Load: sql.format( // event query
			&quot;SELECT * FROM app.events WHERE fileID=? ORDER BY t LIMIT 10000&quot;, [file.ID])
		};

		Log(&quot;ingest stats ctx&quot;, ctx);

		if (estpr = JSLAB.plugins.estpr) estpr(ctx, function (ctx) {
			// estimate/learn hidden process parameters

			if (ctx) {
				var stats = ctx.Save.pop() || {}; // retain last estimate at end
				Log(&quot;ingest stats&quot;, stats);

				cb(stats);
			}
			/*
   cb({
   	coherence_time: stats.coherence_time || 0,
   	coherence_intervals: stats.coherence_intervals || 0,
   	degeneracy_param: stats.degeneracy_param || 0,
   	snr: stats.snr || 0
   	//mean_jump_rate: stats.mean_jump_rate || 0
   });  */
		});
	},

<span id='DEBE-cfg-bySOAP'>	/**
</span> @cfg {Object}
 @member DEBE
 @private
 reserved for soap interfaces
 */
	bySOAP: { //&lt; action:route hash for XML-driven engines
		get: &quot;&quot;,
		put: &quot;&quot;,
		delete: &quot;&quot;,
		post: &quot;/service/algorithm/:proxy&quot; //&lt; hydra endpoint
	}, //&lt; reserved for soap interfaces

	loader: function loader(url, met, req, res) {
		// generic data loader
<span id='DEBE-method-loader'>		/**
</span>  @member DEBE
  @private
  @method loader
  @param {String} url path to source
  @param {String} met method GET/POST/... to use
  @param {Object} req http request
  @param {Function} res Totom response callback
  */
		met(url.tag(&quot;?&quot;, req), res);
	},

	loaders: { // data loading services
		catalog: function catalog(req, res) {
			DEBE.loader(DEBE.paths.wfs.spoof, DEBE.fetchers.http, req, res);
		},
		image: function image(req, res) {
			DEBE.loader(DEBE.paths.wms.spoof, DEBE.fetchers.wget, req, res);
		},
		events: function events(req, res) {
			DEBE.loader(DEBE.paths.sss.spoof, DEBE.fetchers.http, req, res);
		},
		stats: function stats(req, res) {
			DEBE.loader(DEBE.paths.sss.stats, DEBE.fetchers.http, req, res);
		},
		gaussmix: function gaussmix(req, res) {
			DEBE.loader(DEBE.paths.sss.gaussmix, DEBE.fetchers.http, req, res);
		},
		save: {}
	},

	/*
 autoRuns: function (sql, group, aoi, cb) {  // task and run ingestable plugins
 		var
 		ring = aoi.ring;
 	
 	FLEX.taskPlugins( sql, group, function (taskID, pluginName) {
 			cb( pluginName, ring );
 			if (0)
 		FLEX.runPlugin({
 			sql: sql,
 			table: pluginName,
 			query: {ID:taskID}
 		}, function (err, rtn, ctx) {
 		});
 		});
 	
 	/ *
 	var 
 		group = &quot;app&quot;,
 		TL = [aoi.yMax, aoi.xMin],   // [lon,lat] degs
 		TR = [aoi.yMax, aoi.xMax],
 		BL = [aoi.yMin, aoi.xMin],
 		BR = [aoi.yMin, aoi.xMax], 
 		ring = {voiring:[ TL, TR, BR, BL, TL ]};
 		// add this aoi as a usecase to all applicable plugins 
 	sql.eachTable( group, function (table) {  // look for plugins that have a data loader and a Job key
 		var tarkeys = [], srckeys = [], hasJob = false;
 			// if (table == &quot;gaussmix&quot;) // debug filter
 		if ( loader = DEBE.loaders[table] )
 			sql.query(  // get plugin usecase keys
 				&quot;SHOW FIELDS FROM ??.?? WHERE Field != 'ID' &quot;, 
 				[ group, table ], 
 				function (err,keys) {
 					keys.each( function (n,key) { // look for Job key
 					var keyesc = &quot;`&quot; + key.Field + &quot;`&quot;;
 					switch (key.Field) {
 						case &quot;Save&quot;:
 							break;
 						case &quot;Job&quot;:
 							hasJob = true;
 						case &quot;Name&quot;:
 							srckeys.push(&quot;? AS &quot;+keyesc);
 							tarkeys.push(keyesc);
 							break;
 						default:
 							srckeys.push(keyesc);
 							tarkeys.push(keyesc);
 					}
 				});
 					if (hasJob) {
 					Trace( `TASKING AOI ${ring.voiring} TO ${table} PLUGIN` );
 						sql.query( // add usecase to plugin by cloning its Name=&quot;ingest&quot; usecase
 						&quot;INSERT INTO ??.?? (&quot;+tarkeys.join()+&quot;) SELECT &quot;+srckeys.join()+&quot; FROM ??.?? WHERE name='ingest' &quot;, [
 							group, table,
 							&quot;ingest &quot; + new Date(),
 							JSON.stringify(ring),
 							group, table
 					], function (err, info) {
 							if ( !err &amp;&amp; info.insertId )  // relay a fetch request to load the data with the usecase that was just added 
 							loader( {ID:info.insertId}, function (rtn) {
 								Trace(`AUTORUN ${table}`);  // rtn = json parsed or null
 							});
 					});
 				}
 			});
 	});
 	* /
 },
 */

	ingestFile: function ingestFile(sql, filePath, fileName, fileID, cb) {
		// ingest events from file with callback cb(aoi).

		//var trace = &quot;INGEST&quot;;

		Log(&quot;ingest file&quot;, filePath, fileName, fileID);

		HACK.ingestFile(sql, filePath, fileID, function (aoi) {

			Log(&quot;ingest aoi&quot;, aoi);
			var ctx = {
				Job: JSON.stringify({
					file: fileName, limit: 1000, aoi: [[0, 0], [0, 0], [0, 0], [0, 0], [0, 0]]
				}),
				Name: &quot;ingest.&quot; + fileName,
				Description: &quot;see &quot; + fileName.tag(&quot;a&quot;, { href: &quot;/files.view?ID=&quot; + fileID }) + &quot; for details&quot;
			};

			if (false) // add use case to ingested file in all listening plugins
				FLEX.eachPlugin(sql, &quot;app&quot;, function (eng) {
					sql.query(&quot;INSERT INTO ??.?? SET ? ON DUPLICATE KEY UPDATE ?&quot;, [group, eng.Name, ctx, { Description: ctx.Description }], function (err, info) {
						if (false) FLEX.runPlugin({ // run the plugin
							sql: sql,
							table: eng.Name,
							group: group,
							client: client,
							query: { ID: info.insertId }
						}, function (ctx) {
							Log(&quot;TASKED &quot;, eng.Name, err || rtn);
						});
					});
				});
		});
	},

<span id='DEBE-cfg-blindTesting'>	/**
</span> @cfg {Boolean}
 @member DEBE
 Enable for double-blind testing 
 */
	blindTesting: false //&lt; Enable for double-blind testing (eg make FLEX susceptible to sql injection attacks)
});

<span id='DEBE-method-SOAPsession'>/**
</span> * @method SOAPsession
 * @private
 * Process an bySOAP session peer-to-peer request.  Currently customized for Hydra-peer and 
 * could/should be revised to support more generic peer-to-peer bySOAP interfaces.
 * 
 * @param {Object} req HTTP request
 * @param {Object} res HTTP response
 * @param {Function} proxy Name of APP proxy function to handle this session.
 * */
/*
function SOAPsession(req,res,peer,action) {
	Thread( function (sql) {
		req.addListener(&quot;data&quot;, function (data) {
			XML2JS.parseString(data.toString(), function (err,json) {  // hydra specific parse

				hydrareq = false
					? json[&quot;soapenv:Envelope&quot;][&quot;soapenv:Body&quot;][0][&quot;swag:SWAGRequest&quot;][0]	// hydra soapui request
					: json[&quot;soap:Envelope&quot;][&quot;soap:Body&quot;][0][&quot;SWAGRequest&quot;][0];				// hydra peer request

				for (var n in hydrareq)
					switch (n) {
						case &quot;xmls&quot;:
						case &quot;$&quot;:
						case &quot;inFileName&quot;:
						case &quot;outFileName&quot;:
						case &quot;feature&quot;:
							ENV[n.toUpperCase()] = hydrareq[n][0];
							break;

						default:
							ENV[n.toUpperCase()] = parseFloat(hydrareq[n][0]);
					}
				
				var VTL = (APP[action]||{})[peer];
				
				Trace(action.toUpperCase() + peer + (VTL ? &quot;LOCATED&quot; : &quot;MISSING&quot;));
				
				if (VTL) 
					VTL(req, function (msg) {
						Trace(&quot;PEER &quot; + peer + &quot;:&quot; + msg);
					});
					
			});
		});
		
		res.statusCode = 200;
		sql.reply(res,&quot;0&quot;);
	});
}
*/

function icoFavicon(req, res) {
	// extjs trap
	res(&quot;No icons here&quot;);
};

<span id='MAINT'>/**
</span>@class MAINT service maintenance endpoints
*/

/*
function sysAgent(req,res) {
	var 
		query = req.query,
		cb = ATOM.mw.cb[query.job];
	
	Log(&quot;AGENT&quot;, query);
	cb(0);
}
*/

function sysConfig(req, res) {
<span id='MAINT-method-sysConfig'>	/**
</span> @method sysConfig
 @deprecated
 @param {Object} req Totem request
 @param {Function} res Totem response
 */
	function Guard(query, def) {
		for (var n in query) {
			return query;
		}return def;
	}

	var query = Guard(req.query, false);

	if (query) req.sql.query(&quot;UPDATE config SET ?&quot;, query, function (err) {
		res(err || &quot;parameter set&quot;);
	});
}

function sysCheckpt(req, res) {
	/*
 @method sysCheckpt
 @deprecated
 @param {Object} req Totem request
 @param {Function} res Totem response
 */
	CP.exec('source maint.sh checkpoint &quot;checkpoint&quot;');
	res(&quot;Checkpointing database&quot;);
}

function sysStart(req, res) {
	/*
 @method sysStart
 @deprecated
 @param {Object} req Totem request
 @param {Function} res Totem response
 */
	req.sql.query(&quot;select * from openv.apps where least(?)&quot;, { Enabled: true, Name: req.query.name || &quot;node0&quot; }).on(&quot;result&quot;, function (app) {
		if (false) CP.exec(&quot;node $EXAPP/sigma --start &quot; + app.Name, function (err, stdout, stderr) {
			if (err) console.warn(err);
		});else process.exit();
	}).on(&quot;end&quot;, function () {
		res(&quot;restarting service&quot;);
	});
}

function sysBIT(req, res) {
<span id='MAINT-method-sysBIT'>	/**
</span> @method sysBIT
 Totem(req,res) endpoint for builtin testing
 @param {Object} req Totem request
 @param {Function} res Totem response
 */
	var N = req.query.N || 20;
	var lambda = req.query.lambda || 2;

	var actions = [&quot;insert&quot;, &quot;update&quot;, &quot;delete&quot;],
	    tables = [&quot;test1&quot;, &quot;test2&quot;, &quot;test3&quot;, &quot;test4&quot;, &quot;test5&quot;],
	    users = [&quot;simuser1&quot;, &quot;simuser2&quot;, &quot;simuser3&quot;, &quot;simuser4&quot;, &quot;simuser5&quot;],
	    f1 = [&quot;sim1&quot;, &quot;sim2&quot;, &quot;sim3&quot;, &quot;sim4&quot;, &quot;sim5&quot;, &quot;sim6&quot;, &quot;sim7&quot;, &quot;sim&quot;, &quot;sim9&quot;, &quot;sim10&quot;, &quot;sim11&quot;, &quot;sim12&quot;, &quot;sim13&quot;],
	    f2 = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;, &quot;h&quot;],
	    f3 = [0, 1, 2, 3, 4, 5, 6, 7,, 9, 10];

	var t0 = 0;

	// Notify startup

	//Trace(`BIT ${N} events at ${lambda} events/s with logstamp ${stamp}`);

	res(&quot;BIT running&quot;);

	// Setup sync for server blocking and notify both sides

	FLEX.BIT = new SYNC(N, {}, function () {
		FLEX.BIT = null;
		Trace(&quot;BIT completed&quot;);
	});

	//DEBE.LOGSTAMP = Stamp;

	// Poisson load model.

	for (var n = 0; n &lt; N; n++) {
		var t = -1e3 * Math.log(Math.random()) / lambda; // [ms] when lambda [1/s]

		t0 += t;

		var taskID = setTimeout(function (args) {
			req.body = clone(args.parms);
			req.query = args.action == &quot;insert&quot; ? {} : { f1: args.parms.f1 };
			req.ses.source = &quot;testdb.&quot; + args.table;
			req.ses.action = args.action;

			FLEX.open(req, res); // need cb?			
		}, t0, { parms: { f1: f1.rand(), f2: f2.rand(), f3: f3.rand() },
			table: tables.rand(),
			action: actions.rand(),
			client: users.rand()
		});
	}
}

function sysPing(req, res) {
<span id='MAINT-method-sysPing'>	/**
</span> @method sysPing
 Totem(req,res) endpoint to test client connection
 @param {Object} req Totem request
 @param {Function} res Totem response
 */
	res(&quot;hello &quot; + req.client);
}

function sysCodes(req, res) {
<span id='MAINT-method-sysCodes'>	/**
</span> @method sysCodes
 @deprecated
 Totem(req,res) endpoint to return html code for testing connection
 @param {Object} req Totem request
 @param {Function} res Totem response
 */
	res(HTTP.STATUS_CODES);
}

function sysAlert(req, res) {
<span id='MAINT-method-sysAlert'>	/**
</span> @method sysAlert
 Totem(req,res) endpoint to send notice to all clients
 @param {Object} req Totem request
 @param {Function} res Totem response
 */
	if (IO = DEBE.IO) IO.sockets.emit(&quot;alert&quot;, { msg: req.query.msg || &quot;system alert&quot;, to: &quot;all&quot;, from: DEBE.site.title });

	res(&quot;Broadcasting alert&quot;);
}

function sysKill(req, res) {
	/*
 @method sysKill
 @deprecated
 @param {Object} req Totem request
 @param {Function} res Totem response
 */
	var killed = [];

	res(&quot;Killing jobs&quot;);

	req.sql.query(&quot;SELECT * FROM app.queues WHERE pid AND LEAST(?,1)&quot;, req.query).on(&quot;result&quot;, function (job) {
		req.sql.query(&quot;UPDATE queues SET ? WHERE ?&quot;, [{
			Notes: &quot;Stopped&quot;,
			pid: 0,
			Departed: new Date() }, { ID: job.ID }]);

		CP.exec(&quot;kill &quot; + job.pid);
	});
}

function sysStop(req, res) {
<span id='MAINT-method-sysStop'>	/**
</span> @method sysStop
 Totem(req,res) endpoint to send emergency message to all clients then halt totem
 @param {Object} req Totem request
 @param {Function} res Totem response
 */
	if (IO = DEBE.IO) IO.sockets.emit(&quot;alert&quot;, { msg: req.query.msg || &quot;system halted&quot;, to: &quot;all&quot;, from: DEBE.site.title });

	res(&quot;Server stopped&quot;);
	process.exit();
}

function sysHelp(req, res) {
<span id='MAINT-method-sysHelp'>	/**
</span> @method sysHelp
 Totem(req,res) endpoint to return all sys endpoints
 @param {Object} req Totem request
 @param {Function} res Totem response
 */
	res(&quot;/ping.sys check client-server connectivity&lt;br&gt;&quot; + &quot;/bit.sys built-in test with &amp;N client connections at rate &amp;lambda=events/s&lt;br&gt;&quot; + &quot;/codes.sys returns http error codes&lt;br&gt;&quot; + &quot;/alert.sys broadcast alert &amp;msg to all clients&lt;br&gt;&quot; + &quot;/stop.sys stops server with client alert &amp;msg&lt;br&gt;&quot;);
}

<span id='ATTRIB'>/**
</span>@class ATTRIB get and send dataset attributes
*/

function sendCode(req, res) {
	// return file contents tagged as code
<span id='ATTRIB-method-sendCode'>	/**
</span> @method sendCode
 Totem(req,res) endpoint to send engine code requested by (.name, .type) 
 @param {Object} req Totem request
 @param {Function} res Totem response
 */

	var paths = DEBE.paths;

	FS.readFile((paths.code[req.type] || paths.code.default) + req.name, &quot;utf-8&quot;, function (err, code) {

		if (err) res(DEBE.errors.noCode);else res(code.tag(&quot;code&quot;, { class: req.type }).tag(&quot;pre&quot;));
	});
}

function sendCert(req, res) {
	// create/return public-private certs

	var owner = req.table,
	    pass = req.type;

	DEBE.prime(owner, pass, {}, function () {

		CP.exec(&quot;puttygen &quot; + owner + &quot;.key -N &quot; + pass + &quot; -o &quot; + owner + &quot;.ppk&quot;, function (err) {

			if (err) res(DEBE.errors.certFailed);else {

				var master = site.urls.master,
				    paths = DEBE.paths,
				    site = DEBE.site,
				    FF = &quot;Firefox&quot;.tag(&quot;a&quot;, { href: master + &quot;/shares.firefox.zip&quot; }),
				    Putty = &quot;Putty&quot;.tag(&quot;a&quot;, { href: master + &quot;/shares.putty.zip&quot; }),
				    Cert = &quot;Cert&quot;.tag(&quot;a&quot;, { href: master + &quot;/cert/&quot; + owner });

				res(function () {
					return {
						area: &quot;&quot;,
						name: owner + &quot;.ppk&quot;
					};
				});

				APP.sendMail({
					from: DEBE.site.ASP,
					to: DEBE.site.ISP,
					cc: name,
					subject: DEBE.site.Nick + &quot; account request&quot;,
					html: (&quot;Greetings from &quot; + site.Nick.tag(&quot;a&quot;, { href: master }) + &quot;-\n\nPlease create an AWS EC2 account for &quot; + owner + &quot; using attached cert.\n\nTo connect to &quot; + site.Nick + &quot; from Windows:\n\n1. establish gateway &quot; + Putty + &quot; | SSH | Tunnels | (SourcePort, Destination):\n\t\n\t5001, &quot; + site.Host + &quot;:22\n\t5100, &quot; + site.Host + &quot;:3389\n\t5200, &quot; + site.Host + &quot;:8080\n\t5910, &quot; + site.Host + &quot;:5910\n\t5555, Dynamic\n\n2. setup &quot; + Putty + &quot; interface:\n\t\n\tPageant | Add Keys | your private ppk cert\n\n3. start a &quot; + site.Nick + &quot; session using one of these methods:\n\n\t&quot; + Putty + &quot; | Session | Host Name = localhost:5001 \n\tRemote Desktop Connect| Computer = localhost:5100 \n\t&quot; + FF + &quot; | Options | Network | Settings | Manual Proxy | Socks Host = localhost, Port = 5555, Socks = v5\n&quot;).replace(/\n/g, &quot;&lt;br&gt;&quot;),

					attachments: [{
						fileName: Cert,
						path: paths.certs + name + &quot;.pub&quot;
					}],
					alternatives: [{
						contentType: 'text/html; charset=&quot;ISO-59-1&quot;',
						contents: &quot;&quot;
					}]
				});
			}
		});
	});
}

function sendAttr(req, res) {
	// send file attribute
<span id='ATTRIB-method-sendAttr'>	/**
</span> @method sendAttr
 Totem(req,res) endpoint to send the .area attribute of a .table file 
 @param {Object} req Totem request
 @param {Function} res Totem response
 */

	var attr = req.area,
	    table = req.table,
	    sql = req.sql;

	sql.query(&quot;SELECT *,count(ID) AS count FROM app.files WHERE least(?) LIMIT 0,1&quot;, { Area: area, Name: table }).on(&quot;result&quot;, function (file) {
		res((&quot;body {background-color:red;}&quot;.tag(&quot;style&quot;) + (file[attr] || &quot;?&quot;).tag(&quot;body&quot;)).tag(&quot;html&quot;));
	});
}

<span id='PLUGIN'>/**
</span>@class PLUGIN support for dataset-engine plugins
*/

function extendPlugin(req, res) {
<span id='PLUGIN-method-extendPlugin'>	/**
</span> @private
 @method extendPlugin
 @param {Object} req http request
 @param {Function} res Totem response callback
 */

	var sql = req.sql,
	    ds = req.table,
	    query = req.query;

	res(&quot;ok&quot;);

	Each(query, function (key, val) {
		var type = &quot;varchar(32)&quot;;

		if (parseFloat(val)) type = &quot;float&quot;;else if (parseInt(val)) type = &quot;int(11)&quot;;else try {
			var val = JSON.parse(val);
			type = val === true || val === false ? &quot;boolean&quot; : &quot;json&quot;;
		} catch (err) {
			type = val == &quot;doc&quot; ? &quot;mediumtext&quot; : &quot;varchar(&quot; + val.length + &quot;)&quot;;
		}

		sql.query(&quot;ALTER TABLE ??.?? ADD ?? &quot; + type, [req.group, ds, key]);
	});
}

function retractPlugin(req, res) {
<span id='PLUGIN-method-retractPlugin'>	/**
</span> @private
 @method retractPlugin
 @param {Object} req http request
 @param {Function} res Totem response callback
 */

	var sql = req.sql,
	    ds = req.table,
	    query = req.query;

	res(&quot;ok&quot;);

	Each(query, function (key, val) {

		sql.query(&quot;ALTER TABLE ??.?? DROP ?? &quot;, [req.group, ds, key]);
	});
}

function exeEngine(req, res) {
<span id='PLUGIN-method-exeEngine'>	/**
</span> @private
 @method exeEngine
 Interface to execute a dataset-engine plugin with a specified usecase as defined in [api](/api.view).
 @param {Object} req http request
 @param {Function} res Totem response callback
 */

	function saveResults(stats, ctx) {
		// save stats to the Save/Save_KEY keys, an Export file, or the Ingest db
		var status = &quot;&quot;,
		    // returned status
		stash = {}; // ingestable keys stash

		if (!stats) return &quot;empty&quot;;else if (stats.constructor == Error) return stats + &quot;&quot;;else if (stats.constructor == Array) {
			// keys in the plugin context are used to create save stashes
			var rem = [],
			    stash = { remainder: rem }; // stash for saveable keys 
			stats.getStash(&quot;at&quot;, &quot;Save_&quot;, ctx, stash, function (ev, stat) {
				// add {at:&quot;KEY&quot;,...} stats to the Save_KEY stash

				if (ev) for (var key in stat) {
					ev[key].push(stat[key]);
				} else {
					var ev = new Object();
					for (var key in stat) {
						ev[key] = [];
					}return ev;
				}
			});

			if (rem.length) {
				// there is a remainder to save
				if (&quot;Save&quot; in ctx) {
					// dump to Save key
					sql.query(&quot;UPDATE ??.?? SET ? WHERE ?&quot;, [group, table, { Save: JSON.stringify(rem) }, { ID: ctx.ID }]);
					status += &quot; Saved&quot;;
				}

				if (ctx.Export) {
					// export to ./public/stores/FILENAME
					var evidx = 0,
					    evs = rem,
					    // point event source to remainder
					srcStream = new STREAM.Readable({ // establish source stream for export pipe
						objectMode: false,
						read: function read() {
							// read event source
							if (ev = evs[evidx++]) // still have an event
								this.push(JSON.stringify(ev) + &quot;\n&quot;);else // signal events exhausted
								this.push(null);
						}
					});

					DEBE.uploader(srcStream, client, &quot;stores/&quot; + table + &quot;.&quot; + ctx.Name + &quot;.&quot; + group + &quot;.&quot; + client);
					/*
     getFile( sql, function (fileID) {  // allocate a file for this export
     	var 
     		evidx = 0,
     		evs = rem,  // point event source to remainder
     		notes = &quot;. Please visit &quot; + &quot;here&quot;.tag(&quot;a&quot;,&quot;/files.view&quot;) + &quot; to manage your holdings.&quot;,
     		filePath = ENV.PUBLIC+&quot;/stores/&quot;+group+&quot;.&quot;+table+&quot;.&quot;+ctx.Name+&quot;.&quot;+client,
     		srcStream = new STREAM.Readable({    // establish source stream for export pipe
     			objectMode: false,
     			read: function () {  // read event source
     				if ( ev = evs[evidx++] )  // still have an event
     					this.push( JSON.stringify(ev)+&quot;\n&quot; );
     				else 		// signal events exhausted
     					this.push( null );
     			}
     		}),
     		sinkStream = FS.createWriteStream( filePath, &quot;utf8&quot;)
     			.on(&quot;finish&quot;, function() {  // establish sink stream for export pipe
     				//Trace(&quot;EXPORTED &quot;+filePath);
     				sql.query(&quot;UPDATE apps.files SET ? WHERE ?&quot;, {
     					Notes: &quot;Exported on &quot; + new Date() + notes
     				}, {ID: fileID} );
     			})
     			.on(&quot;error&quot;, function (err) {
     				Log(&quot;Ingest File Error&quot;, err);
     				sql.query(&quot;UPDATE app.files SET ? WHERE ?&quot;, {
     					Notes: &quot;Export failed: &quot; + err + notes
     				}, {ID: fileID} );
     			});
     		srcStream.pipe(sinkStream);  // start pipe to export events
     });
     */
					status += &quot; Exported&quot;;
				}

				if (ctx.Ingest) {
					DEBE.uploader(null, client, &quot;ingest/&quot; + table + &quot;.&quot; + ctx.Name, function (fileID) {
						HACK.ingestList(sql, rem, fileID, function (aoi, evs) {
							Log(&quot;INGESTED &quot;, aoi);
						});
					});
					status += &quot; Ingested&quot;;
				}
			}

			delete stash.remainder;
		} else {
			// keys in the plugin context are used to create the stash
			var stash = {};
			Each(stats, function (key, val) {
				// remove splits from bulk save
				if (key in ctx) stash[key] = val;
			});
		}

		for (var key in stash) {
			stash[key] = JSON.stringify(stash[key]);
		}if (!Each(stash)) {
			// split save stats across shared keys
			sql.query(&quot;UPDATE ??.?? SET ? WHERE ?&quot;, [group, table, stash, { ID: ctx.ID }]);
			status += &quot; Saved&quot;;
		}

		return ctx.Share ? stats : status.tag(&quot;a&quot;, { href: &quot;/files.view&quot; });
	}

	var dot = &quot;.&quot;,
	    sql = req.sql,
	    client = req.client,
	    group = req.group,
	    table = req.table,
	    query = req.query;

	if (&quot;ID&quot; in query || &quot;Name&quot; in query) FLEX.runPlugin(req, function (ctx) {
		// run engine using requested usecase via the job regulator 

		//Log(&quot;run ctx&quot;, ctx);

		if (!ctx) res(DEBE.errors.noContext);else if (ctx.constructor == Error) res(ctx);else if (Job = ctx.Job) {
			// Intercept job request to run engine via regulator
			res(&quot;Regulating&quot;);

			HACK.chipEvents(req, Job, function (job) {
				// create job for these Job parameters

				req.query = Copy({ // engine request query gets copied to its context
					_Host: job.class,
					_File: job.File,
					_Voxel: job.Voxel,
					_Collects: job.Collects,
					_Flux: job.Flux,
					_Load: job.Load || &quot;&quot;,
					_Dump: job.Dump || &quot;&quot;
				}, ctx);

				ATOM.select(req, function (ctx) {
					// run plugin's engine
					if (ctx) {
						if (&quot;Save&quot; in ctx) saveResults(Array.from(ctx.Save || []), ctx);
					} else Log(&quot;REG &quot; + job.name + &quot; HALTED&quot;);
				});
			});
		} else if (&quot;Save&quot; in ctx) res(saveResults(Array.from(ctx.Save || []), ctx));else res(&quot;ok&quot;);
	});else if (DEBE.probono) // run engine using its query usecase w/o submitting a job
		ATOM.select(req, res);else res(DEBE.errors.noUsecase);
}

function renderSkin(req, res) {
<span id='DEBE-method-renderSkin'>	/**
</span> @method renderSkin
 @member DEBE
 Totem(req,res) endpoint to render jade code requested by .table jade engine. 
 @param {Object} req Totem request
 @param {Function} res Totem response
 */

	var sql = req.sql,
	    paths = DEBE.paths,
	    site = DEBE.site,
	    ctx = site.context[req.table];

	function dsContext(sql, ctx, cb) {
		// callbacl cb() after loading datasets required for this skin

		if (ctx) // render in extended context
			sql.context(ctx, function (ctx) {
				// establish a sql dsvar context

				var isEmpty = Each(ctx, function (ds, x, isLast) {
					x.args = { ds: ds }; // hold ds name for use after select
					x.rec = function clone(recs, me) {
						// select and clone the records 
						site[me.args.ds] = recs; // save data into the context
						if (isLast) cb(); // all ds loaded so can render with cb
					};
				});

				if (isEmpty) cb();
			});else // render in default site context
			cb();
	}

	dsContext(sql, ctx, function () {

		function renderPlugin(fields) {
			// render using plugin skin

			function acceptable(field) {
				var _types;

				var types = (_types = {
					&quot;?&quot;: &quot;t&quot;,
					&quot;varchar(32)&quot;: &quot;t&quot;,
					&quot;varchar(64)&quot;: &quot;t&quot;,
					&quot;varchar(128)&quot;: &quot;t&quot;,
					&quot;int(11)&quot;: &quot;i&quot;,
					float: &quot;n&quot;,
					json: &quot;x&quot;,
					mediumtext: &quot;h&quot;
				}, _defineProperty(_types, &quot;json&quot;, &quot;x&quot;), _defineProperty(_types, &quot;date&quot;, &quot;d&quot;), _defineProperty(_types, &quot;datetime&quot;, &quot;d&quot;), _defineProperty(_types, &quot;tinyint(1)&quot;, &quot;c&quot;), _types);

				return field.Field != &quot;ID&quot; &amp;&amp; field.Type != &quot;geometry&quot; ? field.Field + &quot;.&quot; + (types[field.Type] || &quot;t&quot;) : null;
			}

			var pluginPath = paths.render + &quot;plugin.jade&quot;,
			    cols = [],
			    query = req.query,
			    sql = req.sql,
			    query = Copy({
				mode: req.parts[1],
				search: req.search,
				cols: cols,
				page: query.page,
				dims: query.dims || &quot;100%,100%&quot;,
				ds: req.table
			}, req.query),
			    ctx = site.context.plugin;

			//Log([query, req.search]);

			switch (fields.constructor) {
				case Array:
					fields.each(function (n, field) {
						if (col = acceptable(field)) cols.push(col);
					});
					break;

				case String:
					fields.split(&quot;,&quot;).each(function (n, field) {
						if (col = acceptable({ Field: field, Type: &quot;?&quot; })) cols.push(col);
					});
					break;

				case Object:
				default:

					try {
						Each(fields, function (n, rec) {
							if (col = acceptable({ Field: n, Type: &quot;?&quot; })) cols.push(n);
						});
					} catch (err) {}
			}

			/*if ( query.mode == &quot;gbrief&quot; ) // better to add this to site.context.plugin
   	sql.query(&quot;SELECT * FROM ??.??&quot;, [req.group, query.ds], function (err,recs) {
   		if (err)
   			res( DEBE.errors.badSkin );
   		
   		else {
   			recs.each( function (n,rec) {
   				delete rec.ID;
   			});
   				query.data = recs;
   			pluginPath.render(req, res);
   		}
   	});
   	else	*/

			dsContext(sql, ctx, function () {
				// render plugin in its plugin context
				pluginPath.renderFile(req, res);
			});
		}

		function renderTable() {
			sql.query(&quot;DESCRIBE ??.??&quot;, [FLEX.dbRoutes[req.table] || req.group, req.table], function (err, fields) {

				if (err) // might be a file
					(paths.render + req.table + &quot;.jade&quot;).renderFile(req, res);else renderPlugin(fields);
			});
		}

		sql.getFirst(&quot;&quot;, paths.engine, { // Try a jade engine
			Name: req.table,
			Type: &quot;jade&quot;,
			Enabled: 1
		}, function (eng) {

			if (eng) // render view with this jade engine
				dsContext(sql, ctx, function () {
					eng.Code.renderJade(req, res);
				});else // try to get engine from sql table or from disk
				if (route = DEBE.byActionTable.select[req.table]) // try virtual table
					route(req, function (recs) {
						renderPlugin(recs[0] || {});
					});else if (route = DEBE.byAction.select) // may have an engine interface
					route(req, function (recs) {
						//Log({eng:recs, ds:req.table});
						if (recs) renderPlugin(recs[0] || {});else renderTable();
					});else // try sql table
					renderTable();
		});
	});
}

function genDoc(recs, req, res) {
<span id='DEBE-method-genDoc'>	/**
</span> @method genDoc
 @member DEBE
 Convert recods to requested req.type office file.
 @param {Array} recs list of records to be converted
 @param {Object} req Totem request
 @param {Function} res Totem response
 */

	if (!ODOC) return res(DEBE.errors.noOffice);

	var types = {
		xdoc: &quot;docx&quot;,
		xxls: &quot;xlsx&quot;,
		xppt: &quot;pptx&quot;,
		xpps: &quot;ppsx&quot;
	},
	    type = types[req.type],
	    docf = &quot;./shares/&quot; + req.table + &quot;.&quot; + type;

	if (type) docx = ODOC({
		type: type
		//onend: function (writeBytes) { 	}
	});else res(DEBE.errors.badOffice);

	var docs = FS.createWriteStream(docf);

	docx.generate(docs);
	docs.on(&quot;close&quot;, function () {
		Trace(&quot;CREATED &quot; + docf);
	});

	if (false) {
		// debugging
		var docp = docx.createP();
		docp.addText(&quot;hello there&quot;);

		docp.addTest(&quot;\nview || edit\n\n1.2 All my users\n\nID\tClient\tLikeus\tUpdated\tBanned\tLiked\tJoined\tSnapInterval\tSnapCount\tCharge\tCredit\tQoS\tTrusted\tCaptcha\tLogin\tEmail\tChallenge\tisHawk\tRequested\tApproved\tGroup\tuid\tgid\tUser\tJournal\tMessage\tIDs\tAdmin\tRepoll\tTimeout\tRoles\tStrength\n34\tbrian.james@guest.org\t0\tMon May 04 2015 05:52:50 GMT-0400 (EDT)\t\t1\tMon Sep 28 2015 20:51:50 GMT-0400 (EDT)\tnull\tnull\tnull\t0\t0\t0\t0\tnull\tnull\t0\t1\tnull\tnull\tapp\tnull\tnull\tbrian.james@guest.org\tnull\tnull\t{\&quot;Login\&quot;:\&quot;me\&quot;,\&quot;Password\&quot;:\&quot;test\&quot;,\&quot;FavColor\&quot;:\&quot;blue\&quot;}\tPlease contact joeschome to unlock your accout\t0\t30000\tPM,R,X\t1\n\nTotem\n\t\n\n{\&quot;a\&quot;:[{\&quot;ID\&quot;:0,\&quot;SORN\&quot;:\&quot;TBD\&quot;,\&quot;SPID\&quot;:\&quot;TBD\&quot;}],\&quot;b\&quot;:[{\&quot;ID\&quot;:1,\&quot;NISTid\&quot;:\&quot;TBD\&quot;,\&quot;NISTtype\&quot;:\&quot;a1\&quot;},{\&quot;ID\&quot;:2,\&quot;NISTid\&quot;:\&quot;TBD\&quot;,\&quot;NISTtype\&quot;:\&quot;TBD\&quot;},{\&quot;ID\&quot;:3,\&quot;NISTtype\&quot;:\&quot;a2\&quot;}]}\n\t\n\nTBD\n\n1.1 SCOPE AND APPLICABILITY\n\nThis document applies to all NGA owned, controlled, outsourced, blah blah\n\n2. INFORMATION SYSTEM CATEGORIZATION\n\n2.1 INFORMATION TYPES\nChapter 1\n\nThe Lorenz Equations x2=0\n\nx\u02D9y\u02D9z\u02D9=\u03C3(y\u2212x)=\u03C1x\u2212y\u2212xz=\u2212\u03B2z+xy\n\nImpressive 'eh\n\nJ\u03B1(x)=\u2211m=0\u221E(\u22121)mm!\u0393(m+\u03B1+1)(x2)2m+\u03B1\nChapter 2\n&quot;);
	}

	var cols = [];
	var rows = [cols];

	recs.each(function (n, rec) {
		if (n == 0) for (var key in rec) {
			rows.push({
				val: key,
				opts: {
					cellColWidth: 4261,
					b: true,
					sz: &quot;48&quot;,
					shd: {
						fille: &quot;7F7F7F&quot;,
						themeFill: &quot;text1&quot;,
						themeFillTint: &quot;80&quot;
					},
					fontFamily: &quot;Avenir Book&quot;
				}
			});
		}var row = new Array();

		rows.push(row);
		for (var key in rec) {
			row.push(rec[key]);
		}
	});

	if (false) docx.createTable(rows, {
		tableColWidth: 4261,
		tableSize: 24,
		tableColor: &quot;ada&quot;,
		tableAlign: &quot;left&quot;,
		tableFontFamily: &quot;Comic Sans MS&quot;,
		borders: true
	});

	res(&quot;Claim file &quot; + &quot;here&quot;.link(docf));
}

function Initialize() {
<span id='DEBE-method-Initialize'>	/**
</span> @method Initialize
 @member DEBE
 Initialize DEBE on startup.
 */

	function initSES(cb) {
<span id='DEBE-method-initSES'>		/**
</span>   * @method initSES
   * @private
   * @member DEBE
   * Initialize the session environment
   */

		Trace(&quot;INIT SESSIONS&quot;);

		/*
  Each( CRUDE, function (n,routes) { // Map engine CRUD to DEBE workers
  	DEBE.byTable[n] = ATOM[n];
  });	
  */

		/*
  The i18n simply provides an industry standard framework for translating native -&gt; foreign
  phrases (defined my pot-&gt;po files under XLATE folder).  These pot-&gt;po translations are 
  not free.  Wordpress, for example, provides a service that allows websites to register
  for their services that crowd source translations from supplied pot files to their
  delivered po files.
  */

		if (path = DEBE.paths.mime.xlate) EXAPP.use(LANG.abide({
			supported_languages: ['en', 'de', 'fr'],
			default_lang: 'en',
			translation_directory: path,
			translation_type: &quot;json&quot;
			//locale_on_url: true
		}));

		if (cb) cb();
	}

	function initENV(cb) {
<span id='DEBE-method-initENV'>		/**
</span>   * @method initENV
   * @private
   * @member DEBE
   * Initialize the runtime environment
   */

		Trace(&quot;INIT ENVIRONMENT&quot;);

		var site = DEBE.site,
		    args = ARGP.usage(&quot;$0 [options]&quot;).default('spawn', DEBE.isSpawned).boolean('spawn').describe('spawn', 'internal hyper-threading option').check(function (argv) {
			DEBE.isSpawned = argv.spawn;
		}).default('blind', DEBE.blindTesting).boolean('blind').describe('blind', 'internal testing flag').check(function (argv) {
			DEBE.blindTesting = argv.blind;
		}).default('dump', false).boolean('dump').describe('dump', 'display derived site parameters').check(function (argv) {
			//Log(site);
		})

		/*
  .default('start',DEBE.site.Name)
  .describe('start','service to start')  
  .check(function (argv) {
  	DEBE.site.Name = argv.start;
  })
  * */

		.boolean('version').describe('version', 'display current version').check(function (argv) {
			if (argv.version) Trace(DEBE.site);
		})

		/*
  .default('echo',DEBE.FLAGS.DEBUG)
  .boolean('echo')
  .describe('echo','echo adjusted http request parameters')
  .check(function(argv) {
  	DEBE.FLAGS.DEBUG = argv.echo;
  })*/

		.boolean('help').describe('help', 'display usage help').check(function (argv) {
			if (argv.help) {
				Trace(ARGP.help());

				Trace(&quot;Available services:&quot;);
				sql.query(&quot;SELECT * FROM openv.apps WHERE ?&quot;, { Enabled: 1 }).on(&quot;result&quot;, function (app) {
					Trace(app.Name + &quot; v&quot; + app.Ver + &quot; url=&quot; + app.Host + &quot;:&quot; + app.Port + &quot; db=&quot; + app.DB + &quot; nick=&quot; + app.Nick + &quot; sockted=&quot; + (app.Sockets ? &quot;yes&quot; : &quot;no&quot;) + &quot; cores=&quot; + app.Cores + &quot; pki=&quot; + app.PKI);
				}).on(&quot;error&quot;, function (err) {
					Trace(err);
				}).on(&quot;end&quot;, function () {
					process.exit();
				});
			}
		}).argv;

		Trace(&quot;HOST &quot; + site.title + &quot; ON &quot; + (CLUSTER.isMaster ? &quot;MASTER&quot; : &quot;CORE&quot; + CLUSTER.worker.id) + &quot;\n- USING &quot; + site.db + &quot;\n- FROM &quot; + process.cwd() + &quot;\n- RUNNING &quot; + (DEBE.nofaults ? &quot;PROTECTED&quot; : &quot;UNPROTECTED&quot;) + &quot;\n- WITH &quot; + (site.urls.socketio || &quot;NO&quot;) + &quot; SOCKETS&quot; + &quot;\n- WITH &quot; + (DEBE.SESSIONS || &quot;UNLIMITED&quot;) + &quot; CONNECTIONS&quot; + &quot;\n- WITH &quot; + (DEBE.cores || &quot;NO&quot;) + &quot; WORKERS@ &quot; + site.urls.worker + &quot; MASTER@ &quot; + site.urls.master);

		if (cb) cb();
	}

	function initSQL(cb) {
<span id='DEBE-method-initSQL'>		/**
</span>   * @method initSQL
   * @private
   * @member DEBE
   * Initialize the FLEX and ATOM interfaces
   */

		Trace(&quot;INIT FLEX&quot;);

		Each(CRUDE, function (n, routes) {
			// redirect dataset crude calls
			DEBE[n] = FLEX[n].ds;
			DEBE.byActionTable[n] = FLEX[n];
		});

		FLEX.config({
			thread: sqlThread,
			emitter: DEBE.IO ? DEBE.IO.sockets.emit : null,
			skinner: JADE,
			fetchers: DEBE.fetchers,
			indexer: DEBE.indexer,
			uploader: DEBE.uploader,

			createCert: DEBE.createCert,

			dbRoutes: {
				roles: &quot;openv&quot;,
				aspreqts: &quot;openv&quot;,
				ispreqts: &quot;openv&quot;,
				tta: &quot;openv&quot;,
				milestones: &quot;openv&quot;,
				journal: &quot;openv&quot;,
				hawks: &quot;openv&quot;,
				attrs: &quot;openv&quot;,
				issues: &quot;openv&quot;
			},

			diag: DEBE.diag,

			site: DEBE.site, // Site parameters

			/*
   statefulViews : { 					// Jade views that require the stateful URL
   	'workflow': 1,
   	'workflows': 1
   },*/

			/*NEWSREAD: { 					// Establish news byType
   	//JOB: APP.INGEST,
   	PROXY: {
   		hostname: 'http://omar.ilabs.ic.gov',
   		port: 80,
   		path: '/tbd',
   		method: 'GET'
   	}
   },*/

			mailer: { // Email parameters
				TRACE: true,
				ONSTART: true,
				SOURCE: &quot;tbd&quot;
			}

			/*
   likeus : {
   	BILLING : 1,				// Billing cycle [days]
   	PING : 0.5	 				// Check period [days]
   },
   */

		});

		Trace(&quot;INIT ATOMS&quot;);

		HACK.config({
			//source: &quot;&quot;,
			taskPlugin: null,
			thread: sqlThread
		});

		JSLAB.config({
			thread: sqlThread,
			fetcher: DEBE.fetchers.http
		});

		ATOM.config({
			thread: sqlThread,
			cores: DEBE.cores,
			watchFile: DEBE.watchFile,
			plugins: Copy({ // share selected FLEX and other modules with engines
				MAIL: FLEX.sendMail,
				RAN: require(&quot;randpr&quot;)
			}, JSLAB.libs)
		});

		if (cb) cb();
	}

	initENV(function () {
		// init the global environment
		initSES(function () {
			// init session handelling
			initSQL(function () {
				// init the sql interface

				JAX.config({
					MathJax: {
						tex2jax: {
							//displayMath: [[&quot;$$&quot;,&quot;$$&quot;]]
						}
					}
				});
				JAX.start();

				sqlThread(function (sql) {
					var path = DEBE.paths.render;

					if (false) DEBE.indexer(path, function (files) {
						// publish new engines
						var ignore = { &quot;.&quot;: true, &quot;_&quot;: true };
						files.each(function (n, file) {
							if (!ignore[file.charAt(0)]) try {
								Trace(&quot;PUBLISHING &quot; + file);

								sql.query(&quot;REPLACE INTO app.engines SET ?&quot;, {
									Name: file.replace(&quot;.jade&quot;, &quot;&quot;),
									Code: FS.readFileSync(path + file, &quot;utf-8&quot;),
									Type: &quot;jade&quot;,
									Enabled: 0
								});
							} catch (err) {
								//Trace(err);
							}
						});

						sql.release();
					});
				});
			});
		});
	});
}

function Trace(msg, arg) {
	TOTEM.trace(&quot;D&gt;&quot;, msg, arg);
}

function siteContext(req, cb) {

	cb(Copy(DEBE.site, {
		table: req.table,
		type: req.type,
		parts: req.parts,
		action: req.action,
		org: req.org,
		client: req.client,
		flags: req.flags,
		query: req.query,
		joined: req.joined,
		profile: req.profile,
		group: req.group,
		search: req.search,
		session: req.session,
		util: {
			cpu: (req.log.Util * 100).toFixed(0),
			disk: (req.profile.useDisk / req.profile.maxDisk * 100).toFixed(0)
		},
		started: DEBE.started,
		fileName: DEBE.paths.jaderef,
		url: req.url
	}));
}

// UNCLASSIFIED</pre>
</body>
</html>
