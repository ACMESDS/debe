//- UNCLASSIFIED

extends base
append base_parms
	- tech = "d3"
	
append base_help
	:markdown
		Display treefan chart using parameters:

			src = source url returning [ { name: "...", size: N, children: [ {...}, ... ] }, ... ]
			name = "name" || "name%..." || "" of source record(s)
			pivots = "key,key,..." || "" source record grouping keys
			w = drawing width
			h = drawing height
			debug = level of debugging alerts
			node,children,value,size,parent = key names

append base_head

	style.
		.node circle {
			cursor: pointer;
			fill: #fff;
			stroke: steelblue;
			stroke-width: 1.5px;
		}
		.node text {
			font-size: 11px;
		}
		path.link {
			fill: none;
			stroke: #ccc;
			stroke-width: 1.5px;
		}

	script.
		var opts = {
			ds: "#{query.pivots}"
				? "/!{query.src}.tree?name=#{query.name}&_sort=#{query.pivots}"
				: "#{query.name}"
							? "/!{query.src}.schema?name=#{query.name}"
							: "/!{query.src}",

			w: parseInt("#{query.w}") || 200,
			h: parseInt("#{query.h}") || 200,
			debug: parseInt("#{query.debug}"),
			NODE: "#{query.node}" || "name",
			CHILDREN: "#{query.children}" || "children",
			VALUE: "#{query.value}" || "value",
			PARENT: "#{query.parent}" || "parent",
			SIZE: "#{query.size}" || "size"	
		};

		const {NODE, CHILDREN, VALUE, SIZE, PARENT} = opts;

append base_body

	script.
		var 
			m = [20, 120, 20, 120],
			w = (opts.w || 1200) - m[1] - m[3],
			h = (opts.h || 500) - m[0] - m[2],
			i = 0,
			root = null,
			docWindow = null; 
			/*
			window.open(
					"",
					"_blank",
					"left=50px,top=50px,width=50,height=50,location=0,menubar=0,status=0,titlebar=0,toolbar=0"
			); */

		const {isString,Load} = BASE;

		var
			width = 960,
			height = 500,
			root;

		console.log(d3);
		var force = d3.forceSimulation()
			.size([width, height])
			.on("tick", tick);

		var svg = d3.select("body").append("svg")
			.attr("width", width)
			.attr("height", height);

		var link = svg.selectAll(".link"),
			node = svg.selectAll(".node");

		Load( opts, recs => {
			root = recs[0] || {};
			root.x0 = h / 2;
			root.y0 = 0;
			update();
		});

		function update() {
			var nodes = flatten(root),
			links = d3.layout.tree().links(nodes);

			// Restart the force layout.
			force
			.nodes(nodes)
			.links(links)
			.start();

			// Update the links?
			link = link.data(links, function(d) { return d.target.id; });

			// Exit any old links.
			link.exit().remove();

			// Enter any new links.
			link.enter().insert("line", ".node")
			.attr("class", "link")
			.attr("x1", function(d) { return d.source.x; })
			.attr("y1", function(d) { return d.source.y; })
			.attr("x2", function(d) { return d.target.x; })
			.attr("y2", function(d) { return d.target.y; });

			// Update the nodes?
			node = node.data(nodes, function(d) { return d.id; }).style("fill", color);

			// Exit any old nodes.
			node.exit().remove();

			// Enter any new nodes.
			node.enter().append("circle")
			.attr("class", "node")
			.attr("cx", function(d) { return d.x; })
			.attr("cy", function(d) { return d.y; })
			.attr("r", function(d) { return Math.sqrt(d.size) / 10 || 4.5; })
			.style("fill", color)
			.on("click", click)
			.call(force.drag);
		}

		function tick() {
			link.attr("x1", function(d) { return d.source.x; })
			.attr("y1", function(d) { return d.source.y; })
			.attr("x2", function(d) { return d.target.x; })
			.attr("y2", function(d) { return d.target.y; });

			node.attr("cx", function(d) { return d.x; })
			.attr("cy", function(d) { return d.y; });
		}

		// Color leaf nodes orange, and packages white or blue.
		function color(d) {
			return d._children ? "#3182bd" : d.children ? "#c6dbef" : "#fd8d3c";
		}

		// Toggle children on click.
		function click(d) {
			if (!d3.event.defaultPrevented) {
				if (d.children) {
					d._children = d.children;
					d.children = null;
				}
				else {
					d.children = d._children;
					d._children = null;
				}
				update();
			}
		}

		// Returns a list of all nodes under the root.
		function flatten(root) {
			var nodes = [], i = 0;

			function recurse(node) {
				if (node.children) node.children.forEach(recurse);
				if (!node.id) node.id = ++i;
				nodes.push(node);
			}

			recurse(root);
			return nodes;
		}

//- UNCLASSIFIED
