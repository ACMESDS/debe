//- UNCLASSIFIED

extends base
append base_parms
	- tech = "d3"

append base_help
	:markdown
		Display d3 circle-pack chart using parameters:

			src = source url returning [ { name: "x.y.z ...", size: N, doc: "", imports: [ "x.y.z ...", ... ]
			name = "name" || "name%..." || "" of source record(s)
			pivots = "key,key,..." || "" source record grouping keys
			w = drawing width
			h = drawing height
			debug = level of debugging alerts
			node,nodes,value,size,parent,doc = tree keys

append base_head
	style.
		.node {
			font: 10px sans-serif;
		}

		.link {
			stroke: steelblue;
			stroke-opacity: 0.5;
			fill: none;
			pointer-events: none;
		}

	script.
		var opts = {
			ds: "#{query.pivots}"
				? "/!{query.src}.tree?name=#{query[NAME]}&_sort=#{query.pivots}"
				: "#{query[NAME]}"
							? "/!{query.src}.schema?name=#{query[NAME]}"
							: "/!{query.src}",

			w: parseInt("#{query.w}") || 200,
			h: parseInt("#{query.h}") || 200,
			debug: parseInt("#{query.debug}"),
			NODE: "#{query.node}" || "name",
			NODES: "#{query.nodes}" || "nodes",
			VALUE: "#{query.value}" || "value",
			PARENT: "#{query.parent}" || "parent",
			SIZE: "#{query.size}" || "size",
			DOC: "#{query.doc}" || "doc"
		};

		const {NODE, NODES, VALUE, SIZE, PARENT, DOC} = opts;
		const {isArray,isString,Load} = BASE;

append base_body

	script.
		var
			w = opts.w || 1200,
			h = opts.h || 500;

		var 
			diameter = 960,
			radius = diameter / 2,
			innerRadius = radius - 120;

		var 
			cluster = d3.cluster()
			.size([360, innerRadius]),

			line = d3.radialLine()
			.curve(d3.curveBundle.beta(0.85))
			.radius(function(d) { return d.y; })
			.angle(function(d) { return d.x / 180 * Math.PI; });

		var 
			svg = d3.select("body").append("svg")
			.attr("width", diameter)
			.attr("height", diameter)
		    .append("g")
			.attr( "transform", "translate(" + radius + "," + radius + ")" );

		var 
			link = svg.append("g").selectAll(".link"),
			node = svg.append("g").selectAll(".node");

		var 
			body = d3.select("body"),
			msg = "p".d3tag(body, {text: "root"}),
			url = "#{url}".replace("/fan",""),
			title = "p".d3tag(body,	{ html: [
					].join(" || ")
				});

		Load( opts, data => {
			var root = packageHierarchy( isArray(data) ? data : [data] )
				  .sum(function(d) { return d.size; });

			cluster(root);

			link = link
			.data(packageImports(root.leaves()))
			.enter().append("path")
			.each(function(d) { d.source = d[0], d.target = d[d.length - 1]; })
			.attr("class", "link")
			.attr("d", line);

			 node = node
			.data(root.leaves())
			.enter().append("text")
			.attr("class", "node")
			.attr("dy", "0.31em")
			.attr("transform", function(d) { return "rotate(" + (d.x - 90) + ")translate(" + (d.y + 8) + ",0)" + (d.x < 180 ? "" : "rotate(180)"); })
			.attr("text-anchor", function(d) { return d.x < 180 ? "start" : "end"; })
			.text(function(d) { return d.data.key; });			
		});

		// Lazily construct the package hierarchy from class names.
		function packageHierarchy(classes) {
			var map = {};

			function find(name, data) {
				var node = map[name], i;
				if (!node) {
					node = map[name] = data || {name: name, children: []};
					if (name.length) {
						node.parent = find(name.substring(0, i = name.lastIndexOf(".")));
						node.parent.children.push(node);
						node.key = name.substring(i + 1);
					}
				}
				return node;
			}

			classes.forEach(function(d) {
				find(d.name, d);
			});

			return d3.hierarchy(map[""]);
		}

		// Return a list of imports for the given array of nodes.
		function packageImports(nodes) {
			var map = {},
			imports = [];

			// Compute a map from name to node.
			nodes.forEach(function(d) {
				map[d.data.name] = d;
			});

			// For each import, construct a link from the source to target node.
			nodes.forEach(function(d) {
				if (d.data.imports) d.data.imports.forEach(function(i) {
				imports.push(map[d.data.name].path(map[i]));
			});
			});

			return imports;
		}

// UNCLASSIFIED
