// UNCLASSIFIED

extends site
append site_help
	:markdown
		See also the companion [api reference](/api.jade) and the [programmers ref manual](/shares/doc/totem/index.html).
append site_parms
	- view = "Typical"
	- options = {tipsheets: "", blogs: "", embeds: "", workflows:"", plugins:"", odbc:"", immersions:"", finders:"", navigators:"", techpubs:"", briefs:"", visuals:""}
append site_body

	case query.options
		when "embeds"
			#post.Simple.Embed(path=hosts.w3,dims="750,500",head="Refresh,Help",wrap)

				:markdown
					Here is a sample service embed.  This was embedded with the "refresh" option, so you 
					need to *refresh* to access the service.  If this was embedded w/o the "refresh" option,
					the service would be already available.  The "refresh" option is particularly useful 
					in [large briefings](/tutorial.view) so hold-off posts until they are needed.

			#grid.Complex.Embed(
				path="/news.db",wrap,
				head="Edit,Help",
				cols="Message,To,Category")

				#folder.Embeds
					#fit.Deep.Insights
						:markdown
							this is a grid whose help button contains embedded widgets as well.

							p.al The Lorenz Equations $x=y$
							p.
								\[
								\begin{align}
								\dot{x} & = \sigma(y-x) \\
								\dot{y} & = \rho x - y - xz \\
								\dot{z} & = -\beta z + xy
								\end{align}
								\]

					#post.Home.Site(path="/home.view?options=news",dims="600,300",wrap)
					#post.Tech.Pub(path="/expub.view",dims="600,300",wrap)
					#minielt.Image.Editor(path="/uploads/a1.jpg",dims="600,300",wrap)
						:markdown
							this is a test image containing a typeset popup
					
		when "odbc"
			#grid.Excel(path="/test.db",cols="a,b,c,d")
			#grid.ViaAccess(path="/linktest.db",cols="a,b,c,d,e")
			#grid.WebSite(path="/somesite.db",cols="x1,x2,x3,x4")
			#grid.Proxies(path="/proxies.db",
				cols="Enabled.c,Name,File(Path,Sheet),Period.n,Special.x,Updates.i,Updated.d,Machine(Vars.x,Classif,Engine,Code.x)")

		when "plugins"
			#post.cv.Plugin(path="/haar.plugin",dims="800,600",wrap)
			#post.py.Plugin(path="/pydemo1.plugin",dims="800,600",wrap)
			#post.js.Plugin(path="/jsdemo1.plugin",dims="800,600",wrap)
			#post.ma.Plugin(path="/mademo1.plugin",dims="800,600",wrap)

		when "immersions"
			#earth.Cesium(path="HelloWorld",dims="800,600",wrap)
			#bump.Bump(path="cubeland",dims="800,600",wrap)
			#bounce.Bounce(path="bogus",dims="800,600",wrap)
			#anaglyph.Anagylph(path="bogus",dims="800,600",wrap)
			#paint.Paint(path="bogus",dims="800,600",wrap)

		when "blogs"
			#grid.Ex.Blog(
				path="news.db?_blog=Message",refresh=300,
				sorts="Stay,Starts",page=30,calc,head="Search,Print,Refresh",
				cols="Message.h")

				:markdown
					The cool thing about blogging grids is that they can be printed.  This one is setup
					to blog Messages and function as a spreadsheet calculator.

		when "finders"
			#pivot.Find(
				path="/intake.db",
				page=50,
				pivots="App,Name,Tech",kiss,
				cols="Condition(TRL,Track,Reason),General(Special,HWConfig,SWConfig,Parms),Data Collect Requirements(Reqts(C*),iName,iClassif,iSpec),Host Env Requirements(Reqts(H*),oName,oClassif,oSpec),Dissem Requirements(M*)")

			- fby = {"a":"A","b":"B"}
			#null.FilterBy(path="#{JSON.stringify(fby)}",cols="Name,opt")

			#grid.List(
				path="/intake.db?Name=${xs('FIND').Name}",
				page=50,
				sorts="App,Name",menu="FilterBy,TestBy(a,b,c)",
				cols="Name,App,Tech,TRL,Track,General(Special,HWConfig,SWConfig,Parms),Data Collect Requirements(Reqts(C*),iName,iClassif,iSpec),Host Env Requirements(Reqts(H*),oName,oClassif,oSpec),Dissem Requirements(M*)")

			#form.Edit(
				path="/intake.db?ID=${xs('List').ID}",
				cols="Name,App,Tech,TRL,Track,General(Special,HWConfig,SWConfig,Parms),Data Collect Requirements(Reqts(C*),iName,iClassif,iSpec),Host Env Requirements(Reqts(H*),oName,oClassif,oSpec),Dissem Requirements(M*)")

				:markdown
					To make a jade skin **hello**, create a **hello**  [jade engine](/engines.view) then
					render it with **/hello.view**.  You can learn more about how to [skin #{title}](/skinguide.view) 
					and the [#{title} API](/api.view).  

		when "navigators"
			#fit.Ex.Navigator
				#exnav.Navs(dims="800,600")

		when "tipsheets"
			#fit.Ex.Tipsheet
				#tipsheet.Tips(
					path="/tips.db",
					pivots="cat,tip,name,symbol,lat,lon,nipf,nipf,links")

		when "techpubs"
			#post.Ex.Tech.Pub(path="/expub.view",dims="800,600",wrap)

		when "mobiles"
			p Pending

		when "briefs"
			#exbrief.Brief(dims="800,600",wrap)

		when "workflows"
			#accordion
				#nodered.Stateless(path="/",dims="1100,600")
				#nodeflow.Stateful(path="Python2&view=Kiss",dims="1100,600")

		when "ex"
			//
				#pivot.Browser(
				path="/intake.db",
				page=10,
				pivots="TRL,Name",
				cols="name")
		
			#pivot.Browser(
				path="/intake.db",
				page=10,
				pivots="TRL,App",
				cols="ID,App,TRL,Tech")

		when "visuals"
			- bpath = "/intake.json&pivots=${ds('Browser').pivots}"

			#pivot.Browser(
				path="/intake.db",kiss,
				page=25,
				pivots="TRL,App,Tech",
				cols="ID,App,TRL,Tech")

			#force.FP(path=bpath)
			#sankey.SK(path="/data/energy.json")
			#omg.OG
			#plot.RC(path="/rocs.json?index=FPR,TPR&_ref=[0,0],[1,1]&marker=dot&legend=ROC&trace=1&_extra=[0,0]")
			#map.EM(path="/maps.json&fill=Type&index=Name&details=Info&${xs('Browser')}")
			#grid.MapData(path="/maps.json",page=20,cols="Name,Type,Info.x")
			#treefan.TF(path=bpath)
			#treemap.TM(path=bpath)
			#cluster.DC(path=bpath)
			#cpack.CP(path=bpath)
			#chords.CH(path="/bank.json")
					
		default
			#fit.Introduction
				:markdown
					When a client requests a X.view, **#{nick}** renders this view with the jade skin associated with X.  [Jade](http://jade-lang.com/tutorial/)
					skins deliver html to the requesting client via a highlevel, js compatible markdown (a more powerful
					version of angularjs).  **#{nick}** retrieves the skin for a X.view request by first attempting to find a jade skinning
					engine named X in its [jade engines](/engine.jade).  If no skin is found, **#{nick}** retrieves the skin from its 
					internal jade skin area. 

					Skins are built on framework skins.  Frameworks provide a parms, a head, and a body block which are extended 
					by a parent skin.  Any skin is free to become a framework by simplying defining its own parms, head, and body blocks.				
					Tthe [home skin](/home.jade), for example, extends the [site framework](/site.jade), which extends 
					the [base framework](/base.jade), which then extends the [layout framework](/layout.jade).

					Many views -- for example, the  D3 [force](/force.jade), [cluster](/cluster.jade), [cpack](/cpack.jade), [treefan](/treefan.jade), [treemap](/treemap.jade), [sankey](/sankey.jade), 
					[chords](/chords.jade), the [plot](/plot.jade) and others [map](/map.jade), [files](/files.jade)) -- employ the layout framework, and can accept query parameters themselves (see, 
					for example, the [D3 plot](/plot.jade)).

					A parent skin extends a framework skin following the **parms-head-body** pattern:

						extends FRAMEWORK
						append FRAMEWORK_head
							CONTENT
						append FRAMEWORK_parms
							- parm = value
							- parm = value
							- parm = value
						append FRAMEWORK_body
							CONTENT

					where CONTENT is more jade.

			#folder.Frameworks(dock="left")
				#fit.layout
					:markdown
						Provides a base layout framework with parameters:

							banner = "site banner"
							start = "div name" to place content
							math = false | true to enable mathjax plugin 
							highlight = "zenburn | ..." code styling theme 
							capture = false | true to add screen capture button
							&inline = "/file.type &w=width &h=height" to embed a file with derived attributes

				#fit.base
					:markdown
						The base framework provides a specific interface and accepts parameters:

							tech = "extjs | jquery | dojo | reveal | voxel | scene | three | cesium | joint | d3 | flow | ..."
							locale = "[en] | fr | de | ..." language plugin 
							holdoff = "button name" to holdoff loading via button
							holdoff = "skin,skin, ..." skins to holding loading via accordion
							start = "starting div" to place content

							extjs:
								carousel = false | true image plugin
								theme = "crisp | neptune | aria | gray | ..." styling
								charting = true | false data visualization plugin

							reveal:
								theme = "default | ..." styling  
								classif = "classification banner"

							jquery:
								grid = "DataTable | w2UI | jqgrid | ... " gridding technology
								image = "Darkroom | Camen | Vide | Fabric | ... " image technology
								pivot = "Isotope | elFinder | apy-X | ... " pivot technology
								themer = false | true
								password = false | true

							voxel:
								game = "cubeland | ... "

							three:
								effect = "AnaglyphEffect | ... "

							cesium:
								src = query.src
								src = "dataset | ..." 
								host = "aws | geohub | me | win | local | local | swaggpu | swagaws | swagdev | ..."
								width = 750
								height = 500

							d3:
								map = "world | usa | ... "

							flow:
								none

				#fit.site
					:markdown
						Extends the base framework to provide a standard site skinning framework with parameters:
						
							options = {menuReturn: menuDisplay | "", ...} dropdown options menu
							dock = [left | right | top | bottom] folder docking style 
							dims = width,height maximum widget dimensions 
							view = [Home | Kiss | Engr | Min | Basic | Nada, ...] site style
							page = maximum grid rows
							goto = tab to activate
							pulse = system health refresh rate (in seconds)

			#fit.Skin.Layouts

				:markdown
					Skins are layed-out as follows:

						#WIDGET.NAME(...)
							#WIDGET.NAME(...)

							:
							:

						#WIDGET.NAME(...)
							#WIDGET.NAME(...)

							:
							:

						TAG(...) CONTENT

						ishtml
							widget-free html

						:FILTER
							CONTENT

						code.LANGUAGE.
							CONTENT

						script.
							CONTENT

					where  

					+ FRAMEWORK specifies the desired skinning framework (see Introduction.Frameworks)

					+ NAME uniquely identifies this widget

					+ FILTER is [markdown](https://github.com/jstransformers) | markdown-it | supermarked | babel | less | coffee-script

					+ (...) represents a list of KEY=VALUE attributes

					+ COLON represents TAGs or [Jade program flow](http://jade-lang.com/tutorial/)

					+ CONTENT include tag-specific content (e.g. markdown, $ mathjax $,  \$$ mathjax \$$ text, javascript, etc)

					+ a WIDGET falls into one of the following categories:  

						+ aggregator: **content** | **folder** | **accordion** | **window** | **border** | **post**
						+ layout: **anchor** | **fit** | **hbox** | **vbox** | **box** | **table** | **column**
						+ terminal: **grid** | **form** | **pivot** | **find** | **hold**
						+ cartesian chart: **bar** | **bar3d** | **candlestick** | **line** | **scatter**
						+ polar chart: **gauge** | **pie** | **pie3d** | **radar** | **surface**

					For example, the tabs in a **folder** (or the sections in an **accordion**, or the regions
					within a **border**) are introduced by indenting children widgets.  HTML and WIDGETs 
					indented under a terminal widget define the terminal's tool-tips.  

					A **post** widget can be used explictly or implictly:

						#post.NAME(path="/SKIN?src=SOURCE", ...)
						#SKIN.NAME(path="/SOURCE")

					where SKIN can specify a dataset, skin, file or file area.

					A widget's SOURCE **path** can reference a dataset, define static data, or define view options:
					+	/DATASET?QUERY
					+	[{key:val,...}]
					+	{key:display,...} 

					The optional dataset QUERY expression can be:
					+ KEY=VALUE & KEY=VALUE ...
					+ \\#{KEY ... F(...) ...} ...
					+ ${xs( 'DS' ).KEY ... x.KEY ... ds( 'DS' ).KEY ... d.KEY} ...

					where:
					+ \\#{...} references site context KEYs and methods F()
					+ ${...} uses xs('DS') to set **x** to the active record, and ds('DS') to set **d** to the properties of dataset DS

					The **hold** widget:

						#hold.FIELD(path="/DATASET",cols="DISPLAY,VALUE,...")

					holds data for comboboxes (with given DISPLAY VALUE cols) associated with the
					FIELD.combo cols used in other terminals.

			#fit.Widget.Attributes

				:markdown
					Source Attributes

						path = url path to dataset
						class = unique widget name
						key = name of unique record key (defaults to "ID")

					Display Attributes

						dims = "WIDTH,HEIGHT" widget dimensions
						title = header title
						hover = css class that renders hover-overs
						region = north | south | east | west | center border region
						page = number of records to display 
						refresh = data store refresh rate in seconds
						blogs = "KEY, ..." restrict bloggable fields
						sorts = "KEY, ..." add sorters
						plugins = "crbXCRF0" editor(cell/row), selector(boX/Column/Row), Filter(F), disable(0)

					Field Attributes

						cols = "KEY.type.tip, KEY*, KEY*count, ... " field list
						cols = "group(KEY,group(KEY, ...), ...), ..." field groups
						cols = "Pivot(NodeID,NodeCount,KEY,KEY, ...), ..." field pivots
						pivots = "KEY,KEY,..." pivot shortcut

					where
					> KEY* matches "KEY0, KEY1, ..." if found in the **Parms** dataset  
					> KEY*N returns "KEY0, KEY1, ... KEY[N-1]"  
					> type can be (capitialized hides field)  
						>	int | bigint | tinyint | autonum | auto  
						>	checkbox | boolean  
						>	varchar | text  
						>	html | longtext | mediumtext  
						>	textarea | xtextarea | json  
						>	file | svg | zilch | combo | geometry  
						>	number | float | double | percent | money  
						>	date | datetime | mediumdate | defaultdate | iso8601long | iso8601short |shortdate | longdate | fulldatetime | monthday | shorttime | longtime | sortabledatetime | universalsortabledatetime | yearmonth  
						>	##... action tokens from class img-Action-value0 | 1 | 2 ...

					Grid Switches

						calc	allow grid cell expressions and cell shifting
						crush	allow minimization
						refresh	manual data store refresher
						hide	render but dont show
						disable disable data entry
						notes	include data notepad within help 
						joins	include data joins within help 
						save	save view state (experimental)
						kiss	display simple linking cues
						wrap	forces display of header menu  
						summary = min | max | average | count | sum | util | any | all | prod | nills 

					When the **calc** switch is provided, grids will evaluate =prefixed cells as follows:
					>	=Font R|G|B|K|O... 
					>	=Style 0|1|2... 
					>	=EXPRESSION like $f.FUNC( $.KEY ) ...

					Content Attributes

						icons = path to icon resources
						start = widget to start skinning defaults to "content"
						query = parameters to save in query variable

					Chart Attributes

						plot = bar,column,scatter,info,pie,radar,xgrid,ygrid,[xmin,xmax,ymin,ymax]

					Folder Attributes

						active = folder tab to make active

					Menu Attributes

						top = "MENU" docked to top
						left = "MENU" docked to left
						right = "MENU" docked to right
						bottom = "MENU" docked to bottom
						head = "MENU" docked to header
						menu = "MENU" additional items

					where:
					+	MENU: WIDGET, ... GROUP(SOURCE,WIDGET,SPECIAL,ACTION,LOADER,BREAK ...), ...   
					+	WIDGET: combo widget with cols=Name,Value fields  
					+	SPECIAL: Search | Print | Refresh | Help | Capture | Save | Status | Delta | Blog | Datasets | Agents
					+	ACTION: Insert | Update | Delete | Select | Execute  
					+	LOADER: $stores | $uploads | $positives | $negatives  
					+	BREAK: |

			#fit.Workflows

				#folder(left)
					#fit.Introduction
						:markdown
							## Models
							A workflow defines a network of systems.  A system (aka machine, engine or application) can be a 
							discrete block (triggered or sampled), a state machine, or a petri net.  Each system has a URL identifing 
							the path to a restful application that sinks and sources event tokens.  The [api](/api.jade) explains
							the workflow engine interface.  Workflows can be defined using the [workflow editor](/workflow.jade).

							Engine stats (event rates, queueing delay, utilization, drops, etc), machine states, and petri tokens are
							logged as the client steps/advances a workflow with the specified simulation options (number of steps, 
							step size, stats snapshot period).

							Workflows are constructed using the system skins, and are compiled, linked and executed at the client
							using the [workflow editor](/workflow.jade).  A workflow skin will thus look like:

								#system.label(inputs="link,link,...",outputs="link,link,...")  
									#system.label(inputs="link,link,...",outputs="link,link,...")  
									#system.label(inputs="link,link,...",outputs="link,link,...")  

							where i/o ports can accept/produce either simple or N-fold threads:

								input link = name|N|system|name  
								output link = name|N

							## Threaded Models
							System i/o ports (and their corresponding i/o event tokens) can be either simple or N-fold threaded.
							Whereas simple ports are sampled, threaded ports are triggered.  In an algorithm chain of, say, 3 systems, 
							with 5, 10, and 2 threaded output ports, there are 5*10*2=100 total execution threads that can be shared
							(hyper-threaded) among K processing cores (if the server implements, say, K=4 processing cores, then 
							no more than 100/4=25 threads are impacted by a single failing thread).

							## Application Interface
							Each system application supports TAUINIT, TAUSTEP, TAUKILL, and TAUREAD (restful PUT, POST, DELETE, GET) to
							program, advance, deallocate and read an engine given itau, otau and state parameters: 

								itau = [event1, event2, ...] events being sinked to inputs ports 1,2, ... 
								otau = [event1, event2, ...] events being sourced from output ports 1,2, ...
								state = {simulation step count, relative simulation time, depth of queue, drops from queue, 
										engine index, as well as a port reset, port name, and port index when stepping i/o threads}.

					#fit.Attributes
						:markdown
							## All systems [default value]

								run [false] autorun simulation with the specified simulation options
								stats = "name" ["stats"] of simulation options in simoptions.db
								buffers = N [0] reserved

							## Discrete systems

								inputs = "link, link, ..." [""] input ports
								outputs = "link, link, ..." [""] output ports

							where link = "name|N|system|name" defines an N-threaded or N=0 simple port.

							## State machines:

								routes = "route, route, ..." [""] are the routes for a state machine

							where route = "fromState | toState | condition | exit | entry" [""] defines from-to machine states, condition code and from state exit-entry code (condition=start to define initial state).

							## Petri nets:

								markers	= "transition, transition, ..." [""] are the transitions for a petri net

							where:

								transition = "fromPlaces || transition || toPlaces" defines from-to places and transition to take-deposit petri net tokens ("n|k|..." initializes each place with n,k,... tokens).
								places = "place | place | ..." are the places from which to take-deposit petri net tokens.
								start = "name" ["content"] of widget to open

					#fit.Examples
						:markdown
							## STEP/POST example
							A POST to system X with a state hash of {... reset:1,name:"A"} directs system X to load its 
							input state variable "A" with the contents of the input job stream itau[0].job.  A POST to system X with a state
							hash of {... reset:0,name:"B"} directs X to advance its output variable "B" into each 
							output job stream otau[n].job.

							## INIT/PUT example

							## FREE/DELETE example

							## READ/GET example

			#fit.Context.Keys
				:markdown
					Context keys are inserted using \\#{KEY} or \\!{KEY} with or without html-escaping (current 
					value).  There are request-context keys:
					
					+	table	= request dataset, view, or engine (#{table})  
					+ 	search	= request search parameters (#{search})  
					+ 	url = full url requested (#{url})
					+ 	path	= request file path (#{path})  
					+	parts = file parts (#{json(parts)})
					+	action	= request action (#{action})  
					+	query	= request query (#{json(query)})
					+	flags	= request flags (#{json(flags)})  
					+	joined = time session started (#{json(joined)})
					
					session-context keys:
					+	client	= client's name (#{client})  
					+	profile	= client's qos profile (#{json(profile)})  
					+ 	group = client's assigned group (#{group})
					+ 	org = client organization (#{org})
					+	email	= client email address (#{email})  
					+	util = cpu and disk utilization (#{json(util)})
					
					site-context keys:
					+ 	urls	= site urls (#{json(urls)})
					+	db	= main database (#{db})  
					+	pocs = poc by role hash (#{pocs})  
					+	distro	= poc by role distribution hash (!{distro})  
					+	info 	= system information (#{json(info)})  
					+	title	= full site name (#{title})  
					+	nick	= site nick name (#{nick})  
					+	ver	= site version number (#{ver})  
					+	released	= site release date (#{released})  
					+	started = site started date (#{json(started)})  
					+	port = site port number (#{port})  
					+	classif = site classification attributes (#{classif})  
					+	cores = number of worker threads (#{cores})  
					+	lock	= session lock (#{json(options)})
					
					and several data manipulator methods:
					
					+	get( list, {key:query,...} )
					+	get( list, {key:query,...}, {key:rename,...} )
					+	get( list, {key:query,...}, {key:rename,...}, {prefix: {recKey:{key:#replace, ...}, ...}, ...} )
					+	get( dsname, {key:query,...}, function (data) {...} )
					+	gridify( list,noheader )
					+	json( list )
					+ 	hover( title, jpgShares, htmlShares )
					+ 	tag( text, el, {key:value,...} )

			//- #exsite.Examples(dims="800,500")
