// UNCLASSIFIED
//-
	Render a skin when DEBE encounters dynamic view endpoints /DS.MODE where
		&mode = MODE = brief | gridbrief | runbrief | pivbrief| run | plugin | view | pivot
		&cols = [key.type, ...]
		&page = page size of DS grid
		&refresh = refresh time of associated job grid
		&width = post width
		&height = post height

extends base
append base_parms
	case query.mode
		when "brief"
		when "gridbrief"
		when "runbrief"
		when "pivbrief"
			- tech = "reveal"
		default
			- tech = "extjs"

extends site
append site_parms
	case query.mode
		when "site"
			- view = "Basic"
		when "plugin"
			- view = "Insert"
			- options = { "more+":"", "more++":"", less:"" }
		when "run"
			- view = "Typical"
			- options = { "more+":"", "more++":"", less:"" }
		when "view"
		when "pivot"
		when "brief"
		default
			- view = "Nada"

append site_body

	- mode = query.mode
	- ds = query.ds || "myplugin"
	- dscols = query.cols || []
	- dspage = query.page || 20
	- dsquery = query.search || ""
	- dsrefresh = query.refresh || ""
	- dspath = `/${ds}.db`
	- dstitle = ds + " view"
	- dsdims = query.dims
	- dims = dsdims.split(",")
	- height = dims.pop()
	- width = dims.pop()
	- tasks = projs ? get( projs , {Plugin:ds}, "Task,Hours,Complete,FAQ1,FAQ2") : []
	- more = parseInt(query.more) || 0

	case mode
		when "plugin"
		when "run"
			#grid.Usecases(
				path=dspath,
				cols=dscols.join(),
				menu="Agents",
				wrap,
				blogs="Description",
				dims=dsdims,
				hover="finished",
				page=dspage )

				:markdown
					You can execute the *#{ds}* engine from its [customizable](/skinguide) [run](#{ds}.run), [usecase](#{ds}.view), or 
					[plugin](#{ds}.plugin) view by simply selecting the desired usecase and clicking *Execute*.  You may also 
					execute *#{ds}* [directly](/api.view) by [usecase Name](/#{ds}.exe?name=CASE) or by [usecase ID](#{fs}.exe?id=CASE).
					
					An engine's usecase *context* can be agumented by optional keys:  
					> [Export+](/#{ds}.add?Export=false) [/-](/#{ds}.sub?Export) writes engine results into a file  
					> [Ingest+](/#{ds}.add?Ingest=false) [/-](/#{ds}.sub?Ingest) ingests engine results into the database  
					> [Share+](/#{ds}.add?Share=false) [/-](/#{ds}.sub?Share) saves engine results to the status area  
					> [Pipe+](/#{ds}.add?Pipe=doc) [/-](/#{ds}.sub?Pipe) regulates chips and events to the engine  
					> [Description+](/#{ds}.add?Description=doc) [/-](/#{ds}.sub?Description) documents a usecase  
					> [Config+](/#{ds}.add?Config=doc) [/-](/#{ds}.sub?Config) defines usecase context with a js-engine  
					> [Save+](/#{ds}.add?Save=doc) [/-](/#{ds}.sub?Save) aggregates engine results not captured in the Save_KEYs  
					> [Save_KEY](/#{ds}.run?options=more) aggregates engine results [{at:"KEY", ...}, ...]  
					
					When executed, an engine's context is automatically extended with the following keys:  
					> _Host name of plugin  
					> _File current file during workflow  
					> _Voxel current voxel being procesed  
					> _Collects sensor collects made under current voxel  
					> _Chip  filepath for first jpeg collect under current voxel  
					> _Flux solar flux at earth's surface under current voxel  
					> _Load event query for current voxel  
					
					An engine's *Pipe* context key contains job regulation parameters:  
					> file: "/FILTER?QUERY" || "PLUGIN.CASE" || "uploaded FILENAME" || "FILE.jpg" || "FILE.json"  
					> group: "KEY,..." || ""  
					> where: { KEY: VALUE, ...} || {}  
					> order: "KEY,..." || "t"  
					> limit: VALUE || 1000  
					> task: "NAME" || ""  
					> aoi: "NAME" || [ [lat,lon], ... ] || []

					and where the *Description* key may contain [blogging tags](/skinguide.view) of the form:
					> image\[ SRC, W, H ]  
					> post\[ SRC, W, H ]  
					> gen\[ SRC , W, H ]$ QUERY $  
					> \[ LINK ]( URL )   
					> $ inline TeX $  ||  $$ break TeX $$ || a$ AsciiMath $ || m$ MathML $ || get$ KEY $ || tex$ KEY $

					to document usecases.  For example:

						gen[/plot.view,100,200]$x=ds.Save.a&ys=[ds.Save.b,ds.Save.c]$
						post[/home.view,500,100]
						[link](https:/go.here)
						image[/shares/a1.jpg]
						gen[force,100,100]$queues.tree?_pivots=class$
						$$ \alpha = 1 + \beta $$ impressive 'eh

					to embed: (1) a plot of the requested x,y data using the [d3 plot](/plot.view), (2) the 
					[home.view](/home.view), (3) a link to the url, (4) the [image](/shares.jpg), (5) a
					force graph of the queues dataset pivoted by class using the [d3 force](/force.view) 
					into a frame of specified W x H dimensions, and (6) a TeX equation.	  Blogging is toggeled by the *Blog* button.  
					
					Usecase views are colorized to reflect the plugin's development status: completed/green, policed/blue, 
					funded/orange, unfunded/red as defined by [project milestones](/milestones.view).
					
				table!= gridify(tasks)
	
			#form.Engine(
				path="/engines.db?Name=#{ds}",
				hover="pending",
				head="select,insert,update,|,delete,|,refresh,login",
				login="/login?pass=",
				cols="ID,Name,Type,Enabled.c,Program(Code.x,State.x.Context)")

				:markdown
					[Engines](api.view) automatically have the LWIP,SQL and JSON modules; js-engines also automatically have the
					[MAT matlab emulator](https://www.npmjs.com/package/mathjs),
					[DSP digitial signal processing](https://www.npmjs.com/package/dsp), 
					[CRY crypto](https://nodejs.org/docs/latest/api/crypto),
					[FLEX data extender](https://github.com/ACMESDS/flex),
					[RAN markov random process](https://github.com/ACMESDS/randpr),
					[SVD singular value decomposition](https://www.npmjs.com/package/node-svd),
					[VITA hidden markov model solver](https://www.npmjs.com/package/nodehmm),
					[MLE maximum liklihood estimator](https://www.npmjs.com/package/node-svd),
					[MVN multivariate normals](https://www.npmjs.com/package/multivariate-normal), and
					[MAIL simple mail transfer](https://www.npmjs.com/package/nodemailer)
					modules.  
					
			#grid.Jobs(
				path="/queues.db?Class=#{ds}",
				cols="Arrived.d,Departed.d,Client,Notes.x,QoS.n,Age.n,Funded.c,Finished.c,Priority.n,Work.n,State.n,Task.t,Signoffs(Flagged.c,Sign0.c,Sign1.c,Sign2.c,Sign3.c)",
				wrap,
				head="Print,Refresh,Execute,Help",
				hover="policed",
				page=dspage )

				:markdown
					sorts="Work,State"
					refresh=refresh
					Jobs created by this plugin are show here.  If the job originator exceeded their credits,
					the job is marked "unfunded"; otherwise the job is marked "funded".  If you would like to 
					fund an unfended job, simply click its "(un)funded" link.  To decide if this is a wise purchase, 
					click the "#{ds}" link to see the test case case being explored; additional project information,
					if available, is attached as "RTP", "PMR" etc links.  Earning job credits is easy: simply 
					upload your data using the Files | Uploads.

			if more>0
				#grid.ContextKeys(
					path="/keyedit.db?ds=#{ds}",
					cols="Key,Type,Samples.x,Dist,Parms.x",
					wrap,
					page=dspage)
					
			if more>1
				#post.Flow( path="/#{ds}_flow.view", dims="800,600",wrap )

		when "pivot"
			- pcol = dscols.pop()
			#pivot(
				class=dstitle,
				path=dspath,
				pivots=pcol,
				cols=dscols.join(),
				page=dspage )

		when "brief"
		when "gridbrief"
			section
				h3.hd= dstitle

				if query.data
					div!= gridify( query.data )

				else				
					iframe(
						src="/#{ds}.view?dims=#{dsdims}",
						width=width,
						height=height )

		when "pivbrief"
			section
				h3.hd= dstitle
				iframe(
					src="/#{ds}.pivot?dims=#{dsdims}",
					width=width,
					height=height )

		when "runbrief"
			section
				h3.hd= dstitle				
				iframe(
					src="/#{ds}.run?dims=#{dsdims}",
					width=width,
					height=height )

		default
			#grid(
				class=dstitle,
				path=dspath,
				cols=dscols.join(),
				dims=dsdims,
				page=dspage )

// UNCLASSIFIED
