//- UNCLASSIFIED

extends base
append base_parms
	- tech = "d3"

append base_help
	:markdown
		Display d3 circle-pack chart using parameters:

			src = source url returning [ { name: "...", size: N, doc: "", nodes: [ {...}, ... ] }, ... ]
			name = "name" || "name%..." || "" of source record(s)
			pivots = "key,key,..." || "" source record grouping keys
			w = drawing width
			h = drawing height
			debug = level of debugging alerts
			node,nodes,value,size,parent,doc = tree keys

append base_head

	svg(width="960",height="960")

	style.
		.node {
			cursor: pointer;
		}

		.node:hover {
			stroke: #000;
			stroke-width: 1.5px;
		}

		.node--leaf {
			fill: white;
		}

		.label {
			font: 11px "Helvetica Neue", Helvetica, Arial, sans-serif;
			text-anchor: middle;
			text-shadow: 0 1px 0 #fff, 1px 0 0 #fff, -1px 0 0 #fff, 0 -1px 0 #fff;
		}

		.label,
		.node--root,
		.node--leaf {
			pointer-events: none;
		}

	script.
		var opts = {
			ds: "#{query.pivots}"
				? "/!{query.src}.tree?name=#{query[NAME]}&_sort=#{query.pivots}"
				: "#{query[NAME]}"
							? "/!{query.src}.schema?name=#{query[NAME]}"
							: "/!{query.src}",

			w: parseInt("#{query.w}") || 200,
			h: parseInt("#{query.h}") || 200,
			debug: parseInt("#{query.debug}"),
			NODE: "#{query.node}" || "name",
			NODES: "#{query.nodes}" || "nodes",
			VALUE: "#{query.value}" || "value",
			PARENT: "#{query.parent}" || "parent",
			SIZE: "#{query.size}" || "size",
			DOC: "#{query.doc}" || "doc"
		};

		const {NODE, NODES, VALUE, SIZE, PARENT, DOC} = opts;
		const {isArray,isString,Load} = BASE;

append base_body

	script.
		var
			w = opts.w || 1200,
			h = opts.h || 500;

		var 
			body = d3.select("body"),
			msg = "p".d3tag(body, {text: "root"}),
			url = "#{url}".replace("/fan",""),
			title = "p".d3tag(body,	{ html: [
						"map".tag( "/map"+url ),
						"force".tag( "/force"+url ),
						"fan".tag( "/fan"+url )
					].join(" || ")
				});

		var
			svg = d3.select("svg"),
			margin = 20,
			diameter = svg.attr("width"),
			g = svg.append("g").attr("transform", "translate(" + diameter / 2 + "," + diameter / 2 + ")");

		var 
			root,
			format = d3.format(",d"),
			color = d3.scaleSequential([8, 0], d3.interpolateMagma);
			/*
			.domain([-1, 5])
				.range(["hsl(152,80%,80%)", "hsl(228,30%,40%)"])
				.interpolate(d3.interpolateHcl); */

		var 
			pack = d3.pack()
				.size([diameter - margin, diameter - margin])
				.padding(2);

		Load( opts, data => {
			root = d3.hierarchy( isArray(data) ? data[0] : data, d => d[NODES] )
				.sum(d => d[SIZE] )
				.sort(function(a, b) { return b.value - a.value; });

			var 
				focus = root,
				cpack = pack(root),
				nodes = cpack.descendants(),
				view;

			var 
				circle = g.selectAll("circle")
					.data(nodes)
					.enter().append("circle")
					.attr("class", d => d.parent ? d.children ? "node" : "node node--leaf" : "node node--root" )
					.style("fill", d => d.children ? color(d.depth) : null )
					.on("click", d => { 
						if (focus !== d) zoom(d);
						d3.event.stopPropagation();
					});

			var 
				text = g.selectAll("text")
					.data(nodes)
					.enter().append("text")
					.attr("class", "label")
					.style("fill-opacity", d => d.parent === root ? 1 : 0 )
					.style("display", d => d.parent === root ? "inline" : "none" )
					.text( d => d.data[NODE] );

			var 
				node = g.selectAll("circle,text");

			svg
				.style("background", color(-1))
				.on("click", function() { zoom(root); });

			zoomTo([root.x, root.y, root.r * 2 + margin]);

			function zoom(d) {
				var focus0 = focus; focus = d;

				var transition = d3.transition()
				.duration(d3.event.altKey ? 7500 : 750)
				.tween("zoom", function(d) {
					var i = d3.interpolateZoom(view, [focus.x, focus.y, focus.r * 2 + margin]);
					return function(t) { zoomTo(i(t)); };
				});

				transition.selectAll("text")
					.filter( function (d) { return d.parent === focus || this.style.display === "inline"; } )
					.style("fill-opacity", d => d.parent === focus ? 1 : 0 )
					.on("start", function (d) { 
						if (d.parent === focus) this.style.display = "inline";
					})
					.on("end", function (d) { 
						if (d.parent !== focus) this.style.display = "none";
					});
			}

			function zoomTo(v) {
				var k = diameter / v[2]; view = v;
				node.attr("transform", d => "translate(" + (d.x - v[0]) * k + "," + (d.y - v[1]) * k + ")" );
				circle.attr("r", d => d.r * k );
			}
		});

// UNCLASSIFIED
