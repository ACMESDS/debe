Ext.data.JsonP.JSDB({"tagname":"class","name":"JSDB","autodetected":{},"files":[{"filename":"jsdb.md","href":"jsdb.md.html#JSDB"},{"filename":"jsdb.js","href":"jsdb.html#JSDB"}],"members":[{"name":"flattenCatalog","tagname":"method","owner":"JSDB","id":"method-flattenCatalog","meta":{}}],"alternateClassNames":[],"aliases":{},"id":"class-JSDB","extends":null,"singleton":null,"private":null,"mixins":[],"requires":["cluster","enum","mysql"],"uses":[],"short_doc":"SourceForge\n    github\n    geointapps\n    gitlab\n\nJSDB\n\nJSDB provides a JS-agnosticated interface to any (default MyS...","component":false,"superclasses":[],"subclasses":[],"mixedInto":[],"parentMixins":[],"html":"<div><pre class=\"hierarchy\"><h4>Requires</h4><div class='dependency'>cluster</div><div class='dependency'>enum</div><div class='dependency'>mysql</div><h4>Files</h4><div class='dependency'><a href='source/jsdb.md.html#JSDB' target='_blank'>jsdb.md</a></div><div class='dependency'><a href='source/jsdb.html#JSDB' target='_blank'>jsdb.js</a></div></pre><div class='doc-contents'><p><a href=\"https://sourceforge.net\">SourceForge</a>\n    <a href=\"https://github.com/acmesds/jsdb.git\">github</a>\n    <a href=\"https://git.geointapps.org/acmesds/jsdb\">geointapps</a>\n    <a href=\"https://gitlab.west.nga.ic.gov/acmesds/jsdb.git\">gitlab</a></p>\n\n<h1>JSDB</h1>\n\n<p>JSDB provides a JS-agnosticated interface to any (default MySQL-Cluster) database\nas follows:</p>\n\n<pre><code>var JSDB = require(\"jsdb\");\n\nJSDB.thread( function (sql) {\n    sql.context( {ds1:ATTRIBUTES, ds2:ATTRIBUTES, ... }, function (ctx) {\n\n        var ds1 = ctx.ds1, ds2 = ctx.ds2, ...;\n\n    });\n});\n</code></pre>\n\n<p>where dsN are datasets, sql in a MySQL connector, and dataset ATTRIBUTES = {key:value, ... } are\ndescribed below.  Alternatively, a lone dataset can be created thusly:</p>\n\n<pre><code>var JSDB = require(\"jsdb\");\n\nJSDB.thread( function (sql) {\n    var ds = new JSDB.DS(sql, ATTRIBUTES);\n})\n</code></pre>\n\n<p>The following JS-agnosticated CRUD queries can then be performed:</p>\n\n<pre><code>ds.rec = { FIELD:VALUE, ... }       // update matched record(s) \nds.rec = [ {...}, {...}, ... ]      // insert record(s)\nds.rec = null       // delete matched record(s)\nds.rec = function CB(recs,me) {...}         // select matched record(s)\n</code></pre>\n\n<p>with callback to a response CB method when the query completes.  Alternatively,\nqueries can be issued like this:</p>\n\n<pre><code>ds.res = callback() { ... }\nds.data = [ ... ]\nds.rec = CRUDE\n</code></pre>\n\n<p>or in record-locked mode using:</p>\n\n<pre><code>ds.rec = \"lock.\" + CRUDE\n</code></pre>\n\n<p>where CRUDE = \"select\" | \"delete\" | \"update\" | \"insert\" | \"execute\".</p>\n\n<p>Dataset ATTRIBUTES = { key: value, ... } provide SQL agnostication:</p>\n\n<pre><code>table:  DB.TABLE || TABLE\nwhere:  [ FIELD, FIELD, ... ] | { CLAUSE:null, nlp:PATTERN, bin:PATTERN, qex:PATTERN, has:PATTERN, like:PATTERN, FIELD:VALUE, FIELD:[MIN,MAX], ...} | CLAUSE\nres:    function CB(ds) {...}\nhaving: [ FIELD, VALUE ] | [ FIELD, MIN, MAX ] | {FIELD:VALUE, CLAUSE:null, FIELD:[MIN,MAX], ...} | CLAUSE\norder:  [ {FIELD:ORDER, ...}, {property:FIELD, direction:ORDER}, FIELD, ...] | \"FIELD, ...\"\ngroup:  [ FIELD, ...] | \"FIELD, ...\"\nlimit:  [ START, COUNT ] | {start:START, count:COUNT} | \"START,COUNT\"\nindex:  [ FIELD, ... ] | \"FIELD, ... \" | { has:PATTERN, nlp:PATTERN, bin:PATTERN, qex:PATTERN, browse:\"FIELD,...\", pivot: \"FIELD,...\" }\n</code></pre>\n\n<p>In addition, update journalling, search tracking, query broadcasting, and auto field conversion is\nsupported using these ATTRIBUTES:</p>\n\n<pre><code>unsafeok:   [true] | false      // allow potentially unsafe queries\ntrace: [true] | false           // trace queries\njournal: true | [false]         // enable table journalling\nsearch: \"field,field,...\"       // define fulltext search fields\ntrack: true | [false]       // enable search tracking\nag: \"...\"       // aggregate where/having with least(?,1), greatest(?,0), sum(?), ...\n</code></pre>\n\n<p>The select query will callback the CB=each/all/clone/trace handler with each/all record(s) matched\nby .where, indexed by  .index, ordered by .order, grouped by .group, filtered by .having\nand limited by .limit ATTRIBUTES.  Select will search for PATTERN\nusing its index.nlp (natural language parse), index.bin (binary mode), index.qex (query expansion),\nor group recording according to its index.browse (file navigation) or index.pivot (joint statistics).</p>\n\n<p>Non-select queries will broadcast a change to all clients if a where.ID is presented (and an emiitter\nwas configured), and willjournal the change when jounalling is enabled.</p>\n\n<p>JSDB will also add a number of methods to the sql connector:</p>\n\n<pre><code>    key getters: getKeys, getFields, jsonKeys, searchKeys, geometryKeys, textKeys\n    record getters: first, context, each, all\n    misc utils: cache, flattenCatalog\n    bulk insert records: beginBulk, endBulk\n    job processing: selectJob, deleteJob, updateJob, insertJob, executeJob\n</code></pre>\n\n<h2>Databases</h2>\n\n<p>openv.attrs   Defines default ATTRIBUTES on startup.<br/>\nopenv.hawks  Queried for moderaters when journalling a dataset.\nopenv.journal   Updated with changes when journalling enabled.\nopenv.tracks    Updated when search tracking enabled.\nopenv.locks Updated when record locks used (e.g. using forms).\napp.X   Scanned for tables that possess fulltext searchable fields.</p>\n\n<h2>Use</h2>\n\n<p>JSDB is configured and started like this:</p>\n\n<pre><code>var JSDB = require(\"../jsdb\").config({\n        key: value,                         // set key\n        \"key.key\": value,                   // indexed set\n        \"key.key.\": value,                  // indexed append\n        OBJECT: [ function (){}, ... ],     // add OBJECT prototypes \n        Function: function () {}            // add chained initializer callback\n        :\n        :\n    }, function (err) {\n    console.log( err ? \"something evil happended\" : \"Im running\");\n});\n</code></pre>\n\n<p>where its configuration keys follow the <a href=\"https://github.com/acmesds/enum\">ENUM copy()</a> conventions\ndescribed in its <a href=\"/shares/prm/jsdb/index.html\">PRM</a>.</p>\n\n<p>Require and config JSDB:</p>\n\n<pre><code>var JSDB = require(\"jsdb\").config({ \n\n    dbtx: {     // table translator\n        X: \"DB.Y\", ...\n    },\n\n    emit:  (crude,parms) =&gt; {  // method to bradcast changes to other socket.io clients\n    }, \n\n    mysql : {   //  database connection parms\n        host: ...\n        user: ...\n        pass: ...\n    }\n\n});\n</code></pre>\n\n<p>Its default DS generator and thread() method can be overridden if the default MySQL-Cluster\nsupport does not suffice.</p>\n\n<p>Create dataset on a new sql thread</p>\n\n<pre><code>JSDB.thread( function (sql) {\n\n    var ds = new JSDB.DS(sql,{table:\"test.x\",trace:1,rec:res});\n\n});\n</code></pre>\n\n<p>Create dataset and access each record</p>\n\n<pre><code>var ds = new JSDB.DS(sql,{table:\"test.x\",trace:1,limit:[0,1],rec:function each(rec) {console.log(rec)}});\nvar ds = new JSDB.DS(sql,{table:\"test.x\",trace:1,where:['x','%ll%'],rec:function each(rec) {console.log(rec)}});\nvar ds = new JSDB.DS(sql,{table:\"test.x\",trace:1,where:['a',0,5],rec:function each(rec) {console.log(rec)}});\nvar ds = new JSDB.DS(sql,{table:\"test.x\",trace:1,where:\"a&lt;30\",rec:function each(rec) {console.log(rec)}});      \n</code></pre>\n\n<p>Create dataset and access all records</p>\n\n<pre><code>var ds = new JSDB.DS(sql,{table:\"test.x\",trace:1,where:{\"a&lt;30\":null,\"b!=0\":null,\"x like '%ll%'\":null,ID:5},rec:function (recs) {console.log(recs)}});\nvar ds = new JSDB.DS(sql,{table:\"test.x\",trace:1,order:[{property:\"a\",direction:\"asc\"}],rec:function (recs) {console.log(recs)}});\nvar ds = new JSDB.DS(sql,{table:\"test.x\",trace:1,index:{pivot:\"root\"},group:\"a,b\",rec:function (recs) {console.log(recs)}});\n</code></pre>\n\n<p>Select ds record(s) matched by ds.where</p>\n\n<pre><code>ds.where = [1,2];\nds.rec = function (rec) {\n    console.log(rec);\n}\n</code></pre>\n\n<p>Delete ds record(s) matched by ds.where</p>\n\n<pre><code>ds.where = {ID:2}\nds.rec = null\n</code></pre>\n\n<p>Update ds record(s) matched by ds.where</p>\n\n<pre><code>ds.where = null\nds.rec = [{a:1,b:2,ds:\"hello\"},{a:10,b:20,x:\"there\"}]\nds.where = {ID:3}\nds.rec = {a:100} \n</code></pre>\n\n<h2>Installation</h2>\n\n<p>Clone from one of the repos.  You will typically want to redirect the following to your project</p>\n\n<pre><code>ln -s PROJECT/totem/test.js test.js\nln -s PROJECT/totem/maint.sh maint.sh\n</code></pre>\n\n<h2>License</h2>\n\n<p><a href=\"LICENSE\">MIT</a></p>\n</div><div class='members'><div class='members-section'><div class='definedBy'>Defined By</div><h3 class='members-title icon-method'>Methods</h3><div class='subsection'><div id='method-flattenCatalog' class='member first-child not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='JSDB'>JSDB</span><br/><a href='source/jsdb.html#JSDB-method-flattenCatalog' target='_blank' class='view-source'>view source</a></div><a href='#!/api/JSDB-method-flattenCatalog' class='name expandable'>flattenCatalog</a>( <span class='pre'>flags, catalog, limits, cb</span> )<span class=\"signature\"></span></div><div class='description'><div class='short'>Flatten entire database for searching the catalog ...</div><div class='long'><p>Flatten entire database for searching the catalog</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>flags</span> : Object<div class='sub-desc'></div></li><li><span class='pre'>catalog</span> : Object<div class='sub-desc'></div></li><li><span class='pre'>limits</span> : Object<div class='sub-desc'></div></li><li><span class='pre'>cb</span> : Object<div class='sub-desc'></div></li></ul></div></div></div></div></div></div></div>","meta":{}});