<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">&quot;use strict&quot;;

// UNCLASSIFIED

<span id='JSDB'>/**
</span> * @class JSDB
 * @requires cluster
 * @requires enum
 * @requires mysql
 */

var // nodejs
CLUSTER = require(&quot;cluster&quot;);

var // 3rd party bindings
MYSQL = require(&quot;mysql&quot;);

var JSDB = module.exports = {

	errors: { //&lt; errors messages
		nillUpdate: new Error(&quot;nill update query&quot;),
		unsafeQuery: new Error(&quot;unsafe queries not allowed&quot;),
		unsupportedQuery: new Error(&quot;query not supported&quot;),
		invalidQuery: new Error(&quot;query invalid&quot;),
		noTable: new Error(&quot;dataset definition missing table name&quot;),
		noDB: new Error(&quot;no database connected&quot;),
		noLock: new Error(&quot;record lock ID missing&quot;),
		isUnlocked: new Error(&quot;record never locked&quot;),
		failLock: new Error(&quot;record locking failed&quot;),
		isLocked: new Error(&quot;record already locked&quot;),
		noExe: new Error(&quot;record execute undefined&quot;),
		noRecord: new Error(&quot;no record found&quot;)
	},

	fetchers: null, //&lt; defined by config 

	attrs: { //&lt; reserved for dataset attributes derived during config
		default: { // default dataset attributes
			sql: null, // sql connector
			query: &quot;&quot;, // sql query
			opts: null, // ?-options to sql query
			unsafeok: true, // allow/disallow unsafe queries
			trace: false, // trace ?-compressed sql queries
			journal: true, // attempt journally of updates to jou.table database
			ag: &quot;&quot;, // default aggregator &quot;&quot; implies &quot;least(?,1)&quot;
			index: { select: &quot;*&quot; }, // data search and index
			client: &quot;guest&quot;, // default client 
			track: false, // change journal tracking
			search: &quot;&quot; // key,key, .... fulltext keys to search
		}
	},

	config: function config(opts, cb) {
		// callback cb(sql connection)

		if (opts) Copy(opts, JSDB);

		Trace(&quot;CONFIG JSDB&quot;);

		if (mysql = JSDB.mysql) {

			mysql.pool = MYSQL.createPool(mysql.opts);

			sqlThread(function (sql) {

				ENUM.extend(sql.constructor, [// extend sql connector with useful methods
				// key getters
				getKeys, getFields, jsonKeys, searchKeys, geometryKeys, textKeys,

				// record getters
				getFirst, getEach, getAll,

				// misc
				context, cache, flattenCatalog,

				// bulk insert records
				beginBulk, endBulk,

				// job processing
				selectJob, deleteJob, updateJob, insertJob, executeJob]);

				sql.query(&quot;DELETE FROM openv.locks&quot;);

				//cb(sql);

				var attrs = JSDB.attrs,
				    dsFrom = &quot;app&quot;,
				    dsKey = &quot;Tables_in_&quot; + dsFrom;

				sql.query(&quot;SHOW TABLES FROM &quot; + dsFrom, function (err, recs) {
					recs.each(function (n, rec) {
						sql.searchKeys(ds = dsFrom + &quot;.&quot; + rec[dsKey], [], function (keys) {
							var attr = attrs[ds] = {};
							for (var key in attrs.default) {
								attr[key] = attrs.default[key];
							}attr.search = keys.join(&quot;,&quot;);
						});
					});

					if (cb) cb(sql);else sql.release();
				});
			});
		}

		return JSDB;
	},

	msql: null, //&lt; reserved for mysql connector

	io: { //&lt; reserved for socketio
		sockets: {
			emit: null
		}
	},

	thread: sqlThread

};

var // totem bindings
ENUM = require(&quot;enum&quot;).extend({
	String: [function Escape() {
		var q = &quot;`&quot;;
		return q + escape(this) + q;
	}],

	Array: [function Escape(slash, cb) {
		var q = &quot;`&quot;;

		if (cb) {
			var rtn = [];
			this.each(function (n, el) {
				rtn.push(cb(el));
			});
			return rtn.join(slash);
		} else return q + this.join(slash ? &quot;&quot; + q + slash + q : q + &quot;,&quot; + q) + q;
	}]
}),
    Copy = ENUM.copy,
    Each = ENUM.each,
    Log = console.log;

function DATASET(sql, ats) {
	// create dataset with given sql connector and attributes

	if (ats.constructor == String) ats = { table: ats };

	if (ats.table) {
		// default then override attributes			
		var attrs = JSDB.attrs[ats.table] || JSDB.attrs.default;

		for (var n in attrs) {
			switch (n) {
				case &quot;select&quot;:
				case &quot;update&quot;:
				case &quot;delete&quot;:
				case &quot;insert&quot;:
					this.prototype[n] = attrs[n];
					break;
				default:
					this[n] = attrs[n];
			}
		}this.sql = sql; // sql connector
		this.err = null; // default sql error response

		for (var n in ats) {
			this[n] = ats[n];
		}
	} else Trace(JSDB.errors.noTable + &quot;&quot;);
}

/*
CRUD interface ds.rec = req where req is an
		Error: respond with error req
		Array: respond with statis on inserting records req into ds
		Object: respond with status on updating ds with req record then respond with status
		null: respond with status on deleting records matching ds attributes
		Function: respond on req callback with ds records matching ds attributes
		&quot;X&quot;: dataset CRUD (ds.rec = ds.data) X=select,update,delete,create,execute 
		&quot;lock.X&quot;: lock/unlock record for dataset CRUD
*/
DATASET.prototype = {

	x: function xquery(opt, key, buf) {
		// query builder extends me.query and me.opts

		var me = this,
		    // target ds 
		keys = key.split(&quot; &quot;),
		    // key the the sql command
		ag = keys[1] || &quot;least(?,1)&quot;,
		    // method to aggregrate 
		type = opt ? opt.constructor : null;

		if (type) switch (keys[0]) {

			case &quot;BROWSE&quot;:

				var slash = &quot;_&quot;,
				    where = me.where,
				    nodeID = where.NodeID,
				    nodes = nodeID ? nodeID.split(slash) : [],
				    pivots = opt.split(&quot;,&quot;);

				me.group = nodes.length &gt;= pivots.length ? pivots.concat([&quot;ID&quot;]) : pivots.slice(0, nodes.length + 1);

				var name = pivots[nodes.length] || &quot;concat('ID',ID)&quot;;
				var path = me.group.Escape(&quot;,'&quot; + slash + &quot;',&quot;);

				me.query += &quot;, cast(&quot; + name + &quot; AS char) AS name, group_concat(DISTINCT &quot; + path + &quot;) AS NodeID&quot; + &quot;, count(ID) AS NodeCount &quot; + &quot;, '/tbd' AS `path`, 1 AS `read`, 1 AS `write`, 'v1' AS `group`, 1 AS `locked`&quot;;

				delete where.NodeID;
				nodes.each(function (n, node) {
					where[pivots[n] || &quot;ID&quot;] = node;
				});
				break;

			case &quot;PIVOT&quot;:

				var where = me.where,
				    nodeID = where.NodeID || &quot;root&quot;;

				if (nodeID == &quot;root&quot;) {
					me.query += &quot;, group_concat(DISTINCT ID) AS NodeID, count(ID) AS NodeCount,false AS leaf,true AS expandable,false AS expanded&quot;;
					me.group = opt;
					delete where.NodeID;
				} else {
					me.query += &quot;, '&quot; + nodeID + &quot;' as NodeID, 1 AS NodeCount, true AS leaf,true AS expandable,false AS expanded&quot;;
					me.where = &quot;instr(',&quot; + nodeID + &quot;,' , concat(',' , ID , ','))&quot;;
					me.group = null;
				}

				break;

			case &quot;&quot;:
			case &quot;IN&quot;:
			case &quot;WITH&quot;:

				if (me.search) {
					me.query += &quot;,MATCH(&quot; + me.search + &quot;) AGAINST('&quot; + opt + &quot;' &quot; + key + &quot;) AS Score&quot;;
					me.having = me.score ? &quot;Score&gt;&quot; + me.score : [&quot;Score&quot;];
					me.searching = opt;
				}
				break;

			case &quot;HAS&quot;:

				if (me.search) {
					me.query += &quot;,instr(concat(&quot; + me.search + &quot;),'&quot; + opt + &quot;') AS Score&quot;;
					me.having = me.score ? &quot;Score&gt;&quot; + me.score : [&quot;Score&quot;];
					me.searching = opt;
				}
				break;

			case &quot;SELECT&quot;:

				switch (type) {
					case Array:
						me.query += &quot; &quot; + key + &quot; ??&quot;;
						me.opts.push(opt);
						break;

					case String:
						if (opt == &quot;*&quot;) me.query += &quot; &quot; + key + &quot; *&quot;;else {
							me.query += &quot; &quot; + key + &quot; &quot; + opt;
							me.unsafe = true;
						}
						break;

					/*
     case Object:
     	
     	if (opt.idx) 
     		me.x(opt.idx, key);
     	
     	else {
     		me.query += ` ${key} *`;
     		me.x(opt.nlp, &quot;&quot;);
     		me.x(opt.bin, &quot;IN BINARY MODE&quot;);
     		me.x(opt.qex, &quot;WITH QUERY EXPANSION&quot;);
     		me.x(opt.has,&quot;HAS&quot;);
     		me.x(opt.browse, &quot;BROWSE&quot;);
     		me.x(opt.pivot, &quot;PIVOT&quot;);
     	}
     	break;
     */
				}

				me.x(me.index, &quot;INDEX&quot;);

				/*
    if ( me.geo )  // any geometry fields are returned as geojson
    	me.query += &quot;,&quot;+me.geo;
    */

				break;

			case &quot;JOIN&quot;:

				switch (type) {
					case Array:
						me.query += &quot; &quot; + mode + &quot; &quot; + key + &quot; ON ?&quot;;
						me.opts.push(opt);
						break;

					case String:
						me.query += &quot; &quot; + mode + &quot; &quot; + key + &quot; ON &quot; + opt;
						break;

					case Object:

						var mode = opt.left ? &quot;left&quot; : opt.right ? &quot;right&quot; : &quot;&quot;;

						me.query += &quot; &quot; + mode + &quot; &quot; + key + &quot; ? ON least(?,1)&quot;;

						for (var n in opt.on) {
							buf[n] = me.table + &quot;.&quot; + opt.on[n];
						}me.opts.push(opt[mode]);
						me.opts.push(buf);
						break;
				}
				break;

			case &quot;LIMIT&quot;:

				switch (type) {
					case Array:
						me.query += &quot; &quot; + key + &quot; ?&quot;;
						me.opts.push(opt);
						break;

					case String:
						me.query += &quot; &quot; + key + &quot; ?&quot;;
						me.opts.push(opt.split(&quot;,&quot;));
						break;

					case Object:
						me.query += &quot; &quot; + key + &quot; ?&quot;;
						me.opts.push([opt.start, opt.count]);
						break;
				}
				break;

			case &quot;WHERE&quot;:
			case &quot;HAVING&quot;:

				me.nowhere = false;

				switch (type) {
					case Array:

						me.query += &quot; &quot; + key + &quot; ??&quot;;
						me.opts.push(opt);
						break;

					case String:

						me.safe = false;
						me.query += &quot; &quot; + key + &quot; &quot; + opt;
						break;

					case Object:
						var rels = [];

						for (var n in opt) {
							// recast and remove unsafes
							var test = opt[n];

							if (test == null) {
								// using unsafe expression query (e.g. &amp;x&lt;10)
								me.safe = false;
								rels.push(n);
								delete opt[n];
							} else switch (test.constructor) {
								case Array:
									// using range query e.g. x=[min,max]

									delete opt[n];
									switch (test.length) {
										case 0:
											rels.push(n.Escape() + &quot; IS null&quot;);
											break;

										case 2:
											rels.push(n.Escape() + &quot; BETWEEN &quot; + test[0] + &quot; AND &quot; + test[1]);
											break;

										default:
									}
									break;

								case Object:
									// using search query e.g. x={nlp:pattern}

									var fld = n.Escape();
									if (pat = test.nlp) rels.push(&quot;MATCH(&quot; + fld + &quot;) AGAINST('&quot; + pat + &quot;')&quot;);else if (pat = test.bin) rels.push(&quot;MATCH(&quot; + fld + &quot;) AGAINST('&quot; + pat + &quot;') IN BINARY MODE&quot;);else if (pat = test.qex) rels.push(&quot;MATCH(&quot; + fld + &quot;) AGAINST('&quot; + pat + &quot;') WITH QUERY EXPANSION&quot;);else if (pat = test.has) rels.push(&quot;INSTR(&quot; + fld + &quot;, '&quot; + pat + &quot;')&quot;);else if (pat = test.like) rels.push(fld + &quot; LIKE '&quot; + pat + &quot;'&quot;);else break;

									delete opt[n];
									break;

								case String: // otherwise using safe query e.g x=value
								default:
							}
						}

						for (var n in opt) {
							// aggregate where clause using least,sum,etc
							rels.push(ag);
							me.opts.push(opt);
							break;
						}

						rels = rels.join(&quot; AND &quot;); // aggregate remaining clauses
						if (rels) me.query += &quot; &quot; + key + &quot; &quot; + rels;else me.nowhere = true;

						break;

					default:
						me.unsafe = true;
				}
				break;

			case &quot;ORDER&quot;:

				switch (type) {
					case Array:
						var by = [];
						opt.each(function (n, opt) {
							if (opt.property) by.push(opt.property + &quot; &quot; + opt.direction);else for (var n in opt) {
								by.push(n + &quot; &quot; + opt[n]);
							}
						});
						me.query += &quot; &quot; + key + &quot; &quot; + by.join(&quot;,&quot;);
						break;

					case String:
						me.query += &quot; &quot; + key + &quot; ??&quot;;
						me.opts.push(opt.split(&quot;,&quot;));
						break;

					case Object:
						break;
				}
				break;

			case &quot;SET&quot;:

				switch (type) {
					/*case Array:
     	me.safe = false;
     	me.query += ` ${key} ??`;
     	me.opts.push(opt);
     	break;*/

					case String:
						me.safe = false;
						me.query += &quot; &quot; + key + &quot; &quot; + opt;
						break;

					case Object:

						me.query += &quot; &quot; + key + &quot; ?&quot;;

						/*
      for (var n in opt) {  // object subkeys are json fields
      	var js = opt[n];
      	if (typeof js == &quot;object&quot;) {
      		var js = JSON.stringify(js);
      		me.query += `,json_merge(${n},${js})`;
      		delete opt[n];
      	}
      */

						me.opts.push(opt);
						break;

					default:
						me.unsafe = true;
				}
				break;

			case &quot;INDEX&quot;:
				//console.log(opt);
				me.x(opt.nlp, &quot;&quot;);
				me.x(opt.bin, &quot;IN BINARY MODE&quot;);
				me.x(opt.qex, &quot;WITH QUERY EXPANSION&quot;);
				me.x(opt.has, &quot;HAS&quot;);
				me.x(opt.browse, &quot;BROWSE&quot;);
				me.x(opt.pivot, &quot;PIVOT&quot;);
				break;

			default:

				switch (type) {
					case Array:
						me.query += &quot; &quot; + key + &quot; ??&quot;;
						me.opts.push(opt);
						break;

					case String:
						me.query += &quot; &quot; + key + &quot; ??&quot;;
						me.opts.push(opt.split(&quot;,&quot;));
						break;

					case Object:
						me.query += &quot; &quot; + key + &quot; ?&quot;;
						me.opts.push(opt);
						break;
				}
		}
	},

	update: function update(req, res) {
		// update record(s) in dataset

		function hawkChange(log) {
			// journal changes 
			sql.query(&quot;SELECT * FROM openv.hawks WHERE least(?,Power)&quot;, log).on(&quot;result&quot;, function (hawk) {
				//console.log(hawk);
				sql.query(&quot;INSERT INTO openv.journal SET ? ON DUPLICATE KEY UPDATE Updates=Updates+1&quot;, Copy({
					Hawk: hawk.Hawk, // moderator
					Power: hawk.Power, // moderator's level
					Updates: 1 // init number of updates made
				}, log));
			});
		}

		var me = this,
		    table = me.table,
		    ID = me.where.ID,
		    client = me.client,
		    sql = me.sql;

		me.opts = [];me.query = &quot;&quot;;me.safe = true;me.nowhere = true;

		me.x(table, &quot;UPDATE&quot;);
		me.x(req, &quot;SET&quot;);
		me.x(me.where, &quot;WHERE &quot; + me.ag);
		me.x(me.order, &quot;ORDER BY&quot;);

		if (me.nowhere) res(JSDB.errors.unsafeQuery);else if (Each(req)) // empty so ....
			res(JSDB.errors.nillUpdate);else if (me.safe || me.unsafeok) {
			/*
   //uncomment to disable journalling
   me.journal = false;
   */

			if (me.journal) {
				// attempt change journal if enabled
				hawkChange({ Dataset: me.table, Field: &quot;&quot; }); // journal entry for the record itself
				/*
    // uncomment to enable
    for (var key in req) { 		// journal entry for each record key being changed
    	hawk({Dataset:me.table, Field:key});
    	hawk({Dataset:&quot;&quot;, Field:key});
    }
    */
			}

			sql.query(me.query, me.opts, function (err, info) {

				if (res) res(err || info);

				if (JSDB.io.sockets.emit &amp;&amp; ID &amp;&amp; !err) // Notify clients of change.  
					JSDB.io.sockets.emit(&quot;update&quot;, {
						path: &quot;/&quot; + me.table + &quot;.db&quot;,
						body: req,
						ID: ID,
						from: client
						//flag: flags.client
					});
			});

			if (me.trace) Trace(me.query);
		} else if (res) res(JSDB.errors.unsafeQuery);
	},

	select: function select(req, res) {
		// select record(s) from dataset

		var me = this,
		    table = me.table,
		    client = me.client,
		    sql = me.sql;

		me.opts = [];me.query = &quot;&quot;;me.safe = true;me.nowhere = true;

		me.x(me.index.select, &quot;SELECT SQL_CALC_FOUND_ROWS&quot;);
		me.x(table, &quot;FROM&quot;);
		me.x(me.join, &quot;JOIN&quot;, {});
		me.x(me.where, &quot;WHERE &quot; + me.ag);
		me.x(me.having, &quot;HAVING &quot; + me.ag);
		me.x(me.order, &quot;ORDER BY&quot;);
		me.x(me.group, &quot;GROUP BY&quot;);
		me.x(me.limit, &quot;LIMIT&quot;);

		if (me.safe || me.unsafeok) switch (req.name) {
			case &quot;each&quot;:
				sql.query(me.query, me.opts).on(&quot;error&quot;, function (err) {
					req(err, me);
				}).on(&quot;result&quot;, function (rec) {
					req(rec, me);
				});
				break;

			case &quot;clone&quot;:
				var rtn = [];
				sql.query(me.query, me.opts, function (err, recs) {
					if (err) return req(err, me);

					recs.each(function (n, rec) {
						rtn.push(new Object(rec));
					});

					req(rtn, me);
				});
				break;

			case &quot;trace&quot;:
				Trace(me.query);
				sql.query(me.query, me.opts, function (err, recs) {
					req(err || recs, me);
				});
				break;

			case &quot;all&quot;:
			default:
				sql.query(me.query, me.opts, function (err, recs) {

					if (me.track &amp;&amp; me.searching &amp;&amp; recs) // track searches if tracking
						sql.query(&quot;INSERT INTO openv.tracks SET ? ON DUPLICATE KEY UPDATE Searched=Searched+1,Returned=Returned+?&quot;, [{ Client: client,
							Searching: me.searching,
							Searched: 0,
							Within: me.table,
							Returned: recs.length
						}, recs.length]);

					req(err || recs, me);
				});
		} else if (res) res(JSDB.errors.unsafeQuery);

		if (me.trace) Trace(me.query);
	},

	delete: function _delete(req, res) {
		// delete record(s) from dataset

		var me = this,
		    table = me.table,
		    ID = me.where.ID,
		    client = me.client,
		    sql = me.sql;

		me.opts = [];me.query = &quot;&quot;;me.safe = true;me.nowhere = true;

		me.x(table, &quot;DELETE FROM&quot;);
		me.x(me.where, &quot;WHERE &quot; + me.ag);

		if (me.nowhere) res(JSDB.errors.unsafeQuery);else if (me.safe || me.unsafeok) {
			me.sql.query(me.query, me.opts, function (err, info) {

				if (me.res) me.res(err || info);

				if (JSDB.io.sockets.emit &amp;&amp; ID &amp;&amp; !err) // Notify clients of change.  
					JSDB.io.sockets.emit(&quot;delete&quot;, {
						path: &quot;/&quot; + me.table + &quot;.db&quot;,
						ID: ID,
						from: me.client
						//flag: flags.client
					});
			});

			if (me.trace) Trace(me.query);
		} else if (res) res(JSDB.errors.unsafeQuery);
	},

	insert: function insert(req, res) {
		// insert record(s) into dataset

		var me = this,
		    table = me.table,
		    ID = me.where.ID,
		    client = me.client,
		    sql = me.sql;

		me.opts = [];me.query = &quot;&quot;;me.safe = true;me.nowhere = true;

		if (!req.length) req = [{}]; // force at least one insert attempt

		req.each(function (n, rec) {
			// insert each record

			sql.query(me.query = Each(rec) // trap empty records
			? &quot;INSERT INTO ?? VALUE ()&quot; : &quot;INSERT INTO ?? SET ?&quot;, [table, rec], function (err, info) {

				if (!n &amp;&amp; res) {
					// respond only to first insert
					res(err || info);

					if (JSDB.io.sockets.emit &amp;&amp; !err) // Notify clients of change.  
						JSDB.io.sockets.emit(&quot;insert&quot;, {
							path: &quot;/&quot; + me.table + &quot;.db&quot;,
							body: rec,
							ID: info.insertId,
							from: client
							//flag: flags.client
						});
				}
			});

			if (me.trace) Trace(me.query);
		});
	},

	get rec() {// reserved
	},

	unlock: function unlock(ID, cb, lockcb) {
		// unlock record 
		var me = this,
		    sql = me.sql,
		    lockID = { Lock: me.table + &quot;.&quot; + ID, Client: me.client };

		if (ID) sql.query( // attempt to unlock a locked record
		&quot;DELETE FROM openv.locks WHERE least(?)&quot;, lockID, function (err, info) {

			if (err) me.res(JSDB.errors.failLock);else if (info.affectedRows) {
				// unlocked so commit queued queries
				cb();
				sql.query(&quot;COMMIT&quot;);
			} else if (lockcb) // attempt to lock this record
				sql.query(&quot;INSERT INTO openv.locks SET ?&quot;, lockID, function (err, info) {

					if (err) me.res(JSDB.errors.isLocked);else sql.query(&quot;START TRANSACTION&quot;, function (err) {
						// queue this transaction
						lockcb();
					});
				});else // record was never locked
				me.res(JSDB.errors.isUnlocked);
		});else me.res(JSDB.errors.noLock);
	},

	set rec(req) {
		// crud interface
		var me = this,
		    res = me.res;

		if (req) switch (req.constructor) {
			case Error:

				if (res) res(req);
				break;

			case Array:

				me.insert(req, res);
				break;

			case Object:

				me.update(req, res);
				break;

			case Function:
				me.select(req, res);
				break;

			case String:

				if (me.trace) Trace(req.toUpperCase() + &quot; &quot; + me.table + &quot; FOR &quot; + me.client);

				switch (req) {
					case &quot;lock.select&quot;:

						me.rec = function (recs) {
							// get records

							if (recs.constructor == Error) res(recs);else if (rec = recs[0]) me.unlock(rec.ID, function () {
								// unlocked
								res(rec);
							}, function () {
								// locked
								res(rec);
							});else res(JSDB.errors.noRecord);
						};
						break;

					case &quot;lock.delete&quot;:

						me.unlock(me.where.ID, function () {
							// delete if unlocked
							me.rec = null;
						});
						break;

					case &quot;lock.insert&quot;:

						me.unlock(me.where.ID, function () {
							// insert if unlocked
							me.rec = [me.data];
						});
						break;

					case &quot;lock.update&quot;:

						me.unlock(me.where.ID, function () {
							// update if unlocked
							me.rec = me.data;
						});
						break;

					case &quot;lock.execute&quot;:

						res(JSDB.errors.noExe);
						break;

					case &quot;select&quot;:
						me.rec = me.res;break;
					case &quot;update&quot;:
						me.rec = me.data;break;
					case &quot;delete&quot;:
						me.rec = null;break;
					case &quot;insert&quot;:
						me.rec = [me.data];break;
					case &quot;execute&quot;:
						me.rec = JSDB.errors.unsupportedQuery;break;

					default:
						me.rec = JSDB.errors.invalidQuery;
				}

		} else me.delete(req, res);

		return this;
	}

};

function getKeys(table, type, keys, cb) {
	this.query(&quot;SHOW KEYS FROM &quot; + table + &quot; WHERE ?&quot;, { Index_type: type }, function (err, recs) {
		recs.each(function (n, rec) {
			keys.push(rec.Column_name);
		});
		cb(keys);
	});
}

function getFields(table, where, keys, cb) {
	this.query(&quot;SHOW FULL FIELDS FROM &quot; + table + &quot; WHERE least(?,1)&quot;, where, function (err, recs) {
		recs.each(function (n, rec) {
			keys.push(rec.Field);
		});
		cb(keys);
	});
}

function jsonKeys(table, keys, cb) {
	this.getFields(table, { Type: &quot;json&quot; }, keys, cb);
}

function textKeys(table, keys, cb) {
	this.getFields(table, { Type: &quot;mediumtext&quot; }, keys, cb);
}

function searchKeys(table, keys, cb) {
	this.getKeys(table, &quot;fulltext&quot;, keys, cb);
}

function geometryKeys(table, keys, cb) {
	this.getFields(table, { Type: &quot;geometry&quot; }, keys, cb);
}

function getFirst(trace, query, args, cb) {
	// callback cb(rec) or cb(null) if error
	var q = query ? this.query(smartTokens(query, args), args, function (err, recs) {
		cb(err ? null : recs[0]);
	}) : { sql: &quot;IGNORE&quot;, on: function on() {} };

	if (trace) Trace(trace + &quot; &quot; + q.sql);
	return q;
}

function getEach(trace, query, args, cb) {
	// callback cb(rec) with each rec
	var q = query ? this.query(smartTokens(query, args), args).on(&quot;result&quot;, cb) : { sql: &quot;IGNORE&quot;, on: function on() {} };

	if (trace) Trace(trace + &quot; &quot; + q.sql);
	return q;
}

function getAll(trace, query, args, cb) {
	// callback cb(recs) if no error
	var q = query ? this.query(query, args, function (err, recs) {
		if (!err) if (cb) cb(recs);
	}) : { sql: &quot;IGNORE&quot;, on: function on() {} };

	if (trace) Trace(trace + &quot; &quot; + q.sql);
	return q;
}

function context(ctx, cb) {
	// callback cb(dsctx) with a JSDB context
	var sql = this,
	    dsctx = {};

	Each(ctx, function (dskey, dsats) {
		dsctx[dskey] = new DATASET(sql, dsats);
	});
	cb(dsctx);
}

function sqlThread(cb) {
	// callback cb(sql) with a sql connection

	function dummyConnector() {
		var This = this,
		    err = JSDB.errors.noDB;

		this.query = function (q, args, cb) {
			Trace(&quot;NODB &quot; + q);
			if (cb) cb(err);else if (args &amp;&amp; args.constructor == Function) args(err);

			return This;
		};

		this.on = function (ev, cb) {
			return This;
		};

		this.sql = &quot;DUMMY SQL CONNECTOR&quot;;

		this.release = function () {
			return This;
		};

		this.createPool = function (opts) {
			return null;
		};
	}

	var mysql = JSDB.mysql;

	if (mysql) {
		if (mysql.pool) mysql.pool.getConnection(function (err, sql) {
			if (err) {
				Log({
					sqlpool: err,
					total: mysql.pool._allConnections.length,
					free: mysql.pool._freeConnections.length,
					queue: mysql.pool._connectionQueue.length
				});

				/*mysql.pool.end( function (err) {
    	mysql.pool = MYSQL.createPool(mysql.opts);
    }); */

				cb(new dummyConnector(err));
			} else cb(sql);
		});else cb(MYSQL.createConnection(mysql.opts) || new dummyConnector());
	} else cb(new dummyConnector());
}

/*
Implements generic cache.  Looks for cache given opts.key and, if found, returns cached results on cb(results);
otherwse, if not found, returns results via opts.make(fetchers, opts.parms, cb).  If cacheing fails, then opts.default 
is returned.  The returned results will always contain a results.ID for its cached ID.  If a opts.default is not provided,
then the cb callback in not made.
*/

function cache(opts, cb) {
	var sql = this;

	if (opts.key) sql.first(&quot;&quot;, &quot;SELECT Results FROM app.cache WHERE least(?,1) LIMIT 1&quot;, [opts.key], function (rec) {

		if (rec) try {
			cb(JSON.parse(rec.Results));
		} catch (err) {
			if (opts.default) cb(Copy(opts.default, { ID: null }));
		} else if (opts.make &amp;&amp; opts.parms) opts.make(JSDB.fetchers, opts.parms, function (res) {

			if (res) sql.query(&quot;INSERT INTO app.cache SET Added=now(), Results=?, ?&quot;, [JSON.stringify(res || opts.default), opts.key], function (err, info) {
				cb(Copy(res, { ID: err ? 0 : info.insertId }));
			});else if (opts.default) cb(Copy(opts.default, { ID: null }));
		});else if (opts.default) cb(Copy(opts.default, { ID: null }));
	});else if (opts.default) cb(Copy({ ID: null }, opts.default));
}

//============== Build insert records

function beginBulk() {
	this.query(&quot;START TRANSACTION&quot;);
	this.query(&quot;SET GLOBAL sync_binlog=0&quot;);
	this.query(&quot;SET GLOBAL innodb-flush-log-at-trx-commit=0&quot;);
}

function endBulk() {
	this.query(&quot;COMMIT&quot;);
	this.query(&quot;SET GLOBAL sync_binlog=1&quot;);
	this.query(&quot;SET GLOBAL innodb-flush-log-at-trx-commit=1&quot;);
}

//=========== Job queue interface
/*
 * Job queue interface
 * 
 * select(where,cb): route valid jobs matching sql-where clause to its assigned callback cb(job).
 * execute(client,job,cb): create detector-trainging job for client with callback to cb(job) when completed.
 * update(where,rec,cb): set attributes of jobs matching sql-where clause and route to callback cb(job) when updated.
 * delete(where,cb): terminate jobs matching sql-whereJob cluase then callback cb(job) when terminated.
 * insert(job,cb): add job and route to callback cb(job) when executed.
 */

JSDB.queues = {};

/*
@method selectJob
@param {Object} req job query
@param {Function} cb callback(rec) when job departs
*
* Callsback cb(rec) for each queuing rec matching the where clause.
* &gt;&gt;&gt; Not used but needs work 
 */
function selectJob(where, cb) {

	// route valid jobs matching sql-where clause to its assigned callback cb(req).
	var sql = this;

	sql.query(where ? &quot;SELECT *,profiles.* FROM queues LEFT JOIN profiles ON queues.Client=profiles.Client WHERE &quot; + where + &quot; ORDER BY QoS,Priority&quot; : &quot;SELECT *,profiles.* FROM queues LEFT JOIN profiles ON queues.Client=profiles.Client ORDER BY QoS,Priority&quot;).on(&quot;error&quot;, function (err) {
		Log(err);
	}).on(&quot;result&quot;, function (rec) {
		cb(rec);
	});
}

/*
@method updateJob
@param {Object} req job query
@param {Function} cb callback(sql,job) when job departs
*
* Adjust priority of jobs matching sql-where clause and route to callback cb(req) when updated.
* &gt;&gt;&gt; Not used but needs work 
*/
function updateJob(req, cb) {

	var sql = this;

	sql.selectJob(req, function (job) {

		cb(job.req, function (ack) {

			if (req.qos) sql.query(&quot;UPDATE queues SET ? WHERE ?&quot;, [{
				QoS: req.qos,
				Notes: ack }, { ID: job.ID }]);else if (req.inc) sql.query(&quot;UPDATE queues SET ?,Priority=max(0,min(5,Priority+?)) WHERE ?&quot;, [{
				Notes: ack }, req.inc, { ID: job.ID }]);

			if (req.qos) {
				// move req to another qos queue
				delete JSDB.queues[job.qos].batch[job.ID];
				job.qos = req.qos;
				JSDB.queues[qos].batch[job.ID] = job;
			}

			if (req.pid) CP.exec(&quot;renice &quot; + req.inc + &quot; -p &quot; + job.pid);
		});
	});
}

/*
@method deleteJob
@param {Object} req job query
@param {Function} cb callback(sql,job) when job departs
* &gt;&gt;&gt; Not used but needs work
*/
function deleteJob(req, cb) {

	var sql = this;
	sql.selectJob(req, function (job) {

		cb(sql, job, function (ack) {
			sql.query(&quot;UPDATE queues SET Departed=now(), Age=(now()-Arrived)/3600e3, Notes=concat(Notes,'stopped') WHERE ?&quot;, {
				Task: job.task,
				Client: job.client,
				Class: job.class,
				QoS: job.qos
			});

			delete JSDB.queues[job.qos].batch[job.priority];

			if (job.pid) CP.exec(&quot;kill &quot; + job.pid); // kill a spawned req
		});
	});
}

function insertJob(job, cb) {
	/*
 @method insertJob
 @param {Object} job arriving job
 @param {Function} cb callback(sql,job) when job departs
 
 Adds job to the specified (client,class,qos,task) queue.  A departing job will execute the supplied 
 callback cb(sql,job) on a new sql thread (or spawn a new process if job.cmd provided).  The job
 is regulated by its job.rate [s] (0 disables regulation). If the client's job.credit has been exhausted, the
 job is added to the queue, but not to the regulator.  Queues are periodically monitored to store 
 billing information.  When using insertJob within an async loop, the caller should pass a cloned copy
 of the job.
  */
	function cpuavgutil() {
		// compute average cpu utilization
		var avgUtil = 0;
		var cpus = OS.cpus();

		cpus.each(function (n, cpu) {
			idle = cpu.times.idle;
			busy = cpu.times.nice + cpu.times.sys + cpu.times.irq + cpu.times.user;
			avgUtil += busy / (busy + idle);
		});
		return avgUtil / cpus.length;
	}

	function regulate(job, cb) {
		// regulate job (spawn if job.cmd provided)

		var queue = JSDB.queues[job.qos]; // get job's qos queue

		if (!queue) // prime the queue if it does not yet exist
			queue = JSDB.queues[job.qos] = new Object({
				timer: 0,
				batch: {},
				rate: job.qos,
				client: {}
			});

		var client = queue.client[job.client]; // update client's bill

		if (!client) client = queue.client[job.client] = new Object({ bill: 0 });

		client.bill++;

		var batch = queue.batch[job.priority]; // get job's priority batch

		if (!batch) batch = queue.batch[job.priority] = new Array();

		batch.push(Copy(job, { cb: cb, holding: false })); // add job to queue

		if (!queue.timer) // restart idle queue
			queue.timer = setInterval(function (queue) {
				// setup periodic poll for this job queue

				var job = null;
				for (var priority in queue.batch) {
					// index thru all priority batches
					var batch = queue.batch[priority];

					job = batch.pop(); // last-in first-out

					if (job) {
						// there is a departing job 
						//Log(&quot;job depth=&quot;+batch.length+&quot; job=&quot;+[job.name,job.qos]);

						if (job.holding) // in holding / stopped state so requeue it
							batch.push(job);else if (job.cmd) {
							// this is a spawned job so spawn and hold its pid
							job.pid = CP.exec(job.cmd, { cwd: &quot;./public/dets&quot;, env: process.env }, function (err, stdout, stderr) {

								job.err = err || stderr || stdout;

								if (job.cb) job.cb(job); // execute job's callback
							});
						} else // execute job's callback
							if (job.cb) job.cb(job);

						break;
					}
				}

				if (!job) {
					// an empty queue goes idle
					clearInterval(queue.timer);
					queue.timer = null;
				}
			}, queue.rate * 1e3, queue);
	}

	var sql = this;

	if (job.qos) // regulated job
		sql.query( // insert job into queue or update job already in queue
		&quot;INSERT INTO app.queues SET ? ON DUPLICATE KEY UPDATE &quot; + &quot;Departed=null, Work=Work+1, State=Done/Work*100, Age=(now()-Arrived)/3600e3, ?&quot;, [{
			// mysql unique keys should not be null
			Client: job.client || &quot;&quot;,
			Class: job.class || &quot;&quot;,
			Task: job.task || &quot;&quot;,
			QoS: job.qos || 0,
			// others 
			State: 0,
			Arrived: new Date(),
			Departed: null,
			Marked: 0,
			Name: job.name,
			Age: 0,
			Classif: &quot;&quot;,
			//Util: cpuavgutil(),
			Priority: job.priority || 0,
			Notes: job.notes,
			Finished: 0,
			Billed: 0,
			Funded: job.credit ? 1 : 0,
			Work: 1,
			Done: 0
		}, {
			Notes: job.notes,
			Task: job.task || &quot;&quot;
		}], function (err, info) {
			// increment work backlog for this job

			//Log([job,err,info]);

			if (err) return Log(err);

			job.ID = info.insertId || 0;

			if (job.credit) // client still has credit so place it in the regulators
				regulate(job, function (job) {
					// provide callback when job departs
					sqlThread(function (sql) {
						// callback on new sql thread
						cb(sql, job);

						sql.query( // reduce work backlog and update cpu utilization
						&quot;UPDATE app.queues SET Age=now()-Arrived,Done=Done+1,State=Done/Work*100 WHERE ?&quot;, [
						// {Util: cpuavgutil()}, 
						{ ID: job.ID //jobID 
						}]);

						sql.release();
						/*
      sql.query(  // mark job departed if no work remains
      	&quot;UPDATE app.queues SET Departed=now(), Notes='finished', Finished=1 WHERE least(?,Done=Work)&quot;, 
      	{ID:job.ID} //jobID
      );
      */
					});
				});
		});else {
		// unregulated so callback on existing sql thread
		job.ID = 0;
		cb(sql, job);
	}
}

function executeJob(req, exe) {

	function flip(job) {
		// flip job holding state
		if (queue = JSDB.queues[job.qos]) // get job's qos queue
			if (batch = queue.batch[job.priority]) // get job's priority batch
				batch.each(function (n, test) {
					// matched jobs placed into holding state
					if (test.task == job.task &amp;&amp; test.client == job.client &amp;&amp; test.class == job.class) test.holding = !test.holding;
				});
	}

	var sql = req.sql,
	    query = req.query;

	sql.query(&quot;UPDATE ??.queues SET Holding = NOT Holding WHERE ?&quot;, { ID: query.ID }, function (err) {

		if (!err) flip();
	});
}

<span id='JSDB-method-flattenCatalog'>/**
</span> @method flattenCatalog
 Flatten entire database for searching the catalog
 * */
function flattenCatalog(flags, catalog, limits, cb) {

	function flatten(sql, rtns, depth, order, catalog, limits, cb) {
		var table = order[depth];

		if (table) {
			var match = catalog[table];
			var filter = cb.filter(match);

			var quality = &quot; using &quot; + (filter ? filter : &quot;open&quot;) + &quot; search limit &quot; + limits.records;

			Trace(&quot;CATALOG &quot; + table + quality + &quot; RECS &quot; + rtns.length, sql);

			var query = filter ? &quot;SELECT SQL_CALC_FOUND_ROWS &quot; + match + &quot;,ID, &quot; + filter + &quot; FROM ?? HAVING Score&gt;? LIMIT 0,?&quot; : &quot;SELECT SQL_CALC_FOUND_ROWS &quot; + match + &quot;,ID FROM ?? LIMIT 0,?&quot;;

			var args = filter ? [table, limits.score, limits.records] : [table, limits.records];

			Trace(sql.query(query, args, function (err, recs) {

				if (err) {
					rtns.push({
						ID: rtns.length,
						Ref: table,
						Name: &quot;error&quot;,
						Dated: limits.stamp,
						Searched: 0,
						Link: (table + &quot;.db&quot;).tag(&quot;a&quot;, { href: &quot;/&quot; + table + &quot;.db&quot; }),
						Content: err + &quot;&quot;
					});

					flatten(sql, rtns, depth + 1, order, catalog, limits, cb);
				} else sql.query(&quot;select found_rows()&quot;).on('result', function (stat) {

					recs.each(function (n, rec) {
						rtns.push({
							ID: rtns.length,
							Ref: table,
							Name: table + &quot;.&quot; + rec.ID,
							Dated: limits.stamp,
							Quality: recs.length + &quot; of &quot; + stat[&quot;found_rows()&quot;] + quality,
							Link: table.tag(&quot;a&quot;, { href: &quot;/&quot; + table + &quot;.db?ID=&quot; + rec.ID }),
							Content: JSON.stringify(rec)
						});
					});

					flatten(sql, rtns, depth + 1, order, catalog, limits, cb);
				});
			}));
		} else cb.res(rtns);
	}

	var sql = this,
	    rtns = [];
	/*limits = {
 	records: 100,
 	stamp: new Date()
 	//pivots: flags._pivot || &quot;&quot;
 };*/

	flatten(sql, rtns, 0, FLEX.listify(catalog), catalog, limits, {
		res: cb,

		filter: function filter(search) {
			return &quot;&quot;; //Builds( &quot;&quot;, search, flags);  //reserved for nlp, etc filters
		} });
}

function smartTokens(q, opts) {
	return q;
	var optn = 0,
	    args = opts.constructor == Array ? null : opts;

	return q.replace(/\?/g, function (mat, idx) {
		var tests = [&quot;?&quot;],
		    quote = &quot;`&quot;,
		    opt = args || opts[optn++];

		if (opt.constructor == Object) {
			Each(opt, function (key, val) {
				switch (op = key.substr(-1)) {
					case &quot;&lt;&quot;:
					case &quot;&gt;&quot;:
					case &quot;!&quot;:
						tests.push(key + &quot;=&quot; + val);
						delete opt[key];
						break;
					default:
						if (!val) {
							tests.push(key);
							delete opt[key];
						}
				}
			});

			Log(&quot;smart&quot;, tests, q);
			return tests.join(&quot;,&quot;);
		} else return &quot;?&quot;;
	});
}

function Trace(msg, sql) {
	ENUM.trace(&quot;V&gt;&quot;, msg, sql);
}</pre>
</body>
</html>
